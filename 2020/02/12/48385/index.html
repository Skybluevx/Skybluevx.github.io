<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.shuoshuoyun.cn","root":"/","scheme":"Gemini","version":"8.0.0-rc.4","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"path":"search.xml"};
  </script>

  <meta name="description" content="版本2.0.0.dev0 本文机器翻译，仅供个人参考，详情请看官网地址 欢迎使用Kivy的文档。 Kivy是一个用于快速开发的开源软件库配备新颖用户界面的应用程序，例如多点触控应用程序。 我们建议您开始使用入门。然后转到《编程指南》。我们如果您不耐烦，也可以创建一个应用程序。 您可能想知道为什么您应该对使用Kivy感兴趣。 有一份文件概述我们鼓励您阅读我们的哲学，以及详细的体系结构概述。 如果您想">
<meta property="og:type" content="article">
<meta property="og:title" content="Kivy参考文档（一）">
<meta property="og:url" content="https://blog.shuoshuoyun.cn/2020/02/12/48385/index.html">
<meta property="og:site_name" content="木今心">
<meta property="og:description" content="版本2.0.0.dev0 本文机器翻译，仅供个人参考，详情请看官网地址 欢迎使用Kivy的文档。 Kivy是一个用于快速开发的开源软件库配备新颖用户界面的应用程序，例如多点触控应用程序。 我们建议您开始使用入门。然后转到《编程指南》。我们如果您不耐烦，也可以创建一个应用程序。 您可能想知道为什么您应该对使用Kivy感兴趣。 有一份文件概述我们鼓励您阅读我们的哲学，以及详细的体系结构概述。 如果您想">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.ax1x.com/2020/02/12/1b6xkn.png">
<meta property="og:image" content="https://s2.ax1x.com/2020/02/13/1qSgc6.png">
<meta property="og:image" content="https://s2.ax1x.com/2020/02/13/1LYIDx.png">
<meta property="og:image" content="https://s2.ax1x.com/2020/02/13/1L0xfK.png">
<meta property="og:image" content="https://s2.ax1x.com/2020/02/15/1xwwnS.jpg">
<meta property="og:image" content="https://s2.ax1x.com/2020/02/15/1xXY6I.png">
<meta property="og:image" content="https://s2.ax1x.com/2020/02/15/1xjGUU.png">
<meta property="article:published_time" content="2020-02-12T14:57:07.000Z">
<meta property="article:modified_time" content="2020-02-12T14:57:07.000Z">
<meta property="article:author" content="十丿叶">
<meta property="article:tag" content="kivy">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.ax1x.com/2020/02/12/1b6xkn.png">

<link rel="canonical" href="https://blog.shuoshuoyun.cn/2020/02/12/48385/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Kivy参考文档（一） | 木今心</title>
  


  <script data-pjax>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?07fdd26aa39a30ab9c8d553e566c50ee";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">木今心</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">站在巨人的肩上</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">15</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">11</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">13</span></a>

  </li>
        
            
  <li class="menu-item menu-item-config">

    <a href="/config/" rel="section"><i class="fa fa-user-cog fa-fw"></i>配置</a>

  </li>


      
        
            
  <li class="menu-item menu-item-write_skills">

    <a href="/write_skills/" rel="section"><i class="fa fa-rocket fa-fw"></i>编辑技巧</a>

  </li>


      
        
            
  <li class="menu-item menu-item-knowledge-handbook">

    <a href="/knowledge/" rel="section"><i class="fas fa-quran fa-fw"></i>知识手册</a>

  </li>


      
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于作者</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第一部分-KIVY-项目"><span class="nav-text">第一部分 KIVY 项目</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#哲学"><span class="nav-text">哲学</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#何必？"><span class="nav-text">何必？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#新鲜"><span class="nav-text">新鲜</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快速"><span class="nav-text">快速</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#灵活"><span class="nav-text">灵活</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#专注"><span class="nav-text">专注</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#已资助"><span class="nav-text">已资助</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#免费"><span class="nav-text">免费</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#贡献"><span class="nav-text">贡献</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#讨论区"><span class="nav-text">讨论区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#行为守则"><span class="nav-text">行为守则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反馈"><span class="nav-text">反馈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#报告问题"><span class="nav-text">报告问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码贡献"><span class="nav-text">代码贡献</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#编码风格"><span class="nav-text">编码风格</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#性能"><span class="nav-text">性能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Git-amp-GitHub"><span class="nav-text">Git &amp; GitHub</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码工作流程"><span class="nav-text">代码工作流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文档贡献"><span class="nav-text">文档贡献</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二部分-编程指南"><span class="nav-text">第二部分 编程指南</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Kivy-基础"><span class="nav-text">Kivy 基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1.1"><span class="nav-text">Kivy 基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#安装Kivy环境"><span class="nav-text">安装Kivy环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建一个应用程序"><span class="nav-text">创建一个应用程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kivy-App生命周期"><span class="nav-text">Kivy App生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行应用程序"><span class="nav-text">运行应用程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定制应用程序"><span class="nav-text">定制应用程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#控制环境"><span class="nav-text">控制环境</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#路径控制"><span class="nav-text">路径控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组态"><span class="nav-text">组态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将核心限制为具体实施"><span class="nav-text">将核心限制为具体实施</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指标"><span class="nav-text">指标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图形"><span class="nav-text">图形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件循环"><span class="nav-text">事件循环</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Kivy-配置"><span class="nav-text">Kivy 配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查找配置文件"><span class="nav-text">查找配置文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本地配置"><span class="nav-text">本地配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#了解配置令牌"><span class="nav-text">了解配置令牌</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#建筑概述"><span class="nav-text">建筑概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#核心提供者和输入提供者"><span class="nav-text">核心提供者和输入提供者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图形-1"><span class="nav-text">图形</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#核心"><span class="nav-text">核心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UIX（小部件和布局）"><span class="nav-text">UIX（小部件和布局）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模组"><span class="nav-text">模组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#输入事件（触摸）"><span class="nav-text">输入事件（触摸）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小部件和事件调度"><span class="nav-text">小部件和事件调度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#活动和属性"><span class="nav-text">活动和属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#事件分派器简介"><span class="nav-text">事件分派器简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主循环"><span class="nav-text">主循环</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#安排重复事件"><span class="nav-text">安排重复事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计划一个事件"><span class="nav-text">计划一个事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#触发事件"><span class="nav-text">触发事件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小部件事件"><span class="nav-text">小部件事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建自定义事件"><span class="nav-text">创建自定义事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#附加回调"><span class="nav-text">附加回调</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#物业介绍"><span class="nav-text">物业介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#财产申报"><span class="nav-text">财产申报</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调度属性事件"><span class="nav-text">调度属性事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复合性质"><span class="nav-text">复合性质</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输入管理"><span class="nav-text">输入管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#输入架构"><span class="nav-text">输入架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运动事件配置文件"><span class="nav-text">运动事件配置文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#触摸事件"><span class="nav-text">触摸事件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#触控事件基础"><span class="nav-text">触控事件基础</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#座标"><span class="nav-text">座标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#触摸形状"><span class="nav-text">触摸形状</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#双击"><span class="nav-text">双击</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三连击"><span class="nav-text">三连击</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#抓住触摸事件"><span class="nav-text">抓住触摸事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#触摸事件管理"><span class="nav-text">触摸事件管理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#游戏杆事件"><span class="nav-text">游戏杆事件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#游戏杆事件基础"><span class="nav-text">游戏杆事件基础</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#操纵杆输入"><span class="nav-text">操纵杆输入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#游戏杆调试"><span class="nav-text">游戏杆调试</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="十丿叶"
      src="/images/touxiang.jpg">
  <p class="site-author-name" itemprop="name">十丿叶</p>
  <div class="site-description" itemprop="description">-------<椿去湫来，海棠花开>--------------<椿还鲲命，谁还湫情>-------</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NreWJsdWV2eA==" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Skybluevx"><i class="fab fa-github fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOjEzNzI3NTU0NzJAcXEuY29t" title="E-Mail → mailto:1372755472@qq.com"><i class="fa fa-envelope fa-fw"></i></span>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></span>
  </div>



      </section>
        <div class="back-to-top animated">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NreWJsdWV2eA==" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.shuoshuoyun.cn/2020/02/12/48385/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jpg">
      <meta itemprop="name" content="十丿叶">
      <meta itemprop="description" content="-------<椿去湫来，海棠花开>--------------<椿还鲲命，谁还湫情>-------">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="木今心">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Kivy参考文档（一）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-12 22:57:07" itemprop="dateCreated datePublished" datetime="2020-02-12T22:57:07+08:00">2020-02-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Kivy/" itemprop="url" rel="index"><span itemprop="name">Kivy</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/02/12/48385/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/02/12/48385/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>26k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>版本2.0.0.dev0</p>
<p><strong>本文机器翻译，仅供个人参考，详情请看</strong><br><span class="exturl" data-url="aHR0cDovL3d3dy5raXZ5Lm9yZw==">官网地址<i class="fa fa-external-link-alt"></i></span></p>
<p>欢迎使用Kivy的文档。 Kivy是一个用于快速开发的开源软件库配备新颖用户界面的应用程序，例如多点触控应用程序。</p>
<p>我们建议您开始使用入门。然后转到<a href="#1.1">《编程指南》</a>。我们<br>如果您不耐烦，也可以<a href="#2.0">创建一个应用程序</a>。</p>
<p>您可能想知道为什么您应该对使用Kivy感兴趣。 有一份文件概述我们鼓励您阅读我们的哲学，以及详细的体系结构概述。</p>
<p>如果您想为Kivy做出贡献，请务必阅读Contributing。 如果您的疑虑未在文档，请随时与我们联系。</p>
<a id="more"></a>

<h1 id="第一部分-KIVY-项目"><a href="#第一部分-KIVY-项目" class="headerlink" title="第一部分 KIVY 项目"></a>第一部分 KIVY 项目</h1><p>文档的这一部分说明了Kivy设计的基本思想以及为什么要这么用它。</p>
<h2 id="哲学"><a href="#哲学" class="headerlink" title="哲学"></a>哲学</h2><p>如果您想知道Kivy到底是什么，以及它与其他解决方案的不同之处，这文件适合您。</p>
<h3 id="何必？"><a href="#何必？" class="headerlink" title="何必？"></a>何必？</h3><p>您为什么要使用Kivy？ 毕竟，有很多很棒的工具包（或框架或平台）免费提供。 您有Qt和Flash，仅举两个应用程序的不错选择发展。 这些众多解决方案中的许多解决方案已经支持Multi-Touch，那么它的作用是什么？奇异果特别值得一用吗？</p>
<h4 id="新鲜"><a href="#新鲜" class="headerlink" title="新鲜"></a>新鲜</h4><p>Kivy是为今天和明天制作的。 诸如Multi-Touch之类的新颖输入法已经越来越多重要。 我们从头开始创建Kivy，专门用于这种交互。 这意味着我们能够从人机交互的角度重新思考许多事情，而较旧的（并非意味着“过时的”，而不是“完善的”）工具包具有其传统，这通常是一种负担。 我们没有尝试迫使这种使用计算机的新方法成为现有模型的紧身胸衣（例如单指针）鼠标互动）。 我们希望让它蓬勃发展，并让您探索各种可能性。 这才是真正的使Kivy与众不同。</p>
<h4 id="快速"><a href="#快速" class="headerlink" title="快速"></a>快速</h4><p>Kivy很快。 这适用于应用程序开发和应用程序执行速度。 我们已经优化Kivy在很多方面。 我们在C层上实现了对时间要求严格的功能，以利用现有编译器的功能。更重要的是，我们还使用智能算法将成本降到最低操作。在我们的上下文中，我们也会在有意义的地方使用GPU。 计算能力在某些任务和算法方面，当今的图形卡的数量远远超过了当今的CPU。画画。 这就是为什么我们尝试让GPU尽可能多地完成工作，从而增加性能相当。</p>
<h4 id="灵活"><a href="#灵活" class="headerlink" title="灵活"></a>灵活</h4><p>Kivy非常灵活。 这意味着它可以在各种不同的设备上运行，包括Android驱动的智能手机和平板电脑。 我们支持所有主要操作系统（Windows，Linux，OS X）。 灵活一点也意味着Kivy的快速发展使其可以迅速适应新技术。 多于曾经，我们增加了对新的外部设备和软件协议的支持，有时甚至他们被释放了。 最后，Kivy的灵活性还在于它可以与多种不同的第三方解决方案。 例如，在Windows上，我们支持WM_TOUCH，意味着任何具有Windows 7 Pen＆Touch驱动程序的设备都可以与Kivy一起使用。 在OS X上您可以使用Apple具备Multi-Touch功能的设备，例如触控板和鼠标。 在Linux上，您可以使用HID内核输入事件。 除此之外，我们还支持TUIO（有形用户界面对象）和其他输入源的数量。</p>
<h4 id="专注"><a href="#专注" class="headerlink" title="专注"></a>专注</h4><p>Kivy专注。 您可以用几行代码编写一个简单的应用程序。 创建Kivy程序使用Python编程语言，该语言具有广泛的功能和强大的功能，而且易于使用。 在此外，我们创建了自己的描述语言，即Kivy语言，用于创建复杂的用户接口。 使用该语言，您可以快速设置，连接和安排应用程序元素。我们认为，让您专注于应用程序的本质比强制更重要您将摆弄编译器设置。 我们减轻了您的负担。</p>
<h4 id="已资助"><a href="#已资助" class="headerlink" title="已资助"></a>已资助</h4><p>Kivy由其领域的专业人员积极开发。 Kivy是受社区影响的专业人士开发和商业支持的解决方案。 我们的一些核心开发人员开发Kivy是为了活的。 Kivy在这里停留。 这不是一个很小的消失的学生项目。</p>
<h4 id="免费"><a href="#免费" class="headerlink" title="免费"></a>免费</h4><p>Kivy是免费使用。 您不必为此付费。 如果您要赚钱，甚至不用付费通过销售使用Kivy的应用程序赚钱。</p>
<h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><p>您可以通过多种方式为Kivy做出贡献。代码补丁只是其中的一件事您可以提交以帮助该项目的其他项目。我们也欢迎您提供反馈，错误报告，功能要求，文档改进，广告和宣传，测试，图形贡献等其他想法。如果您想提供帮助，请与我们联系，我们将为您提供帮助。</p>
<h3 id="讨论区"><a href="#讨论区" class="headerlink" title="讨论区"></a>讨论区</h3><p>关于Kivy开发的讨论发生在Github的问题上，并拉动了对特定事物的要求。对于两者都不适合的问题，讨论会在<span class="exturl" data-url="aHR0cHM6Ly9jaGF0Lmtpdnkub3JnLw==">#dev Discord频道<i class="fa fa-external-link-alt"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9mb3J1bS8jIWZvcnVtL2tpdnktZGV2">kivy-dev<i class="fa fa-external-link-alt"></i></span>上进行谷歌组。 如果不确定如何捐款，请来寻求指导在进行构想之前，先确认您的构想是否适合项目。 如果您要-或提供支持-您可以加入<span class="exturl" data-url="aHR0cHM6Ly9jaGF0Lmtpdnkub3JnLw==">#support Discord频道<i class="fa fa-external-link-alt"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9mb3J1bS8jIWZvcnVtL2tpdnktdXNlcnM=">kivy-users谷歌论坛<i class="fa fa-external-link-alt"></i></span>。</p>
<h3 id="行为守则"><a href="#行为守则" class="headerlink" title="行为守则"></a>行为守则</h3><p>为了建立一个开放和欢迎的社区，我们作为贡献者和维护者需要确保参与我们的项目和我们的姐妹项目是无骚扰和积极的经历为了每一个。</p>
<p>因此，至关重要的是，所有互动都应以尊重，开放的态度进行和感激。有关这些准则的更全面讨论，请参阅<span class="exturl" data-url="aHR0cHM6Ly93d3cuY29udHJpYnV0b3ItY292ZW5hbnQub3JnL3ZlcnNpb24vMS80L2NvZGUtb2YtY29uZHVjdC5odG1s">贡献者盟约<i class="fa fa-external-link-alt"></i></span>。本文档提供了对您的期望的准确描述，两者都是核心开发人员或首次贡献者。</p>
<h3 id="反馈"><a href="#反馈" class="headerlink" title="反馈"></a>反馈</h3><p>到目前为止，这是做出贡献的最简单方法。如果您将Kivy用于自己的项目，不要犹豫，分享。显然，它不必是高级企业应用程序。 真是难以置信激发人们知道您使用您开发的东西以及它能使他们做什么的动机。如果你有您想告诉我们的事情，请不要犹豫。 屏幕截图和视频也非常欢迎！ 我们也对您入门时遇到的问题感兴趣。请感到鼓舞报告您遇到的任何障碍，例如缺少文档，误导性指示或类似内容。我们是完美主义者，所以即使是错字，也请告诉我们。</p>
<h3 id="报告问题"><a href="#报告问题" class="headerlink" title="报告问题"></a>报告问题</h3><p>如果发现任何错误，崩溃，段错误，缺少文档，拼写无效或很奇怪示例，请花2分钟报告此问题。</p>
<p>1.通过编辑将日志记录级别移至调试级别 <code>&lt;user_directory&gt;/.kivy/config.ini:</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[kivy]</span><br><span class="line">log_level &#x3D; debug</span><br></pre></td></tr></table></figure>
<p>2.再次执行您的代码，然后将完整的输出复制/粘贴到<span class="exturl" data-url="aHR0cDovL2dpc3QuZ2l0aHViLmNvbS/vvIzljIXmi6zmnaXoh6pLaXZ555qE5pel5b+X5ZKMcHl0aG9u">http://gist.github.com/，包括来自Kivy的日志和python<i class="fa fa-external-link-alt"></i></span> backtrace。</p>
<p>3.打开 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tpdnkva2l2eS9pc3N1ZXMv">https://github.com/kivy/kivy/issues/<i class="fa fa-external-link-alt"></i></span></p>
<p>4.设置您的问题的标题</p>
<p>5.确切说明要重现该问题的方法，并粘贴发布在其上的输出的链接 <span class="exturl" data-url="aHR0cDovL2dpc3QuZ2l0aHViLmNvbS8=">http://gist.github.com/<i class="fa fa-external-link-alt"></i></span></p>
<p>6.验证问题，您就完成了！</p>
<p>如果您愿意，也可以尝试解决该错误，并通过向我们发送补丁来做出贡献：）阅读下一节以了解如何执行此操作。</p>
<h3 id="代码贡献"><a href="#代码贡献" class="headerlink" title="代码贡献"></a>代码贡献</h3><p>代码贡献（补丁，新功能）是帮助项目发展的最明显方法。由于这很常见，因此请您遵循我们的工作流程以最有效地与我们合作。遵守我们的工作流程可确保您的贡献不会被遗忘或丢失。 还有你的名字将始终与您所做的更改相关联，这基本上意味着我们代码中的永恒声誉历史记录（如果您不想这样做，可以选择退出）。</p>
<h4 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h4><ul>
<li>如果尚未完成，请阅读<span class="exturl" data-url="aHR0cDovL3d3dy5weXRob24ub3JnL2Rldi9wZXBzL3BlcC0wMDA4Lw==">PEP8<i class="fa fa-external-link-alt"></i></span>有关python编码样式的信息。</li>
<li>像这样激活对git commit的pep8检查：</li>
</ul>
<p><code>make hook</code></p>
<p>这将通过pep8检查器传递添加到git临时区域（即将提交）的代码进行提交时进行编程，并确保没有引入pep8错误。 如果您这样做，提交将被拒绝：请更正错误，然后重试。</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ul>
<li>照顾性能问题：阅读<span class="exturl" data-url="aHR0cDovL3dpa2kucHl0aG9uLm9yZy9tb2luL1B5dGhvblNwZWVkL1BlcmZvcm1hbmNlVGlwcw==">Python性能提示<i class="fa fa-external-link-alt"></i></span></li>
<li>Kivy的cpu密集部分用cython编写：如果您要进行大量计算，请考虑也使用它。<h4 id="Git-amp-GitHub"><a href="#Git-amp-GitHub" class="headerlink" title="Git &amp; GitHub"></a>Git &amp; GitHub</h4>我们将git用作代码库的版本控制系统。 如果您从未使用过git或类似的工具DVCS（甚至任何VCS）之前，我们强烈建议您看一下有关可用于git在线。<span class="exturl" data-url="aHR0cDovL2Jvb2suZ2l0LXNjbS5jb20v">Git社区书<i class="fa fa-external-link-alt"></i></span>或<span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS92aWRlb3M=">Git视频<i class="fa fa-external-link-alt"></i></span>都是学习git的好方法。当我们说git是一个很棒的工具时，请相信我们。 乍一看似乎令人生畏，但过了一会儿（希望）像我们一样爱它。 但是，教给你git远远超出了本文的范围文献。</li>
</ul>
<p>此外，我们使用<span class="exturl" data-url="aHR0cDovL2dpdGh1Yi5jb20v">GitHub<i class="fa fa-external-link-alt"></i></span>托管代码。 在下文中，我们将假设您有一个（免费的）GitHub帐户。 虽然这部分是可选的，但它允许您的补丁程序与我们的补丁程序紧密集成上游代码库。 如果您不想使用GitHub，我们假设您知道自己在做什么无论如何。</p>
<h4 id="代码工作流程"><a href="#代码工作流程" class="headerlink" title="代码工作流程"></a>代码工作流程</h4><p>因此，这是从我们的工作流程开始的初始设置（您只需安装一次即可安装Kivy）。基本上，您会按照dev-install的安装说明进行操作，但是您不会克隆我们的存储库，你叉它。 步骤如下：</p>
<p>1.登录到GitHub</p>
<p>2.单击fork按钮，创建<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tpdnkva2l2eQ==">Kivy存储库<i class="fa fa-external-link-alt"></i></span>的fork。</p>
<p>3.将我们的存储库的分支克隆到计算机上。您的fork将具有git远程名称“origin”，您将进入“master”分支：</p>
<p><code>git clone https://github.com/username/kivy.git</code></p>
<p>4.编译并设置PYTHONPATH或安装（请参阅dev-install）。</p>
<p>5.安装我们的预提交钩子，以确保您的代码不违反我们的样式指南，方法是执行从克隆的根目录建立钩子。这将在任何时候运行我们的styleguide检查您进行提交，并且如果您更改的部分中有违规行为，您的提交将为流产了。修复并重试。</p>
<p>6.将Kivy仓库添加为远程资源：</p>
<p><code>git remote add kivy https://github.com/kivy/kivy.git</code></p>
<p>现在，无论何时要创建补丁，都可以按照以下步骤操作：</p>
<p>1.查看我们的错误跟踪器中是否有针对该修补程序或功能的故障单，并宣布您将如果还没有受让人，请继续研究。</p>
<p>2.在本地存储库中为该特定对象创建一个新的，命名适当的分支功能或错误修正。（为每个功能保留一个新分支，确保我们可以轻松地加入您所做的更改，而不会提取任何其他本不应该被提取的东西。）：</p>
<p><code>git checkout -b new_feature</code></p>
<p>3.修改代码以执行所需的操作（例如，对其进行修复）。</p>
<p>4.测试代码。 即使是较小的修复，也请尝试这样做。 你永远不知道你是否有引入了一些未经测试的怪异错误。</p>
<p>5.对每个修订或每个功能执行一次或多次最小的原子提交。 最小/原子意味着保持提交干净。不要提交逻辑上不属于的其他内容此修复程序或功能。这与每更改一行创建一个提交无关。 使用git必要时添加-p。</p>
<p>6.给每个提交一个适当的提交消息，以便其他不熟悉的人对此事，您应该对自己的改变有所了解。</p>
<p>7.对更改满意后，请拉动我们的上游存储库并进行合并与您的本地存储库。 我们可以拉您的东西，但是既然您确切知道更改后，您应该进行合并：</p>
<p><code>git pull kivy master</code></p>
<p>8.将本地分支推送到GitHub上的远程存储库中：</p>
<p><code>git push origin new_feature</code></p>
<p>9.通过GitHub中的按钮发送请求，其中包含您所做的更改的描述存储库的界面。（这就是我们最初分叉的原因。您的存储库已链接反对我们的。）</p>
<p><strong>警告：如果更改代码库中需要编译的部分，则将具有重新编译以使更改生效。make命令将执行此操作为您服务（如果您想知道它的作用，请参见Makefile）。如果您需要清洁当前目录从编译文件，执行<code>make clean</code>。如果你想摆脱一切不受版本控制的文件，请运行<code>make distclean</code>（警告：如果您进行更改，不受版本控制，此命令将删除它们！）</strong></p>
<p>现在，我们将收到您的拉取请求。我们将检查您的更改是否干净且合理（如果您在进行所有操作之前与我们进行了交谈，我们会告诉您是否有意义）。如果是这样的话，我们将拉动它们，您将立即获得业力。恭喜，您是英雄！</p>
<h3 id="文档贡献"><a href="#文档贡献" class="headerlink" title="文档贡献"></a>文档贡献</h3><h1 id="第二部分-编程指南"><a href="#第二部分-编程指南" class="headerlink" title="第二部分 编程指南"></a>第二部分 编程指南</h1><h2 id="Kivy-基础"><a href="#Kivy-基础" class="headerlink" title="Kivy 基础"></a><h2 id="1.1">Kivy 基础</h2></h2><h3 id="安装Kivy环境"><a href="#安装Kivy环境" class="headerlink" title="安装Kivy环境"></a>安装Kivy环境</h3><p>Kivy依赖于许多Python库，例如pygame，gstreamer，PIL，Cairo等。他们是并非全部都需要，但是根据您正在使用的平台，安装它们可能会很麻烦。对于在Windows和MacOS X上，我们提供了一个可移植的软件包，您可以将其解压缩并使用。</p>
<p>请查看以下页面之一，以获取详细的安装说明：</p>
<ul>
<li>安装windows</li>
<li>安装osx</li>
<li>安装linux</li>
<li>安装rpi</li>
</ul>
<p>另外，可以在此处找到开发版本的说明：</p>
<ul>
<li>安装<h3 id="创建一个应用程序"><a href="#创建一个应用程序" class="headerlink" title="创建一个应用程序"></a>创建一个应用程序</h3>创建kivy应用程序很简单：</li>
<li>子类化App类</li>
<li>实现其build（）方法，使其返回Widget实例（您的Widget树的根）</li>
<li>实例化此类，并调用其run（）方法。</li>
</ul>
<p>这是最小应用程序的示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kivy</span><br><span class="line">kivy.require(<span class="string">'1.0.6'</span>) <span class="comment"># replace with your current kivy version !</span></span><br><span class="line"><span class="keyword">from</span> kivy.app <span class="keyword">import</span> App</span><br><span class="line"><span class="keyword">from</span> kivy.uix.label <span class="keyword">import</span> Label</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span><span class="params">(App)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Label(text=<span class="string">'Hello world'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    MyApp().run()</span><br></pre></td></tr></table></figure>
<p>您可以将其保存到文本文件，例如main.py，然后运行它。</p>
<h3 id="Kivy-App生命周期"><a href="#Kivy-App生命周期" class="headerlink" title="Kivy App生命周期"></a>Kivy App生命周期</h3><p>首先，让我们熟悉Kivy应用的生命周期。</p>
<p><img src="https://s2.ax1x.com/2020/02/12/1b6xkn.png" alt="1b6xkn.png"></p>
<p>正如您在上面看到的，出于所有意图和目的，我们进入应用程序的入口是<code>run()</code>方法，在我们的例子中是<code>MyApp().run()</code>。 我们将回到这一点，但让我们从第三行开始：</p>
<p><code>from kivy.app import App</code></p>
<p>您的应用的基本类必须继承自该应用类。 它存在于<code>kivy_installation_dir/kivy/app.py</code>中。</p>
<hr>
<p><strong>注意：如果您想深入研究Kivy App类的功能，请继续打开该文件。我们鼓励您打开代码并仔细阅读。 Kivy基于Python，并使用Sphinx进行文档，因此每个类的文档都在实际文件中。</strong></p>
<hr>
<p>同样在第2行：</p>
<p><code>from kivy.uix.label import Label</code></p>
<p>这里要注意的一件事是软件包/类的布局方式。 uix模块是包含用户界面元素（如布局和小部件）的部分。</p>
<p>移至第5行：</p>
<p><code>class MyApp(App):</code></p>
<p>这是我们定义Kivy应用程序的基类的地方。 您只需要更改此行中应用程序MyApp的名称。</p>
<p>移至第7行：</p>
<p><code>def build(self):</code></p>
<p>如上图突出显示，显示了Kivy App生命周期，这是您可以在其中使用的功能应该初始化并返回您的Root Widget。这是我们在第8行上所做的：</p>
<p><code>return Label(text=&#39;Hello world&#39;)</code></p>
<p>在这里，我们使用文本“ Hello World”初始化Label并返回其实例。 此标签将成为根此应用程序的小部件。</p>
<hr>
<p><strong>注意：Python使用缩进来表示代码块，因此请注意，在提供的代码中上面的第9行，类和函数定义结束。</strong></p>
<hr>
<p>现在进入将使我们的应用程序在第11行和第12行运行的部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    MyApp().run()</span><br></pre></td></tr></table></figure>
<p>在这里，类<code>MyApp</code>被初始化并调用其<code>run()</code>方法。 这将初始化并启动我们的Kivy应用。</p>
<h3 id="运行应用程序"><a href="#运行应用程序" class="headerlink" title="运行应用程序"></a>运行应用程序</h3><p>要运行该应用程序，请按照您的操作系统的说明进行操作：</p>
<ul>
<li>Linux请按照以下说明在Linux上运行Kivy应用程序：</li>
</ul>
<p><code>$ python main.py</code></p>
<ul>
<li>Windows请按照以下说明在Windows上运行Kivy应用程序：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python main.py</span><br><span class="line"># or</span><br><span class="line">C:\appdir&gt;kivy.bat main.py</span><br></pre></td></tr></table></figure></li>
<li>Mac OS X请按照以下说明在OS X上运行Kivy应用程序：</li>
</ul>
<p><code>$ kivy main.py</code></p>
<p>Android您的应用程序需要一些补充文件才能在Android上运行。请参阅创建Android包以获取更多参考。</p>
<p>应打开一个窗口，显示一个覆盖整个标签的标签（带有“ Hello World”文本）窗口区域。 这里的所有都是它的。</p>
<h3 id="定制应用程序"><a href="#定制应用程序" class="headerlink" title="定制应用程序"></a>定制应用程序</h3><p>让我们扩展这个应用程序，例如一个简单的UserName / Password页面。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> kivy.app <span class="keyword">import</span> App</span><br><span class="line"><span class="keyword">from</span> kivy.uix.gridlayout <span class="keyword">import</span> GridLayout</span><br><span class="line"><span class="keyword">from</span> kivy.uix.label <span class="keyword">import</span> Label</span><br><span class="line"><span class="keyword">from</span> kivy.uix.textinput <span class="keyword">import</span> TextInput</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginScreen</span><span class="params">(GridLayout)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        super(LoginScreen, self).__init__(**kwargs)</span><br><span class="line">        self.cols = <span class="number">2</span></span><br><span class="line">        self.add_widget(Label(text=<span class="string">'User Name'</span>))</span><br><span class="line">        self.username = TextInput(multiline=<span class="literal">False</span>)</span><br><span class="line">        self.add_widget(self.username)</span><br><span class="line">        self.add_widget(Label(text=<span class="string">'password'</span>))</span><br><span class="line">        self.password = TextInput(password=<span class="literal">True</span>, multiline=<span class="literal">False</span>)</span><br><span class="line">        self.add_widget(self.password)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span><span class="params">(App)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> LoginScreen()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    MyApp().run()</span><br></pre></td></tr></table></figure>
<p>在第2行，我们导入<code>Gridlayout</code>：</p>
<p><code>from kivy.uix.gridlayout import GridLayout</code></p>
<p>此类用作第9行中定义的<code>RootWidget（LoginScreen）</code>的基础：</p>
<p><code>class LoginScreen(GridLayout):</code></p>
<p>在<code>LoginScreen</code>类的第12行，我们重写了<code>__init __（）</code>方法，以便添加小部件并添加到定义他们的行为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def __init__(self, **kwargs):</span><br><span class="line">    super(LoginScreen, self).__init__(**kwargs)</span><br></pre></td></tr></table></figure>
<p>为了实现原始类的功能，请不要忘记调用<code>super</code>超载。 还要注意，优良作法是在调用<code>super</code>时不要忽略<code>** kwarg</code>，因为它们是有时在内部使用。</p>
<p>移至15行及以后：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">self.cols = <span class="number">2</span></span><br><span class="line">self.add_widget(Label(text=<span class="string">'User Name'</span>))</span><br><span class="line">self.username = TextInput(multiline=<span class="literal">False</span>)</span><br><span class="line">self.add_widget(self.username)</span><br><span class="line">self.add_widget(Label(text=<span class="string">'password'</span>))</span><br><span class="line">self.password = TextInput(password=<span class="literal">True</span>, multiline=<span class="literal">False</span>)</span><br><span class="line">self.add_widget(self.password)</span><br></pre></td></tr></table></figure>
<p>我们要求<code>GridLayout</code>在两列中管理其子项，并为以下项添加<code>Label</code>和<code>TextInput</code>用户名和密码。</p>
<p>运行上面的代码将为您提供一个如下所示的窗口：</p>
<p><img src="https://s2.ax1x.com/2020/02/13/1qSgc6.png" alt="1qSgc6.png"></p>
<p>尝试重新调整窗口大小，您将看到屏幕上的小部件会根据无需做任何事情的窗口大小。 这是因为小部件使用大小提示默认。</p>
<p>上面的代码无法处理用户的输入，也不进行验证或其他任何操作。我们会在接下来的部分中深入研究此功能以及小部件的大小和位置。</p>
<h2 id="控制环境"><a href="#控制环境" class="headerlink" title="控制环境"></a>控制环境</h2><p>许多环境变量可用于控制Kivy的初始化和行为。</p>
<p>例如，为了将文本呈现限制为PIL实现：</p>
<p><code>$ KIVY_TEXT=pil python main.py</code></p>
<p>导入kivy之前应设置环境变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">'KIVY_TEXT'</span>] = <span class="string">'pil'</span></span><br><span class="line"><span class="keyword">import</span> kivy</span><br></pre></td></tr></table></figure>
<h3 id="路径控制"><a href="#路径控制" class="headerlink" title="路径控制"></a>路径控制</h3><p>1.0.7版中的新功能。</p>
<p>您可以控制配置文件，模块和kivy数据所在的默认目录。</p>
<p><strong>KIVY_DATA_DIR</strong> Kivy数据的位置，默认为<code>&lt;depressed path&gt;/data</code></p>
<p><strong>KIVY_MODULES_DIR</strong> Kivy模块的位置，默认为<code>&lt;depressed path&gt;/modules</code></p>
<p><strong>KIVY_HOME</strong> Kivy家的位置。 此目录用于本地配置，并且必须为在可写的位置。</p>
<p>默认为：</p>
<ul>
<li>Desktop: <code>&lt;user home&gt;/.kivy</code></li>
<li>Android: <code>&lt;android app path&gt;/.kivy</code></li>
<li>iOS: <code>&lt;user home&gt;/Documents/.kivy</code></li>
</ul>
<p>1.9.0版中的新功能。</p>
<p><strong>KIVY_SDL2_PATH</strong>如果设置，则在编译kivy时使用此路径的SDL2库和头<br>而不是系统范围内安装的系统。 要在运行kivy应用程序时使用相同的库，这<br>必须在PATH环境变量的开头添加路径。</p>
<p>1.9.0版中的新功能。</p>
<p><strong>警告：编译Kivy需要此路径。程序不需要执行。</strong></p>
<h3 id="组态"><a href="#组态" class="headerlink" title="组态"></a>组态</h3><p><strong>KIVY_USE_DEFAULTCONFIG</strong> 如果在环境中找到此名称，Kivy将不会读取用户配置文件。</p>
<p><strong>KIVY_NO_CONFIG</strong> 如果设置，则不会读取或写入任何配置文件。 这也适用于用户配置目录。</p>
<p><strong>KIVY_NO_FILELOG</strong> 如果设置，日志将不会打印到文件中。</p>
<p><strong>KIVY_NO_CONSOLELOG</strong> 如果设置，日志将不会打印到控制台</p>
<p><strong>KIVY_NO_ARGS</strong> 如果设置，则在命令行中传递的参数将不会被Kivy解析和使用。</p>
<p>即，您可以安全地使用自己的参数制作脚本或应用，而无需 - 分隔符：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">"KIVY_NO_ARGS"</span>] = <span class="string">"1"</span></span><br><span class="line"><span class="keyword">import</span> kivy</span><br></pre></td></tr></table></figure>
<p>1.9.0版中的新功能。</p>
<p><strong>KCFG_section_key</strong> 如果检测到这样的格式环境名称，它将被映射到<code>Config</code>宾语。 导入kivy后，它们只会加载一次。 该行为可以通过以下方式禁用<em>KIVY_NO_ENV_CONFIG</em>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">"KCFG_KIVY_LOG_LEVEL"</span>] = <span class="string">"warning"</span></span><br><span class="line"><span class="keyword">import</span> kivy</span><br><span class="line"><span class="comment"># during import it will map it to:</span></span><br><span class="line"><span class="comment"># Config.set("kivy", "log_level", "warning")</span></span><br></pre></td></tr></table></figure>
<p>1.11.0版中的新功能。</p>
<p><strong>KIVY_NO_ENV_CONFIG</strong> 如果设置，则没有环境密钥将映射到配置对象。 如果未设置，任何<code>KCFG_section_key = value</code>都将映射到<code>Config</code>。</p>
<p>1.11.0版中的新功能。</p>
<h3 id="将核心限制为具体实施"><a href="#将核心限制为具体实施" class="headerlink" title="将核心限制为具体实施"></a>将核心限制为具体实施</h3><p>kivy.core尝试选择适用于您的平台的最佳实施。用于测试或定制<br>安装时，您可能希望将选择器限制为特定的实现。</p>
<p><strong>KIVY_WINDOW</strong> 实现，用于创建窗口。</p>
<p>值：sdl2，pygame，x11，egl_rpi</p>
<p><strong>KIVY_TEXT</strong> 用于呈现文本的实现</p>
<p>值：sdl2, pil, pygame, sdlttf</p>
<p>KIVY_VIDEO实现，用于呈现视频</p>
<p>值：gstplayer, ffpyplayer, ffmpeg, null</p>
<p><strong>KIVY_AUDIO</strong> 用于播放音频的实现</p>
<p>值：sdl2, gstplayer, ffpyplayer, pygame, avplayer</p>
<p><strong>KIVY_IMAGE</strong> 用于读取图像的实现</p>
<p>值：sdl2, pil, pygame, imageio, tex, dds, gif</p>
<p><strong>KIVY_CAMERA</strong> 用于读取相机的实现</p>
<p>值：avfoundation, android, opencv</p>
<p><strong>KIVY_SPELLING</strong> 用于拼写的实现</p>
<p>值：enchant, osxappkit</p>
<p><strong>KIVY_CLIPBOARD</strong> 实现，用于剪贴板管理</p>
<p>值：sdl2, pygame, dummy, android</p>
<h3 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h3><p><strong>KIVY_DPI</strong> 如果设置，则该值将用于<strong>Metrics.dpi</strong>。</p>
<p>1.4.0版的新功能。</p>
<p><strong>KIVY_METRICS_DENSITY</strong> 如果设置，则该值将用于<strong>Metrics.density</strong>。</p>
<p>1.5.0版的新功能。</p>
<p><strong>KIVY_METRICS_FONTSCALE</strong>如果设置，则该值将用于<strong>Metrics.fontscale</strong>。</p>
<p>1.5.0版的新功能。</p>
<h3 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h3><p><strong>KIVY_GL_BACKEND</strong> 要使用的OpenGL后端。参见cgl。</p>
<p><strong>KIVY_GL_DEBUG</strong> 是否记录OpenGL调用。参见cgl。</p>
<p><strong>KIVY_GRAPHICS</strong> 是否使用OpenGL ES2。参见cgl。</p>
<p><strong>KIVY_GLES_LIMITS</strong> 是否强制执行GLES2限制（默认设置，或设置为1）。如果设置为否，Kivy不会真正与GLES2兼容。</p>
<p>以下列出了设置为true时可能导致的不兼容性。</p>
<ul>
<li>网格指数<ul>
<li>如果为true，则网格中的索引数限制为65535</li>
</ul>
</li>
<li>纹理闪电战<ul>
<li>向纹理贴图时，数据（颜色和缓冲区）格式必须与一种用于纹理创建。在桌面上，不同颜色的转换正确由驱动程序处理，而在Android上，大多数设备都无法做到。参考：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tpdnkva2l2eS9pc3N1ZXMvMTYwMA==">https://github.com/kivy/kivy/issues/1600<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
</ul>
<p>版本1.8.1中的新功能。</p>
<p><strong>KIVY_BCM_DISPMANX_ID</strong> 更改要使用的默认Raspberry Pi显示。 可用清单可在<em>vc_dispmanx_types.h</em>中访问该值。默认值为0：</p>
<ul>
<li>0: <strong>DISPMANX_ID_MAIN_LCD</strong></li>
<li>1: <strong>DISPMANX_ID_AUX_LCD</strong></li>
<li>2: <strong>DISPMANX_ID_HDMI</strong></li>
<li>3: <strong>DISPMANX_ID_SDTV</strong></li>
<li>4: <strong>DISPMANX_ID_FORCE_LCD</strong></li>
<li>5: <strong>DISPMANX_ID_FORCE_TV</strong></li>
<li>6: <strong>DISPMANX_ID_FORCE_OTHER</strong></li>
</ul>
<p><strong>KIVY_BCM_DISPMANX_LAYER</strong> 更改默认的Raspberry Pi Dispmanx图层。默认值为0。</p>
<p>1.10.1版中的新功能。</p>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p><strong>KIVY_EVENTLOOP</strong>在异步运行应用程序时应使用哪个异步库方式。有关示例用法，请参见kivy.app。</p>
<p><strong>‘asyncio’</strong>：当应用以异步方式运行且标准库asyncio时包装应使用。 如果未设置，则为默认值。</p>
<p><strong>‘trio’</strong>：当应用程序以异步方式运行且trio包应为用过的。</p>
<p>2.0.0版中的新功能。</p>
<h2 id="Kivy-配置"><a href="#Kivy-配置" class="headerlink" title="Kivy 配置"></a>Kivy 配置</h2><p>kivy的配置文件名为config.ini，并遵循<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JTklfZmlsZQ==">标准INI<i class="fa fa-external-link-alt"></i></span>格式。</p>
<h3 id="查找配置文件"><a href="#查找配置文件" class="headerlink" title="查找配置文件"></a>查找配置文件</h3><p>配置文件的位置由环境变量<em>KIVY_HOME</em>控制：</p>
<p><code>&lt;KIVY_HOME&gt;/config.ini</code></p>
<p>在台式机上，默认为：</p>
<p><code>&lt;HOME_DIRECTORY&gt;/.kivy/config.ini</code></p>
<p>因此，如果您的用户名为“ tito”，则文件将位于此处：</p>
<ul>
<li>Windows: C:\Users\tito.kivy\config.ini</li>
<li>OS X: /Users/tito/.kivy/config.ini</li>
<li>Linux: /home/tito/.kivy/config.ini</li>
</ul>
<p>在Android上，默认为：</p>
<p><code>&lt;ANDROID_APP_PATH&gt;/.kivy/config.ini</code></p>
<p>如果您的应用名为“ org.kivy.launcher”，则文件将位于此处：</p>
<p><code>/data/data/org.kivy.launcher/files/.kivy/config.ini</code></p>
<p>在iOS上，默认为：</p>
<p><code>&lt;HOME_DIRECTORY&gt;/Documents/.kivy/config.ini</code></p>
<h3 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h3><p>有时，只希望更改某些应用程序的配置或在单独测试期间更改配置Kivy的一部分，例如输入提供程序。要创建单独的配置文件，您只需使用以下命令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> kivy.config <span class="keyword">import</span> Config</span><br><span class="line">Config.read(&lt;file&gt;)</span><br><span class="line"><span class="comment"># set config</span></span><br><span class="line">Config.write()</span><br></pre></td></tr></table></figure>
<p>如果单个.ini文件的本地配置不够用，例如 当你想分开花园，奇异果原木和其他物品的环境，您需要更改<strong>KIVY_HOME</strong>环境您的应用程序中的变量以获得所需的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">os.environ[&#39;KIVY_HOME&#39;] &#x3D; &lt;folder&gt;</span><br></pre></td></tr></table></figure>
<p>或在每次运行该应用程序之前在控制台中对其进行手动更改：</p>
<ol>
<li>Windows:</li>
</ol>
<p><code>set KIVY_HOME=&lt;folder&gt;</code></p>
<ol start="2">
<li>Linux &amp; OSX:</li>
</ol>
<p><code>export KIVY_HOME=&lt;folder&gt;</code></p>
<p>更改<strong>KIVY_HOME</strong>后，该文件夹的行为将与默认的.kivy /文件夹完全相同上文提到的。</p>
<h3 id="了解配置令牌"><a href="#了解配置令牌" class="headerlink" title="了解配置令牌"></a>了解配置令牌</h3><p>所有配置令牌在kivy.config模块中进行了说明。</p>
<h2 id="建筑概述"><a href="#建筑概述" class="headerlink" title="建筑概述"></a>建筑概述</h2><p>我们想花一点时间从软件工程角度解释我们如何设计Kivy视图。 这是了解所有事物如何协同工作的关键。如果您只看代码，您是否已经有了一个大概的主意，但是由于这种方法对于大多数用户而言确实令人生畏，因此本节更详细地说明了实现的基本思想。 您可以跳过本节并参考稍后再讨论，但我们建议至少略读一下以大致了解。</p>
<p>Kivy由几个构建块组成，我们将在稍后进行解释。这是以下内容的图形摘要,架构：</p>
<p><img src="https://s2.ax1x.com/2020/02/13/1LYIDx.png" alt="1LYIDx.png"></p>
<h3 id="核心提供者和输入提供者"><a href="#核心提供者和输入提供者" class="headerlink" title="核心提供者和输入提供者"></a>核心提供者和输入提供者</h3><p>理解Kivy内部的关键是模块化和抽象化。我们尝试抽象基本任务，例如打开窗口，显示图像和文本，播放音频，获取来自相机的图像，拼写更正等。我们称这些核心任务。这使得API都易于使用且易于扩展。最重要的是，它允许我们使用-我们所谓的-特定提供商适用于运行您的应用的各个方案。例如，在OSX，Linux和Windows上，针对不同的核心任务有不同的本机API。一段使用以下特定代码之一的代码一方面与操作系统通信，另一方面与Kivy通信的API（充当中间设备）通信层）就是我们所谓的核心提供商。使用专业核心提供商的优势对于每个平台，我们可以充分利用操作系统提供的功能并采取行动尽可能有效。它还为用户提供了选择。此外，通过使用附带的库在任何一个平台上，我们都有效地减少了Kivy分销的规模并进行包装更轻松。这也使得将Kivy移植到其他平台变得更加容易。 Android端口受益匪浅由此。</p>
<p>我们对输入处理遵循相同的概念。 输入提供程序是一段添加支持的代码适用于特定的输入设备，例如Apple的触控板，TUIO或鼠标模拟器。 如果需要添加支持新的输入设备，您只需提供一个新类即可从中读取输入数据您的设备并将其转换为Kivy基本事件。</p>
<h3 id="图形-1"><a href="#图形-1" class="headerlink" title="图形"></a>图形</h3><p>Kivy的图形API是我们对OpenGL的抽象。从最低的角度看，Kivy的硬件加速问题使用OpenGL绘制命令。但是编写OpenGL代码可能会有些混乱，特别是对新来者。因此，我们提供了图形API，可让您使用OpenGL中不存在的简单隐喻（例如Canvas，Rectangle等）。</p>
<p>我们所有的小部件本身都使用此图形API，该API在C层上实现以提高性能原因。</p>
<p>图形API的另一个优点是它能够自动优化绘图命令您的代码问题。如果您不是调整OpenGL的专家，这将特别有用。这使得在许多情况下，您的绘图代码效率更高。</p>
<p>当然，如果愿意，您仍然可以使用原始OpenGL命令。我们针对的版本是OpenGL 2.0所有设备上的ES（GLES2），因此，如果要保持跨平台兼容性，建议您仅使用GLES2功能。</p>
<h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p>核心软件包中的代码提供了常用功能，例如：</p>
<ul>
<li><strong>Clock</strong> 您可以使用时钟安排计时器事件。 一次性计时器和定期计时器支持计时器。</li>
<li><strong>Cache</strong> 如果您需要缓存经常使用的内容，可以使用我们的类而不是自己写。</li>
<li><strong>Gesture Detection</strong> 我们提供了一个简单的手势识别器，您可以使用它来检测各种各种笔触，例如圆形或矩形。您可以训练它来检测自己的招。</li>
<li><strong>Kivy Language</strong> Kivy语言用于轻松有效地描述用户界面。</li>
<li><strong>Properties</strong> 这些不是您可能从python知道的普通属性。他们是我们自己的属性类，这些属性类将窗口小部件代码与用户界面描述相关联。</li>
</ul>
<h3 id="UIX（小部件和布局）"><a href="#UIX（小部件和布局）" class="headerlink" title="UIX（小部件和布局）"></a>UIX（小部件和布局）</h3><p>UIX模块包含常用的小部件和布局，您可以重复使用这些小部件和布局以快速创建一个用户界面。</p>
<ul>
<li><strong>Widgets</strong> 小部件是您添加到程序中以提供的用户界面元素某种功能。它们可能不可见。例子是文件浏览器，按钮，滑块，列表等。窗口小部件接收MotionEvents。</li>
<li><strong>Layouts</strong> 您使用布局来排列小部件。当然可以计算您的小部件的定位自己，但使用我们现成的一种通常更方便布局。例如网格布局或箱形布局。您也可以嵌套布局。</li>
</ul>
<h3 id="模组"><a href="#模组" class="headerlink" title="模组"></a>模组</h3><p>如果您曾经使用过现代的网络浏览器并使用一些插件对其进行了自定义，那么您已经了解我们模块类背后的基本思想。模块可用于将功能注入Kivy程序，即使原始作者未将其包括在内。</p>
<p>一个示例是始终显示当前应用程序的FPS和一些图形的模块描述随着时间推移的FPS。</p>
<p>您也可以编写自己的模块。</p>
<h3 id="输入事件（触摸）"><a href="#输入事件（触摸）" class="headerlink" title="输入事件（触摸）"></a>输入事件（触摸）</h3><p>Kivy提取了不同的输入类型和来源，例如触摸，鼠标，TUIO或类似输入。 什么都可以。这些输入类型的共同点是您可以将2D屏幕上的位置与任何个人相关联输入事件。（还有其他输入设备，例如加速度计，您无法轻松找到2D例如的位置 设备倾斜。 这种输入是单独处理的。 接下来我们描述前一种类型。）</p>
<p>所有这些输入类型均由<code>Touch()</code>类的实例表示。（请注意，这不仅指的是手指触摸，其他所有输入类型也是如此。为了方便起见，我们将其称为Touch简单。考虑一下触摸用户界面或屏幕的事物。）触摸实例，或对象，可以处于三种状态之一。当触摸进入这些状态之一时，程序会收到通知该事件发生了。可以进入的三种状态是：</p>
<ul>
<li><strong>Down</strong> 触摸仅在第一次出现的那一刻才下降一次。</li>
<li><strong>Move</strong> 触摸可能会在这种状态下持续无限的时间。 一点触摸都没有在其一生中处于这种状态。只要“ A”的2D位置触摸更改。</li>
<li><strong>Up</strong> 触摸最多一次或永远不会增加。实际上，您几乎总是会收到上升事件，因为没有人会永远在屏幕上牵着手指，但这是不保证。如果您知道用户将使用的输入源，则将知道是否可以依靠此状态被输入。</li>
</ul>
<h3 id="小部件和事件调度"><a href="#小部件和事件调度" class="headerlink" title="小部件和事件调度"></a>小部件和事件调度</h3><p>小部件<em>widget</em>通常在GUI编程上下文中用于描述程序的某些部分，用户进行交互。在Kivy中，小部件是一个接收输入事件的对象。不一定必须在屏幕上有可见的表示。所有小部件都排列在小部件树中（从计算机科学类中已知的树数据结构）：一个小部件可以具有任意数量的子级小部件或无。树的顶部只有一个根窗口小部件，没有父窗口小部件，而所有其他小部件直接或间接是此小部件的子级（这就是为什么将其称为根）的原因。</p>
<p>当有新的输入数据可用时，Kivy每次触摸都会发出一个事件。小部件的根小部件树首先接收事件。根据触摸状态，<code>on_touch_down</code>，<code>on_touch_move</code>或<code>on_touch_up</code>事件被调度（以touch作为参数）到根窗口小部件，结果在根小部件的相应<code>on_touch_down</code>，<code>on_touch_move</code>或<code>on_touch_up</code>事件处理程序中被呼叫。</p>
<p>树中的每个窗口小部件（包括根窗口小部件）都可以选择摘要事件或将事件继续传递。如果事件处理程序返回True，则表示该事件已被摘要并正确处理。 没有该事件将进行进一步处理。否则，事件处理程序会将小部件传递给通过调用其超类的相应事件处理程序的实现来调用自己的子级。这去一直到baseWidget类，在其触摸事件处理程序中，除了传递感动它的孩子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This is analogous for move/up:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_touch_down</span><span class="params">(self, touch)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> self.children[:]:</span><br><span class="line">        <span class="keyword">if</span> child.dispatch(<span class="string">'on_touch_down'</span>, touch):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>这确实比最初看起来容易得多。 如何将其用于创建漂亮的应用程序的示例下一节将很快给出。</p>
<p>通常，您会希望限制小部件监视触摸的屏幕区域。您可以使用小部件的<code>collide_point()</code>方法来实现此目的。您只需将触摸的位置传递给它如果触摸在“观看区域”内，则返回True；否则返回False。默认情况下，这会检查小部件的pos（位置； x和y）和大小所描述的屏幕上的矩形区域（宽度和高度），但是您可以在自己的课程中覆盖此行为。</p>
<h2 id="活动和属性"><a href="#活动和属性" class="headerlink" title="活动和属性"></a>活动和属性</h2><p>事件是Kivy编程的重要组成部分。对于使用GUI的人来说，这可能不足为奇开发经验，但这对新来者来说是重要的概念。一旦你了解了事件有效，以及如何绑定它们，您会在Kivy中到处看到它们。他们很容易将您想要的任何行为建立到Kivy中。</p>
<p>下图显示了如何在Kivy框架中处理事件。<br><img src="https://s2.ax1x.com/2020/02/13/1L0xfK.png" alt="1L0xfK.png"></p>
<h3 id="事件分派器简介"><a href="#事件分派器简介" class="headerlink" title="事件分派器简介"></a>事件分派器简介</h3><p>该框架最重要的基类之一是EventDispatcher类。这个班允许您注册事件类型，并将其分派给感兴趣的各方（通常是其他事件分派器）。Widget，Animation和Clock类是事件分配器的示例。</p>
<p>EventDispatcher对象依赖于主循环来生成和处理事件。</p>
<h3 id="主循环"><a href="#主循环" class="headerlink" title="主循环"></a>主循环</h3><p>如上图所示，Kivy具有一个主循环。 此循环正在所有应用程序的运行期间运行生存期，仅在退出应用程序时退出。</p>
<p>在循环内部，每次迭代都会从用户输入，硬件传感器或几个事件生成事件其他来源，并将帧渲染到显示器。</p>
<p>您的应用程序将指定回调（稍后会详细介绍），这些回调由主循环调用。如果回调时间太长或根本没有退出，主循环中断并且您的应用无法正常运行不再。</p>
<p>在Kivy应用程序中，必须避免长时间/无限循环或休眠。例如下面的代码两者都做：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    animate_something()</span><br><span class="line">    time.sleep(<span class="number">.10</span>)</span><br></pre></td></tr></table></figure>
<p>当您运行此程序时，该程序将永远不会退出循环，从而阻止Kivy执行其他所有操作需要做的事情。结果，您将看到的是一个黑色的窗口，您将无法交互用。相反，您需要“计划”您的<code>animate_something()</code>函数以反复调用。</p>
<h4 id="安排重复事件"><a href="#安排重复事件" class="headerlink" title="安排重复事件"></a>安排重复事件</h4><p>您可以使用<code>schedule_interval()</code>每秒每X次调用一次函数或方法。 这是每秒调用一次名为<code>my_callback</code>的函数30次的示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_callback</span><span class="params">(dt)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'My callback is called'</span>, dt</span><br><span class="line">event = Clock.schedule_interval(my_callback, <span class="number">1</span> / <span class="number">30.</span>)</span><br></pre></td></tr></table></figure>
<p>您可以采用多种方式取消安排先前安排的事件。一种是使用<code>cancel()</code>或<br><code>unschedule()</code>：</p>
<p><code>event.cancel()</code></p>
<p>或者：</p>
<p><code>Clock.unschedule(event)</code></p>
<p>另外，您可以在回调中返回False，事件将自动取消计划：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_callback</span><span class="params">(dt)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> count</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'Last call of my callback, bye bye !'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'My callback is called'</span>)</span><br><span class="line">Clock.schedule_interval(my_callback, <span class="number">1</span> / <span class="number">30.</span>)</span><br></pre></td></tr></table></figure>
<h4 id="计划一个事件"><a href="#计划一个事件" class="headerlink" title="计划一个事件"></a>计划一个事件</h4><p>使用<code>schedule_once()</code>，您可以调用函数“稍后”，例如在下一帧或X秒内：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_callback</span><span class="params">(dt)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'My callback is called !'</span></span><br><span class="line">Clock.schedule_once(my_callback, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>这将在一秒钟内调用<code>my_callback</code>。第二个参数是要等待的时间量调用该函数，以秒为单位。但是，您可以使用特殊的值获得其他一些结果第二个参数：</p>
<ul>
<li>如果X大于0，则回调将在X秒内被调用</li>
<li>如果X为0，则在下一帧之后将调用回调</li>
<li>如果X为-1，则将在下一帧之前调用回调</li>
</ul>
<p>-1通常用于已经安排好的活动中，并且要安排通话时在下一帧发生之前。</p>
<p>重复函数调用的第二种方法是先使用<code>schedule_once()</code>，以及在回调自身内部的第二次调用此函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_callback</span><span class="params">(dt)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'My callback is called !'</span></span><br><span class="line">    Clock.schedule_once(my_callback, <span class="number">1</span>)</span><br><span class="line">Clock.schedule_once(my_callback, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>尽管主循环将尝试按要求保持进度，但在某些方面存在不确定性确切地说，何时将调用计划的回调。有时，另一个回调或其他一些任务应用所需的时间比预期的要长，因此时间可能会稍短。</p>
<p>在后一种解决重复性回调问题的方法中，下一次迭代将至少称为一个最后一次迭代结束后的第二秒。但是，使用<code>schedule_interval()</code>时，每个回调都会被调用第二。</p>
<h4 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h4><p>有时您可能希望将某个函数安排为下一帧仅被调用一次，以防止重复通话。您可能会很想这样实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># First, schedule once.</span></span><br><span class="line">event = Clock.schedule_once(my_callback, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># Then, in another place you will have to unschedule first</span></span><br><span class="line"><span class="comment"># to avoid duplicate call. Then you can schedule again.</span></span><br><span class="line">Clock.unschedule(event)</span><br><span class="line">event = Clock.schedule_once(my_callback, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>通过这种方式对触发器进行编程非常昂贵，因为即使事件已经完成了。此外，每次都会创建一个新事件。改用触发器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trigger = Clock.create_trigger(my_callback)</span><br><span class="line"><span class="comment"># later</span></span><br><span class="line">trigger()</span><br></pre></td></tr></table></figure>
<p>每次调用<code>trigger()</code>时，它将安排一次回调调用。如果已经安排好了不会重新安排。</p>
<h3 id="小部件事件"><a href="#小部件事件" class="headerlink" title="小部件事件"></a>小部件事件</h3><p>小部件具有2种默认事件类型：</p>
<ul>
<li>属性事件：如果窗口小部件更改其位置或大小，则将触发一个事件。</li>
<li>窗口小部件定义的事件：例如 按下或释放按钮时会触发一个事件。</li>
</ul>
<p>有关如何管理和传播窗口小部件触摸事件的讨论，请参考窗口小部件触摸事件冒泡部分。</p>
<h3 id="创建自定义事件"><a href="#创建自定义事件" class="headerlink" title="创建自定义事件"></a>创建自定义事件</h3><p>要使用自定义事件创建事件分配器，您需要在类中注册事件的名称,然后创建一个同名的方法。</p>
<p>请参见以下示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEventDispatcher</span><span class="params">(EventDispatcher)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        self.register_event_type(<span class="string">'on_test'</span>)</span><br><span class="line">        super(MyEventDispatcher, self).__init__(**kwargs)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_something</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="comment"># when do_something is called, the 'on_test' event will be</span></span><br><span class="line">        <span class="comment"># dispatched with the value</span></span><br><span class="line">        self.dispatch(<span class="string">'on_test'</span>, value)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_test</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"I am dispatched"</span>, args</span><br></pre></td></tr></table></figure>

<h3 id="附加回调"><a href="#附加回调" class="headerlink" title="附加回调"></a>附加回调</h3><p>要使用事件，您必须将回调绑定到事件。调度事件后，您的回调将使用与该特定事件相关的参数调用。</p>
<p>回调可以是任何可调用的python，但是您需要确保其接受该事件的参数发出。为此，通常最安全的方法是接受<code>* args</code>参数，该参数会捕获参数列表。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_callback</span><span class="params">(value, *args)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Hello, I got an event!"</span>, args</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ev = MyEventDispatcher()</span><br><span class="line">ev.bind(on_test=my_callback)</span><br><span class="line">ev.do_something(<span class="string">'test'</span>)</span><br></pre></td></tr></table></figure>
<p>请参阅<code>kivy.event.EventDispatcher.bind()</code>方法文档以获取更多示例关于如何附加回调。</p>
<h3 id="物业介绍"><a href="#物业介绍" class="headerlink" title="物业介绍"></a>物业介绍</h3><p>属性是定义事件并将其绑定的一种很棒的方法。本质上，它们产生事件,这样，当对象的属性更改时，所有引用该属性的属性都会自动更新。</p>
<p>有不同类型的属性来描述您要处理的数据类型。</p>
<ul>
<li><strong>StringProperty</strong></li>
<li><strong>NumericProperty</strong></li>
<li><strong>BoundedNumericProperty</strong></li>
<li><strong>ObjectProperty</strong></li>
<li><strong>DictProperty</strong></li>
<li><strong>ListProperty</strong></li>
<li><strong>OptionProperty</strong></li>
<li><strong>AliasProperty</strong></li>
<li><strong>BooleanProperty</strong></li>
<li><strong>ReferenceListProperty</strong></li>
</ul>
<h3 id="财产申报"><a href="#财产申报" class="headerlink" title="财产申报"></a>财产申报</h3><p>要声明属性，必须在类级别声明它们。 然后，该班级将做创建对象时实例化真实属性。这些属性不是属性：它们是根据您的属性创建事件的机制：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWidget</span><span class="params">(Widget)</span>:</span></span><br><span class="line"></span><br><span class="line">    text = StringProperty(<span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<p>覆盖<code>__init__</code>时，请始终接受<code>**kwargs</code>并使用<code>super()</code>调用父级的<code>__init__</code>方法，传递您的类实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">    super(MyWidget, self).__init__(**kwargs)</span><br></pre></td></tr></table></figure>

<h3 id="调度属性事件"><a href="#调度属性事件" class="headerlink" title="调度属性事件"></a>调度属性事件</h3><p>默认情况下，Kivy属性提供on_<property_name>事件。当值属性的更改。</property_name></p>
<hr>
<p><strong>注意：如果属性的新值等于当前值，则on_ <property_name>事件不会被调用。</property_name></strong></p>
<hr>
<p>例如，考虑以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomBtn</span><span class="params">(Widget)</span>:</span></span><br><span class="line"></span><br><span class="line">    pressed = ListProperty([<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_touch_down</span><span class="params">(self, touch)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.collide_point(*touch.pos):</span><br><span class="line">            self.pressed = touch.pos</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> super(CustomBtn, self).on_touch_down(touch)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_pressed</span><span class="params">(self, instance, pos)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'pressed at &#123;pos&#125;'</span>.format(pos=pos))</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，第3行：</p>
<p><code>pressed = ListProperty([0, 0])</code></p>
<p>我们定义类型为ListProperty的pressed属性，并为其提供默认值[0，0]。由此向前指出，只要更改此属性的值，就会调用on_pressed事件。</p>
<p>在第5行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_touch_down</span><span class="params">(self, touch)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.collide_point(*touch.pos):</span><br><span class="line">        self.pressed = touch.pos</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> super(CustomBtn, self).on_touch_down(touch)</span><br></pre></td></tr></table></figure>
<p>我们重写Widget类的<code>on_touch_down()</code>方法。在这里，我们检查触摸我们的小部件。</p>
<p>如果触摸落入我们的小部件内部，我们将pressed的值更改为touch.pos并返回True，表示我们已经消耗了触摸并且不希望其进一步传播。</p>
<p>最后，如果触摸超出了我们的小部件，我们将使用<code>super（...）</code>调用原始事件，并返回结果。这使得触摸事件传播可以像通常发生的那样继续进行。</p>
<p>最后在第11行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_pressed</span><span class="params">(self, instance, pos)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'pressed at &#123;pos&#125;'</span>.format(pos=pos))</span><br></pre></td></tr></table></figure>
<p>我们定义了一个<em>on_pressed</em>函数，只要更改属性值，属性就会调用该函数。</p>
<hr>
<p><strong>注意：此on_ <prop_name>事件在定义属性的类中调用。 要监视/观察对定义类之外的属性的任何更改，您应按如下所示绑定到该属性。</prop_name></strong></p>
<hr>
<p><strong>绑定到属性</strong></p>
<p>当您仅拥有窗口小部件实例时，如何监视对属性的更改？ 您绑定到属性：</p>
<p><code>your_widget_instance.bind(property_name=function_name)</code></p>
<p>例如，考虑以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootWidget</span><span class="params">(BoxLayout)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        super(RootWidget, self).__init__(**kwargs)</span><br><span class="line">        self.add_widget(Button(text=<span class="string">'btn 1'</span>))</span><br><span class="line">        cb = CustomBtn()</span><br><span class="line">        cb.bind(pressed=self.btn_pressed)</span><br><span class="line">        self.add_widget(cb)</span><br><span class="line">        self.add_widget(Button(text=<span class="string">'btn 2'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">btn_pressed</span><span class="params">(self, instance, pos)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'pos: printed from root widget: &#123;pos&#125;'</span>.format(pos=.pos))</span><br></pre></td></tr></table></figure>
<p>如果按原样运行代码，则会在控制台中看到两个打印语句。一个来自在CustomBtn类内部调用的on_pressed事件，另一个来自我们绑定到属性更改的btn_pressed函数。</p>
<p>调用两个函数的原因很简单。绑定并不意味着覆盖。 同时拥有这两个功能是多余的，通常应仅使用侦听/响应属性更改的方法之一。</p>
<p>您还应该注意传递给on_ <property_name>事件的参数或绑定到该属性的函数。</property_name></p>
<p><code>def btn_pressed(self, instance, pos):</code></p>
<p>第一个参数是self，它是定义此函数的类的实例。 您可以如下使用嵌入式函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cb = CustomBtn()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_local_func</span><span class="params">(instance, pos)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'pos: printed from root widget: &#123;pos&#125;'</span>.format(pos=pos))</span><br><span class="line"></span><br><span class="line">cb.bind(pressed=_local_func)</span><br><span class="line">self.add_widget(cb)</span><br></pre></td></tr></table></figure>
<p>第一个参数将是定义属性的类的实例。</p>
<p>第二个参数是值，它是属性的新值。</p>
<p>这是从上面的片段衍生而来的完整示例，您可以使用该示例复制并粘贴到编辑器中进行实验。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> kivy.app <span class="keyword">import</span> App</span><br><span class="line"><span class="keyword">from</span> kivy.uix.widget <span class="keyword">import</span> Widget</span><br><span class="line"><span class="keyword">from</span> kivy.uix.button <span class="keyword">import</span> Button</span><br><span class="line"><span class="keyword">from</span> kivy.uix.boxlayout <span class="keyword">import</span> BoxLayout</span><br><span class="line"><span class="keyword">from</span> kivy.properties <span class="keyword">import</span> ListProperty</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootWidget</span><span class="params">(BoxLayout)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        super(RootWidget, self).__init__(**kwargs)</span><br><span class="line">        self.add_widget(Button(text=<span class="string">'btn 1'</span>))</span><br><span class="line">        cb = CustomBtn()</span><br><span class="line">        cb.bind(pressed=self.btn_pressed)</span><br><span class="line">        self.add_widget(cb)</span><br><span class="line">        self.add_widget(Button(text=<span class="string">'btn 2'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">btn_pressed</span><span class="params">(self, instance, pos)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'pos: printed from root widget: &#123;pos&#125;'</span>.format(pos=pos))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomBtn</span><span class="params">(Widget)</span>:</span></span><br><span class="line">    pressed = ListProperty([<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_touch_down</span><span class="params">(self, touch)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.collide_point(*touch.pos):</span><br><span class="line">            self.pressed = touch.pos</span><br><span class="line">            <span class="comment"># we consumed the touch. return False here to propagate</span></span><br><span class="line">            <span class="comment"># the touch further to the children.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> super(CustomBtn, self).on_touch_down(touch)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_pressed</span><span class="params">(self, instance, pos)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'pressed at &#123;pos&#125;'</span>.format(pos=pos))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestApp</span><span class="params">(App)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> RootWidget()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    TestApp().run()</span><br></pre></td></tr></table></figure>
<p>运行上面的代码将为您提供以下输出：<br><img src="https://s2.ax1x.com/2020/02/15/1xwwnS.jpg" alt="1xwwnS.jpg"></p>
<p>我们的CustomBtn没有视觉表现，因此显示为黑色。 您可以触摸/单击黑色区域以在控制台上查看输出。</p>
<h3 id="复合性质"><a href="#复合性质" class="headerlink" title="复合性质"></a>复合性质</h3><p>定义AliasProperty时，通常您自己定义一个getter和setter函数。 在这里，由您来定义何时使用bind参数调用getter和setter函数。</p>
<p>考虑下面的代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cursor_pos = AliasProperty(_get_cursor_pos, <span class="literal">None</span>, bind=(<span class="string">'cursor'</span>, <span class="string">'padding'</span>, <span class="string">'pos'</span>, <span class="string">'size'</span>, <span class="string">'focus'</span>, <span class="string">'scroll_x'</span>, <span class="string">'scroll_y'</span>, <span class="string">'line_height'</span>, <span class="string">'line_spacing'</span>), cache=<span class="literal">True</span>)</span><br><span class="line"><span class="string">'''Current position of the cursor, in (x, y).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">:attr:`cursor_pos` is an :class:`~kivy.properties.AliasProperty`,</span></span><br><span class="line"><span class="string">read-only.</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<p>在这里cursor_pos是AliasProperty，它使用将setter部分设置为None的<em>getter _get_cursor_pos</em>，这意味着这是一个只读属性。</p>
<p>最后，bind参数定义当bind =参数中使用的任何属性更改时，将调度<em>on_cursor_pos</em>事件。</p>
<h2 id="输入管理"><a href="#输入管理" class="headerlink" title="输入管理"></a>输入管理</h2><h3 id="输入架构"><a href="#输入架构" class="headerlink" title="输入架构"></a>输入架构</h3><p>Kivy能够处理大多数类型的输入：鼠标，触摸屏，加速计，陀螺仪等。它在以下平台上处理本机多点触摸协议：Tuio，WM_Touch，MacMultitouchSupport，MT Protocol A / B和Android。</p>
<p>全局架构可以视为：</p>
<p><code>Input providers -&gt; Motion event -&gt; Post processing -&gt; Dispatch to Window</code></p>
<p>所有输入事件的类都是MotionEvent。它生成2种事件：</p>
<ul>
<li>触摸事件：至少包含X和Y位置的运动事件。所有触摸事件都在Widget树中调度。</li>
<li>非接触事件：其余所有事件。例如，加速度计是连续事件，没有位置。 它永远不会开始或停止。这些事件不会在Widget树上调度。</li>
</ul>
<p>Motion事件由输入提供程序生成。 输入提供者负责从操作系统，网络甚至其他应用程序读取输入事件。 存在多个输入提供程序，例如：</p>
<ul>
<li>TuioMotionEventProvider：创建UDP服务器并侦听TUIO / OSC消息。</li>
<li>WM_MotionEventProvider：使用Windows API读取多点触控信息并将其发送给Kivy。</li>
<li>ProbeSysfsHardwareProbe：在Linux中，遍历连接到计算机的所有硬件，并为找到的每个多点触控设备附加一个多点触控输入提供程序。</li>
<li>以及更多！</li>
</ul>
<p>编写应用程序时，无需创建输入提供程序。Kivy尝试自动检测可用的硬件。但是，如果要支持自定义硬件，则需要配置kivy使其起作用。</p>
<p>在将新创建的运动事件传递给用户之前，Kivy将后处理应用于输入。 分析每个运动事件，以检测和纠正错误的输入，并做出有意义的解释，例如：</p>
<ul>
<li>根据距离和时间阈值两次/三次检测</li>
<li>在硬件不准确时使事件更准确</li>
<li>如果本机触摸硬件正在发送位置几乎相同的事件，则减少生成的事件数量。</li>
</ul>
<p>经过处理后，运动事件将分派到Window。 如前所述，并非所有事件都分派到整个窗口小部件树：窗口会过滤它们。 对于给定事件：</p>
<ul>
<li>如果只是运动事件，它将被分派到on_motion()</li>
<li>如果是触摸事件，则触摸的（x，y）位置（0-1范围）将缩放为窗口大小（宽度/高度），并分配给：<ul>
<li>on_touch_down()</li>
<li>on_touch_move()</li>
<li>on_touch_up()</li>
</ul>
</li>
</ul>
<h3 id="运动事件配置文件"><a href="#运动事件配置文件" class="headerlink" title="运动事件配置文件"></a>运动事件配置文件</h3><p>根据您的硬件和使用的输入提供程序，可能会为您提供更多信息。 例如，触摸输入具有（x，y）位置，但也可能具有压力信息，斑点大小，加速度矢量等。</p>
<p>配置文件是一个字符串，指示运动事件中可用的功能。 假设您处于<code>on_touch_move</code>方法中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_touch_move</span><span class="params">(self, touch)</span>:</span></span><br><span class="line">    print(touch.profile)</span><br><span class="line">    <span class="keyword">return</span> super(..., self).on_touch_move(touch)</span><br></pre></td></tr></table></figure>
<p>打印输出：</p>
<p><code>[&#39;pos&#39;, &#39;angle&#39;]</code></p>
<hr>
<p><strong>警告：许多人混淆了个人资料的名称和相应属性的名称。 仅仅因为可用配置文件中包含“角度”，并不意味着触摸事件对象将具有angle属性。</strong></p>
<hr>
<p>对于“ pos”配置文件，属性pos，x和y将可用。 使用“角度”配置文件，属性a将可用。 如前所述，对于触摸事件，“ pos”是必需配置文件，而不是“ angle”。 您可以通过检查“角度”配置文件是否存在来扩展交互：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_touch_move</span><span class="params">(self, touch)</span>:</span></span><br><span class="line">    print(<span class="string">'The touch is at position'</span>, touch.pos)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'angle'</span> <span class="keyword">in</span> touch.profile:</span><br><span class="line">        print(<span class="string">'The touch angle is'</span>, touch.a)</span><br></pre></td></tr></table></figure>
<p>您可以在motionevent文档中找到可用配置文件的列表。</p>
<h3 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h3><p>触摸事件是专用的MotionEvent，其属性is_touch的值为True。 对于所有触摸事件，您将自动获得X和Y位置，并缩放到Window的宽度和高度。 换句话说，所有触摸事件都具有“ pos”配置文件。</p>
<h4 id="触控事件基础"><a href="#触控事件基础" class="headerlink" title="触控事件基础"></a>触控事件基础</h4><p>默认情况下，触摸事件将分派给所有当前显示的窗口小部件。 这意味着小部件将接收触摸事件，无论它是否在其物理区域内发生。</p>
<p>如果您有使用其他GUI工具包的经验，这可能会很直观。 这些通常将屏幕划分为几何区域，并且如果坐标位于窗口小部件区域之内，则仅向窗口小部件发送触摸或鼠标事件。</p>
<p>使用触摸输入时，此要求变得非常严格。 滑动，捏和长按很可能源自想要了解它们并对其做出反应的小部件外部。</p>
<p>为了提供最大的灵活性，Kivy将事件分派给所有小部件，并让它们决定如何对它们作出反应。 如果您只想响应小部件内的触摸事件，则只需检查：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_touch_down</span><span class="params">(self, touch)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.collide_point(*touch.pos):</span><br><span class="line">        <span class="comment"># The touch has occurred inside the widgets area. Do stuff!</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h4 id="座标"><a href="#座标" class="headerlink" title="座标"></a>座标</h4><p>在使用带有矩阵转换的小部件时，必须立即触摸矩阵转换。 诸如Scatter之类的某些小部件具有其自己的矩阵转换，这意味着触摸必须乘以散布矩阵才能正确地将触摸位置分配给Scatter的子级。</p>
<ul>
<li>获取父空间到本地空间的坐标：<code>to_local()</code></li>
<li>获取从本地空间到父空间的坐标：<code>to_parent()</code></li>
<li>获取局部空间到窗口空间的坐标：<code>to_window()</code></li>
<li>获取从窗口空间到本地空间的坐标：<code>to_widget()</code></li>
</ul>
<p>您必须使用其中之一将坐标正确缩放到上下文。 让我们看一下分散的实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_touch_down</span><span class="params">(self, touch)</span>:</span></span><br><span class="line">    <span class="comment"># 推动当前坐标，以便以后恢复</span></span><br><span class="line">    touch.push()</span><br><span class="line">    <span class="comment"># 将触摸坐标转换为局部空间</span></span><br><span class="line">    touch.apply_transform_2d(self.to_local)</span><br><span class="line">    <span class="comment"># 像往常一样向孩子派遣触摸</span></span><br><span class="line">    <span class="comment"># 触摸中的坐标现在在本地空间中</span></span><br><span class="line">    ret = super(..., self).on_touch_down(touch)</span><br><span class="line">    <span class="comment"># 无论结果如何，别忘了进行转换</span></span><br><span class="line">    <span class="comment"># 调用之后，因此坐标将返回到父空间</span></span><br><span class="line">    touch.pop()</span><br><span class="line">    <span class="comment"># 返回结果（取决于您想要的）。</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h4 id="触摸形状"><a href="#触摸形状" class="headerlink" title="触摸形状"></a>触摸形状</h4><p>如果触摸具有形状，它将反映在“形状”属性中。 现在，只能公开ShapeRect：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> kivy.input.shape <span class="keyword">import</span> ShapeRect</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_touch_move</span><span class="params">(self, touch)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(touch.shape, ShapeRect):</span><br><span class="line">        print(<span class="string">'My touch have a rectangle shape of size'</span>,</span><br><span class="line">              (touch.shape.width, touch.shape.height))</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<h4 id="双击"><a href="#双击" class="headerlink" title="双击"></a>双击</h4><p>双击是一次在一定距离内两次轻敲的动作。 由doubletap后处理模块计算得出。 您可以测试当前触摸是否是双击之一：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_touch_down</span><span class="params">(self, touch)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> touch.is_double_tap:</span><br><span class="line">        print(<span class="string">'Touch is a double tap !'</span>)</span><br><span class="line">        print(<span class="string">' - interval is'</span>, touch.double_tap_time)</span><br><span class="line">        print(<span class="string">' - distance between previous is'</span>, touch.double_tap_distance)</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<h4 id="三连击"><a href="#三连击" class="headerlink" title="三连击"></a>三连击</h4><p>三次轻击是在一个时间和距离内轻击三次的动作。 由三连击后处理模块计算得出。 您可以测试当前触摸是否是三次轻击之一：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_touch_down</span><span class="params">(self, touch)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> touch.is_triple_tap:</span><br><span class="line">        print(<span class="string">'Touch is a triple tap !'</span>)</span><br><span class="line">        print(<span class="string">' - interval is'</span>, touch.triple_tap_time)</span><br><span class="line">        print(<span class="string">' - distance between previous is'</span>, touch.triple_tap_distance)</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<h4 id="抓住触摸事件"><a href="#抓住触摸事件" class="headerlink" title="抓住触摸事件"></a>抓住触摸事件</h4><p>父窗口小部件可以通过<strong>inon_touch_down</strong>向其子窗口小部件发送触摸事件，而不能从<strong>on_touch_move</strong>或<strong>on_touch_up</strong>中向其分配事件。 在某些情况下可能会发生这种情况，例如当触摸运动位于父级的边界框之外时，因此父级决定不通知其子级该运动。</p>
<p>但是您可能想在<strong>on_touch_up</strong>中做一些事情。 假设您在<strong>on_touch_down</strong>事件中开始了某件事，例如播放声音，并且想在<strong>on_touch_up</strong>事件中完成某件事。您需要抓斗。</p>
<p>当您触摸时，将始终收到上移事件。但是抓取有一些限制：</p>
<ul>
<li>您将至少两次收到该事件：一次来自您的父母（正常事件），一次来自窗口（抓取）。</li>
<li>您可能会收到一个带有触摸式触摸的事件，但不是从您那里收到的：这可能是因为父级在触摸式触摸屏状态下已将触摸发送给了其子级。</li>
</ul>
<p>这是如何使用抓取的示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_touch_down</span><span class="params">(self, touch)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.collide_point(*touch.pos):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># if the touch collides with our widget, let's grab it</span></span><br><span class="line">        touch.grab(self)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># and accept the touch.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_touch_up</span><span class="params">(self, touch)</span>:</span></span><br><span class="line">    <span class="comment"># here, you don't check if the touch collides or things like that.</span></span><br><span class="line">    <span class="comment"># you just need to check if it's a grabbed touch event</span></span><br><span class="line">    <span class="keyword">if</span> touch.grab_current <span class="keyword">is</span> self:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># ok, the current touch is dispatched for us.</span></span><br><span class="line">        <span class="comment"># do something interesting here</span></span><br><span class="line">        print(<span class="string">'Hello world!'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># don't forget to ungrab ourself, or you might have side effects</span></span><br><span class="line">        touch.ungrab(self)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># and accept</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h4 id="触摸事件管理"><a href="#触摸事件管理" class="headerlink" title="触摸事件管理"></a>触摸事件管理</h4><p>为了查看如何在小部件之间控制和传播触摸事件，请参阅“小部件触摸事件冒泡”部分。</p>
<h3 id="游戏杆事件"><a href="#游戏杆事件" class="headerlink" title="游戏杆事件"></a>游戏杆事件</h3><p>操纵杆输入代表通过以下事件通过SDL2提供程序直接从物理或虚拟控制器接收的原始值：</p>
<ul>
<li>SDL_JOYAXISMOTION</li>
<li>SDL_JOYHATMOTION</li>
<li>SDL_JOYBALLMOTION</li>
<li>SDL_JOYBUTTONDOWN</li>
<li>SDL_JOYBUTTONUP</li>
</ul>
<p>每个运动事件都有一个最小值，最大值和默认值，可以达到：<br><img src="https://s2.ax1x.com/2020/02/15/1xXY6I.png" alt="1xXY6I.png"></p>
<p>另一方面，按钮事件基本上仅表示每个按钮的状态，即向上和向下，因此不存在这样的值。</p>
<ul>
<li>on_joy_button_up</li>
<li>on_joy_button_down</li>
</ul>
<h4 id="游戏杆事件基础"><a href="#游戏杆事件基础" class="headerlink" title="游戏杆事件基础"></a>游戏杆事件基础</h4><p>与触摸事件不同，操纵杆事件直接分派到Window，这意味着仅传递了一个值，例如 指定的轴，而不是多个轴。 如果您想将输入分离到不同的小部件，这将使事情变得更加困难，但这并非没有可能。 您可以使用Multiple dropfile示例作为灵感。</p>
<p>要获得操纵杆事件，首先需要将一些函数绑定到Window操纵杆事件，如下所示：</p>
<p><code>Window.bind(on_joy_axis=self.on_joy_axis)</code></p>
<p>然后，您需要为您使用的每个事件获取在Window中指定的参数，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_joy_axis</span><span class="params">(self, win, stickid, axisid, value)</span>:</span></span><br><span class="line">    print(win, stickid, axisid, value)</span><br></pre></td></tr></table></figure>
<p>变量stickid是发送值的控制器的ID，axisid是值所属的轴的ID。</p>
<h4 id="操纵杆输入"><a href="#操纵杆输入" class="headerlink" title="操纵杆输入"></a>操纵杆输入</h4><p>Kivy应该能够从指定为手柄，操纵杆的任何设备或基本上由SDL2提供程序识别的任何其他类型的游戏控制器中获取输入。 为了使事情变得容易，这里是一些通用控制器的布局以及每个部分的ID。</p>
<p>Xbox 360<br><img src="https://s2.ax1x.com/2020/02/15/1xjGUU.png" alt="1xjGUU.png"></p>
<h4 id="游戏杆调试"><a href="#游戏杆调试" class="headerlink" title="游戏杆调试"></a>游戏杆调试</h4><p>通常，您希望使用多个控制器调试应用程序，或针对_other_类型的控制器（例如，不同品牌）进行测试。 或者，您可能想使用一些可用的控制器仿真器，例如vJoy。</p>
<hr>
<p><strong>下一篇<span class="exturl" data-url="aHR0cDovL3d3dy5zaHVvc2h1b3l1bi5jbi9hcmNoaXZlcy80ODM4NS5odG1s">《Kivy参考文档（二）》<i class="fa fa-external-link-alt"></i></span></strong></p>
<hr>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2020/03/03/20561/" rel="bookmark">Kivy参考文档（三）</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2020/03/03/23592/" rel="bookmark">Kivy参考文档（二）</a></div>
    </li>
  </ul>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>十丿叶
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://blog.shuoshuoyun.cn/2020/02/12/48385/" title="Kivy参考文档（一）">https://blog.shuoshuoyun.cn/2020/02/12/48385/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/images/wechat_channel.jpg">
            <span class="icon">
              <i class="fab fa-weixin"></i>
            </span>

            <span class="label">WeChat</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/kivy/" rel="tag"><i class="fa fa-tag"></i> kivy</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/02/07/9903/" rel="prev" title="Chrome浏览器推荐插件">
      <i class="fa fa-chevron-left"></i> Chrome浏览器推荐插件
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/03/03/23592/" rel="next" title="Kivy参考文档（二）">
      Kivy参考文档（二） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><span class="exturl" data-url="aHR0cDovL3d3dy5iZWlhbi5taWl0Lmdvdi5jbg==">湘ICP备20008495号-1 </span>
      <img src="/images/beian.png" style="display: inline-block;"><span class="exturl" data-url="aHR0cDovL3d3dy5iZWlhbi5nb3YuY24vcG9ydGFsL3JlZ2lzdGVyU3lzdGVtSW5mbz9yZWNvcmRjb2RlPTQzMDUyMzAyMDAwMTIz">湘公网安备 43052302000123号 </span>
  </div>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heartbeat"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">十丿叶</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">116k</span>
</div>
  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZw==">NexT.Gemini</span> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="//unpkg.com/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/next-theme/pjax@0/pjax.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  











<script data-pjax>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




    <div class="pjax">
  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    new Valine(Object.assign({
      el  : '#valine-comments',
      path: location.pathname,
    }, {"enable":true,"appId":"SRvHJbrJB86zbizktl0F4Wz3-gzGzoHsz","appKey":"m3kGoyrm4o4V0uNWsxXkrUDF","placeholder":"说点什么吧~","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"language":"zh-cn","visitor":false,"comment_count":true,"recordIP":true,"serverURLs":null}
    ));
  }, window.Valine);
});
</script>

    </div>
</body>
</html>
