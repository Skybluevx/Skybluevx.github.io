<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo博客搭建</title>
    <url>/2020/07/17/41646/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>搭建这个网站的最开始的理由就是想找一个清净点的地方记录自己想记录的一些东西，并且不用有任何的担心文章会不会被删除之类的；所以不惜花费一点时间来搭建一个属于自己的主页，这样就可以<del>为所欲为</del>好好写博客了~</p>
<a id="more"></a>

<hr>
<h1 id="Hexo搭建本地博客"><a href="#Hexo搭建本地博客" class="headerlink" title="Hexo搭建本地博客"></a>Hexo搭建本地博客</h1><p>Hexo是一个快速、简洁且高效的博客框架。Hexo使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3Mv">hexo官方文档<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装<span class="exturl" data-url="aHR0cHM6Ly9naXQtZm9yLXdpbmRvd3MuZ2l0aHViLmlvLw==">git<i class="fa fa-external-link-alt"></i></span></h2><ul>
<li>安装时一直下一步即可，若出现加入系统环境变量的选项，则需要勾选上，否则需要自己手动加入；</li>
<li>检验是否成功添加到环境变量：打开cmd，输入<code>git version</code>，若出现<code>git</code>的版本，则说明成功添加。</li>
</ul>
<h2 id="安装nodeJs-LTS为长期维护版本，Current为最新版"><a href="#安装nodeJs-LTS为长期维护版本，Current为最新版" class="headerlink" title="安装nodeJs(LTS为长期维护版本，Current为最新版)"></a>安装<span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2VuLw==">nodeJs<i class="fa fa-external-link-alt"></i></span>(LTS为长期维护版本，Current为最新版)</h2><ul>
<li>安装时一直下一步，不过在 Custom Setup 这一步记得选<code>Add to PATH</code>，否则就需要自己手动添加到系统环境变量；</li>
<li>检验：打开cmd，输入<code>node</code>，若出现<code>node</code>的简介，则表示安装成功且成功添加到系统环境变量。</li>
</ul>
<h2 id="安装Heox"><a href="#安装Heox" class="headerlink" title="安装Heox"></a>安装Heox</h2><ul>
<li>打开cmd；</li>
<li>输入<code>npm install -g hexo-cli</code>（通过<code>npm</code>安装<code>hexo</code>，<code>-g</code>为全局安装）；</li>
<li>等待安装成功即可。</li>
</ul>
<h2 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a>创建博客</h2><ul>
<li>博客的初始化：<code>hexo init Blog</code> (这里的Blog为用于存放博客文件的地方，名字随意)；<br><img src="https://s2.ax1x.com/2020/01/28/1M3ZOP.png" alt="1M3ZOP.png"></li>
<li><code>cd Blog</code>；</li>
<li>安装npm相关组件：<code>npm inistall</code>；<br><img src="https://s2.ax1x.com/2020/01/28/1M8Xb6.png" alt="1M8Xb6.png"></li>
<li>生成静态页面：<code>hexo generate</code>或<code>hexo g</code>；</li>
<li>启动服务：<code>hexo server</code>或<code>hexo s</code>；<br>此时就可以打开浏览器，输入<code>http://localhost:4000</code>查看效果，本地博客搭建成功。<br><img src="https://s2.ax1x.com/2020/01/28/1MGeIS.png" alt="1MGeIS.png"></li>
</ul>
<hr>
<h1 id="桥接到github"><a href="#桥接到github" class="headerlink" title="桥接到github"></a>桥接到github</h1><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>新建一个名为&lt;你的用户名&gt;.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <span class="exturl" data-url="aHR0cDovL3Rlc3QuZ2l0aHViLmlv">http://test.github.io<i class="fa fa-external-link-alt"></i></span> 了，是不是很方便？</p>
<p>由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。<br><img src="https://s2.ax1x.com/2020/01/29/1MJwtS.png" alt="1MJwtS.png"></p>
<p><strong>几个注意的地方</strong>：</p>
<ul>
<li>注册的邮箱一定要验证，否则不会成功；</li>
<li>仓库名字必须是：username.github.io，其中username是你的用户名；</li>
<li>仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久。</li>
</ul>
<p>创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。</p>
<h2 id="配置github的-SSH-key"><a href="#配置github的-SSH-key" class="headerlink" title="配置github的 SSH key"></a>配置github的 SSH key</h2><p>为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。</p>
<p><strong>注意：本文是用 git bash 输入所有命令，用 cmd 可能会出错</strong></p>
<ul>
<li>检查本机已存在的ssh密钥：<code>$ cd ~/. ssh</code> 如果提示：No such file or directory 说明你是第一次使用git。</li>
<li>创建SSH：<code>ssh-keygen -t rsa -C &quot;邮件地址&quot;</code> <strong>注意：这里的邮件地址指的是你注册 github 的邮箱</strong>;</li>
<li>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录即<code>c:\Users\你的电脑用户名</code>，找到.ssh文件夹下的id_rsa.pub文件，记事本打开并复制里面的内容;</li>
<li>打开你的github主页，进入<code>个人设置 -&gt; SSH and GPG keys -&gt; New SSH key</code></li>
</ul>
<p><img src="https://s2.ax1x.com/2020/01/30/1l0isU.png" alt="1l0isU.png"></p>
<ul>
<li>将刚复制的内容粘贴到key那里，title随便填，保存。</li>
<li>打开cmd，输入<code>ssh -T git@github.com</code># 测试是否成功；</li>
</ul>
<p>如果提示<code>Are you sure you want to continue connecting (yes/no)?</code>，输入<code>yes</code>，然后会看到：<code>Hi h0ryit! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code>看到这个信息说明SSH已配置成功！</p>
<p>此时你还需要配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;liuxianan&quot;&#x2F;&#x2F; 你的github用户名</span><br><span class="line">git config --global user.email  &quot;xxx@qq.com&quot;&#x2F;&#x2F; 填写你的github注册邮箱</span><br></pre></td></tr></table></figure>

<h2 id="修改站点配置"><a href="#修改站点配置" class="headerlink" title="修改站点配置"></a>修改站点配置</h2><p>打开你的blog文件，找到_config.yml文件。修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy: </span><br><span class="line">    type: git  </span><br><span class="line">    repository:https:&#x2F;&#x2F;github.com&#x2F;YourgithubName&#x2F;YourgithubName.github.io.git </span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure>

<p>然后在站点文件夹目录下执行命令<code>npm install hexo-deployer-git --save</code></p>
<p>这样，你的本地博客就可以通过<code>hexo d</code>命令部署到<code>github</code>上了。</p>
<hr>
<h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>之前的博客搭建之初，对各个方面都不是很懂，因此对于博客的搭建以及美化优化做的并不是特别好；在经过一番思考过后，决定将博客的文件储存到服务器里，将博客的撰写以及上传工作都放到服务器里面，这样就不用担心文件的突然丢失了。同时也对博客的部署以及<code>NexT</code>模板的版本进行了更改，让我们有更好的体验~</p>
<h1 id="桥接到Coding"><a href="#桥接到Coding" class="headerlink" title="桥接到Coding"></a>桥接到Coding</h1><p>由于<code>github</code>是国外网站，我们将博客部署到那里时，对其进行访问会很慢，所以我们将博客的托管平台进行了更改，国内小编知道的比较大的代码托管平台就只知道<code>Gitee</code>和<code>Coding</code>了，目前<code>Gitee</code>平台的企业版本才可以免费支持<code>Pages</code>服务中的自动部署以及自定义域名服务，而<code>Coding</code>平台中这些都免费支持（虽然他的缺点也有一些，但是这个符合我们的要求，所以就选择了它~）。</p>
<p>将博客托管到<code>Coding</code>平台其实和<code>Github</code>差不多，大概也就下面三步：</p>
<div class="tabs" id="qiaojiedcoding"><ul class="nav-tabs"><li class="tab active"><a href="#qiaojiedcoding-1">创建仓库</a></li><li class="tab"><a href="#qiaojiedcoding-2">配置 SSH key</a></li><li class="tab"><a href="#qiaojiedcoding-3">开启静态网站服务</a></li><li class="tab"><a href="#qiaojiedcoding-4">修改站点配置</a></li></ul><div class="tab-content"><div class="tab-pane active" id="qiaojiedcoding-1"><p>这个应该不用多说了，很简单的，不过<code>Coding</code>里面有一点不一样的就是，首先是创建项目，项目里面可以创建个仓库，所以小伙伴们可以先创建一个项目，然后再创建相应的仓库，这里还有一点和<code>Github</code>不一样的就是，这里的仓库名字可以随意起~</p></div><div class="tab-pane" id="qiaojiedcoding-2"><p>如图，</p>
<p><strong>代码仓库</strong> –&gt; <strong>设置</strong> –&gt; <strong>部署公钥</strong></p>
<p><img src="https://s1.ax1x.com/2020/07/18/Ucl8eO.png" alt="Ucl8eO.png"></p>
<p>在这里面配置好自己的公钥即可，公钥的生成方法以及查看方法前面有介绍到。</p></div><div class="tab-pane" id="qiaojiedcoding-3"><p>如图，</p>
<p><strong>持续部署</strong> –&gt; <strong>静态网站</strong></p>
<p><img src="https://s1.ax1x.com/2020/07/17/U6vFAJ.png" alt="U6vFAJ.png"></p>
<p>若是没有这个选项的话，则需要手动开启：</p>
<p><strong>项目设置</strong> –&gt; <strong>项目与成员</strong> –&gt; <strong>功能开关</strong> –&gt; <strong>持续集成</strong> –&gt; <strong>打开开关</strong></p>
<p><img src="https://s1.ax1x.com/2020/07/17/U6xvLT.png" alt="U6xvLT.png"></p>
<p>静态网站初始设置：</p>
<p><strong>网站名称</strong>：随意</p>
<p><strong>部署来源</strong>：本项目仓库</p>
<ul>
<li><strong>选择项目</strong>：刚才创建的项目</li>
<li><strong>选择仓库</strong>：刚才创建的项目中的仓库</li>
</ul>
<p>其他的选项都选择默认</p>
<p><img src="https://s1.ax1x.com/2020/07/17/U6v9nU.png" alt="U6v9nU.png"></p>
<p>确定后就你的博客就搭建完成啦，赶紧去它给你的网址去看看吧~</p>
<p><img src="https://s1.ax1x.com/2020/07/18/UclmFJ.png" alt="UclmFJ.png"></p>
<p>这里小编的访问地址有两个，是因为小编自己绑定了域名~</p>
<div class="note info icon"><h2 id="个性域名"><a href="#个性域名" class="headerlink" title="个性域名"></a>个性域名</h2><p>大家可以自己去购买一个个性域名，这样会显得很不一样，而且也不用多少q~</p>
</div></div><div class="tab-pane" id="qiaojiedcoding-4"><p>打开文件<code>blog/_config.yml</code>，修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy: </span><br><span class="line">    type: git  </span><br><span class="line">    repository: git@e.coding.net:YourTeamName&#x2F;YourProjectName&#x2F;YourRepositoryName.git </span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure>

<p>最后，在<code>blog/</code>目录下执行命令<code>npm install hexo-deployer-git --save</code></p>
<p>这样，你的本地博客就可以通过<code>hexo d</code>命令部署到<code>Coding</code>上了，从此再也不用担心国内访问速度啦。</p></div></div></div>

<hr>
<h1 id="个性化设置"><a href="#个性化设置" class="headerlink" title="个性化设置"></a>个性化设置</h1><p>小编这次的个性化设置基本上参照<code>NexT</code>主题的官方文档设置的，传送门如下：</p>
<div class="link-grid"><div class="link-grid-container">
<div class="link-grid-image" style="background-image: url(/images/apple-touch-icon-next.png);"></div>
<p>Theme NexT</p><p>Stay Simple. Stay NexT.</p>
<a href="https://theme-next.js.org/" target="_blank" rel="noopener"></a>
</div></div>

<h2 id="常规配置"><a href="#常规配置" class="headerlink" title="常规配置"></a>常规配置</h2><p><code>hexo/_config.yml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title:  # 博客标题</span><br><span class="line">subtitle: &#39;&#39;  # 副标题</span><br><span class="line">description: &#39;&#39;  # 描述</span><br><span class="line">keywords:  # 关键字</span><br><span class="line">author:  # 作者</span><br><span class="line">language: zh-CN  # 语言 </span><br><span class="line">timezone: &#39;&#39;  # 时区</span><br></pre></td></tr></table></figure>

<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>默认的主题感觉还是不喜欢，所以这里小编选用的是<code>NexT</code>主题；安装方式如下：</p>
<div class="tabs" id="genghuanzt"><ul class="nav-tabs"><li class="tab active"><a href="#genghuanzt-1">最新版</a></li><li class="tab"><a href="#genghuanzt-2">稳定版</a></li></ul><div class="tab-content"><div class="tab-pane active" id="genghuanzt-1"><p>在<code>next/</code>下打开终端：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd hexo</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;next-theme&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="genghuanzt-2"><ol>
<li><p>前往<code>NexT</code>主题的版本发布页面前往选择下载：<a class="btn" href="https://github.com/next-theme/hexo-theme-next/releases" target="_blank" rel="noopener" title="Hexo&NexT"><i class="fa fa-home fa-fw fa-lg"></i>NexT-Releases</a>你需要的版本源代码（zip文件），例如： v8.0.0-rc.3</p>
</li>
<li><p>将zip文件解压到主题文件夹目录下并重命名为<code>next</code>即可。</p>
</li>
</ol></div></div></div>

<p>安装完成主题后即可在文件<code>blog/_config.yml</code>中启用主题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<p>启用完成后就可以在命令端执行：<code>hexo s --debug</code>，然后在浏览器中打开网址：<code>http://localhost:4000</code>就可以看到修改完成后的<code>next</code>主题啦。</p>
<h2 id="更换主题方案"><a href="#更换主题方案" class="headerlink" title="更换主题方案"></a>更换主题方案</h2><p><code>next/_config.yml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line"># scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure>

<p>这里有四种主题方案，各位同学可自行选择~</p>
<h2 id="精简静态文件"><a href="#精简静态文件" class="headerlink" title="精简静态文件"></a>精简静态文件</h2><p><code>next/_config.yml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 生成静态文件后移除不必要的文件。</span><br><span class="line">minify: true</span><br></pre></td></tr></table></figure>

<h2 id="更换网站图标"><a href="#更换网站图标" class="headerlink" title="更换网站图标"></a>更换网站图标</h2><p><code>next/_config.yml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: &#x2F;images&#x2F;favicon-16x16-next.ico</span><br><span class="line">  medium: &#x2F;images&#x2F;favicon-32x32-next.ico</span><br><span class="line">  apple_touch_icon: &#x2F;images&#x2F;apple-touch-icon-next.png</span><br><span class="line">  safari_pinned_tab: &#x2F;images&#x2F;logo.svg</span><br><span class="line">  #android_manifest: &#x2F;images&#x2F;manifest.json</span><br><span class="line">  #ms_browserconfig: &#x2F;images&#x2F;browserconfig.xml</span><br></pre></td></tr></table></figure>

<p>将自己喜欢的图片在网站：<a class="btn" href="http://www.bitbug.net/t" target="_blank" rel="noopener" title="icon制作网站"><i class="fas fa-bug fa-fw fa-lg"></i>比特虫</a> 制作成<code>ico</code>图标，制作两个，一个16X16的，一个32X32的，放在<code>next/source/images</code>中，用其相对文件路径替换<code>favicon</code>中的<code>small</code>和<code>medium</code>后的默认路径。</p>
<h2 id="网站底部"><a href="#网站底部" class="headerlink" title="网站底部"></a>网站底部</h2><p><code>next/_config.yml</code></p>
<h3 id="建站年份"><a href="#建站年份" class="headerlink" title="建站年份"></a>建站年份</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">footer:</span><br><span class="line">  # 建站年份，如果未启用，则默认未当前年份。</span><br><span class="line">  since: 2019</span><br></pre></td></tr></table></figure>

<h3 id="底部图标"><a href="#底部图标" class="headerlink" title="底部图标"></a>底部图标</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 底部图标相关信息</span><br><span class="line">icon:</span><br><span class="line">  # Icon 图标名字，详情见: https:&#x2F;&#x2F;fontawesome.com&#x2F;icons</span><br><span class="line">  name: fa fa-heartbeat</span><br><span class="line">  # 设置图标是否开启动画</span><br><span class="line">  animated: true</span><br><span class="line">  # 改变图标颜色</span><br><span class="line">  color: &quot;#ff0000&quot;</span><br><span class="line"></span><br><span class="line"># If not defined, &#96;author&#96; from Hexo &#96;_config.yml&#96; will be used.</span><br><span class="line">copyright:</span><br></pre></td></tr></table></figure>

<h3 id="Powered-by-Hexo-amp-NexT"><a href="#Powered-by-Hexo-amp-NexT" class="headerlink" title="Powered by Hexo &amp; NexT"></a>Powered by Hexo &amp; NexT</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 是否开启：Powered by Hexo &amp; NexT</span><br><span class="line">powered: true</span><br></pre></td></tr></table></figure>

<h3 id="备案信息"><a href="#备案信息" class="headerlink" title="备案信息"></a>备案信息</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 我们特有的备案信息选填项~详情见: http:&#x2F;&#x2F;www.beian.miit.gov.cn, http:&#x2F;&#x2F;www.beian.gov.cn</span><br><span class="line"># 网站备案</span><br><span class="line">beian:</span><br><span class="line">  enable: true</span><br><span class="line">  icp: 京ICP备1234567890号-1</span><br><span class="line">  # The digit in the num of gongan beian.</span><br><span class="line">  gongan_id: 1234567890</span><br><span class="line">  # The full num of gongan beian.</span><br><span class="line">  gongan_num: 京公网安备 1234567890号</span><br><span class="line">  # The icon for gongan beian. See: http:&#x2F;&#x2F;www.beian.gov.cn&#x2F;portal&#x2F;download</span><br><span class="line">  gongan_icon_url: &#x2F;images&#x2F;beian.png</span><br></pre></td></tr></table></figure>

<h2 id="深色模式"><a href="#深色模式" class="headerlink" title="深色模式"></a>深色模式</h2><p><code>next/_config.yml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Dark Mode</span><br><span class="line">darkmode: true</span><br></pre></td></tr></table></figure>

<div class="note warning"><h4 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h4><p>请确保您的浏览器支持暗模式。</p>
</div>

<h2 id="菜单栏设置"><a href="#菜单栏设置" class="headerlink" title="菜单栏设置"></a>菜单栏设置</h2><h3 id="启用默认菜单栏"><a href="#启用默认菜单栏" class="headerlink" title="启用默认菜单栏"></a>启用默认菜单栏</h3><p>在<code>next/_config.yml</code>启用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || fa fa-home</span><br><span class="line">  #about: &#x2F;about&#x2F; || fa fa-user</span><br><span class="line">  #tags: &#x2F;tags&#x2F; || fa fa-tags</span><br><span class="line">  #categories: &#x2F;categories&#x2F; || fa fa-th</span><br><span class="line">  #archives: &#x2F;archives&#x2F; || fa fa-archive</span><br><span class="line">  #schedule: &#x2F;schedule&#x2F; || fa fa-calendar</span><br><span class="line">  #sitemap: &#x2F;sitemap.xml || fa fa-sitemap</span><br><span class="line">  #commonweal: &#x2F;404&#x2F; || fa fa-heartbeat</span><br></pre></td></tr></table></figure>

<div class="note warning"><h4 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h4><p>除了<code>home</code>和<code>archives</code>，其他的菜单启用时，都要手动添加其页面；如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure>
</div>

<h3 id="添加自定义菜单"><a href="#添加自定义菜单" class="headerlink" title="添加自定义菜单"></a>添加自定义菜单</h3><div class="tabs" id="tianjiazdycd"><ul class="nav-tabs"><li class="tab active"><a href="#tianjiazdycd-1">第一步</a></li><li class="tab"><a href="#tianjiazdycd-2">第二步</a></li><li class="tab"><a href="#tianjiazdycd-3">第三步</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tianjiazdycd-1"><p>创建新的页面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd hexo-site</span><br><span class="line">hexo new page custom-name</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="tianjiazdycd-2"><p>将自定义菜单添加进<code>hexo/_config.yml</code>的<code>menu</code>中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || fa fa-home</span><br><span class="line">  archives: &#x2F;archives&#x2F; || fa fa-archive</span><br><span class="line">  custom-name: &#x2F;custom-name&#x2F; || fa fa-user</span><br></pre></td></tr></table></figure>

<div class="note success"><h4 id="温馨提示"><a href="#温馨提示" class="headerlink" title="温馨提示"></a>温馨提示</h4><p>自定义菜单相应显示的小图标，如<code>home</code>的<code>fa fa-home</code>，同学们可以前往<a class="btn" href="https://fontawesome.com/" target="_blank" rel="noopener" title="Font Awesome 官网"><i class="fas fa-flag fa-lg"></i>Font Awesome</a>寻找自己喜欢的小图标换上。</p>
</div></div><div class="tab-pane" id="tianjiazdycd-3"><p>为你的<code>custom-name</code>添加译文：</p>
<p>在<code>next/languages/zh-CN.yml</code>文件中的<code>menu</code>中添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">    custom-name: 自定义名字</span><br></pre></td></tr></table></figure>

<div class="note info"><p>因为我们启用的语言为<code>zh-CN</code>，因此需要在这里面添加<code>custome-name</code>相应的翻译，这样在博客中才会正确的显示我们自定义菜单的中文；否则就只会显示英文。</p>
</div></div></div></div>

<h3 id="添加二级子菜单"><a href="#添加二级子菜单" class="headerlink" title="添加二级子菜单"></a>添加二级子菜单</h3><p>添加子菜单方式如下：</p>
<p><code>next/_config.yml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || fa fa-home</span><br><span class="line">  archives: &#x2F;archives&#x2F; || fa fa-archive</span><br><span class="line">  sub-menu:                                       # 一级子菜单</span><br><span class="line">    default: &#x2F;sub-menu&#x2F; || fa fa-book             # 一级子菜单的配置</span><br><span class="line">    sub-sub-menu-1: &#x2F;sub-sub-menu || fa fa-plug   # 二级一号子菜单的配置</span><br><span class="line">    sub-sub-menu-2:                               # 二级二号子菜单</span><br><span class="line">      default: &#x2F;sub-suub-menu-2&#x2F; || fa fa-plug    # 二级二号子菜单配置</span><br><span class="line">      sub-sub-sub-menu: &#x2F;sub-sub-sub-menu || fa fa-search-plus</span><br></pre></td></tr></table></figure>

<div class="tabs" id="tianjiaejzcd"><ul class="nav-tabs"><li class="tab active"><a href="#tianjiaejzcd-1">添加中文译文</a></li><li class="tab"><a href="#tianjiaejzcd-2">添加子菜单文件</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tianjiaejzcd-1"><p>这里和添加自定义菜单时一样的，传送按钮<a class="btn" href="#tianjiazdycd-3"><i class="fa fa-"></i>添加译文</a></p></div><div class="tab-pane" id="tianjiaejzcd-2"><p>在目录<code>hexo/source/</code>下创建如下文件树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sub-menu</span><br><span class="line">    |</span><br><span class="line">    |— index.md</span><br><span class="line">    |— sub-sub-menu-1.md</span><br><span class="line">    |— sub-sub-menu-2</span><br><span class="line">             |</span><br><span class="line">             |— index.md</span><br><span class="line">             |— sub-sub-sub-menu.md</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里解释一下这些文件</p>
<ul>
<li><code>index.md</code>：当前文件目录下的默认博客文件</li>
<li><code>sub-sub-menu-1.md</code>：二级一号子菜单的博客文件</li>
<li><code>sub-sub-sub-menu.md</code>：三级子菜单的博客文件</li>
</ul>
<div class="note primary"><h4 id="温馨提示"><a href="#温馨提示" class="headerlink" title="温馨提示"></a>温馨提示</h4><p>这些文件小编暂时没有找到使用<code>hexo</code>命令来生成二级及其以下子菜单级文件目录及文件的方法，所以同学们可以自己手动创建。</p>
</div></div></div></div>

<h3 id="链接持久化"><a href="#链接持久化" class="headerlink" title="链接持久化"></a>链接持久化</h3><p>在<code>Hexo</code>中当我们创建的博客名包含中文的名的时候，<code>url</code>链接地址经常会变成一串很长字符串，不利于博客的链接分享，以及搜索引擎搜索，我们可以通过安装其他的插件来解决这个问题。</p>
<ol>
<li><p>安装<code>url</code>地址持久化插件:</p>
<p><code>npm install hexo-abbrlink --save</code></p>
</li>
<li><p>配置文件<code>hexo/_config.yml</code></p>
<p><code>permalink: :year/:month/:day/:abbrlink/</code></p>
</li>
</ol>
<hr>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><blockquote class="blockquote-center">
<p>感谢这些作者的无私奉献</p>

</blockquote>

<div class="link-grid"><div class="link-grid-container">
<div class="link-grid-image" style="background-image: url(/images/apple-touch-icon-next.png);"></div>
<p>Theme NexT</p><p>Stay Simple. Stay NexT.</p>
<a href="https://theme-next.js.org/" target="_blank" rel="noopener"></a>
</div><div class="link-grid-container">
<div class="link-grid-image" style="background-image: url(/images/apple-touch-icon-next.png);"></div>
<p>CSDN</p><p>GitHub Pages自定义域名后每次hexo d都会失效解决</p>
<a href="https://blog.csdn.net/fake_hydra/article/details/82414965" target="_blank" rel="noopener"></a>
</div><div class="link-grid-container">
<div class="link-grid-image" style="background-image: url(/images/apple-touch-icon-next.png);"></div>
<p>CSDN</p><p>hexo+github搭建免费个人博客</p>
<a href="https://blog.csdn.net/weixin_38788347/article/details/78154487" target="_blank" rel="noopener"></a>
</div><div class="link-grid-container">
<div class="link-grid-image" style="background-image: url(/images/apple-touch-icon-next.png);"></div>
<p>CSDN</p><p>hexo + next主题高级配置</p>
<a href="https://blog.csdn.net/destinytaoer/article/details/78400023" target="_blank" rel="noopener"></a>
</div><div class="link-grid-container">
<div class="link-grid-image" style="background-image: url(/images/apple-touch-icon-next.png);"></div>
<p>CSDN</p><p>Hexo框架下用NexT(v7.0+)主题美化博客</p>
<a href="https://blog.csdn.net/weixin_39345384/article/details/80785373" target="_blank" rel="noopener"></a>
</div><div class="link-grid-container">
<div class="link-grid-image" style="background-image: url(/images/apple-touch-icon-next.png);"></div>
<p>CSDN</p><p>快速搭建博客：写作技巧</p>
<a href="https://blog.csdn.net/weixin_41800884/article/details/103750672" target="_blank" rel="noopener"></a>
</div><div class="link-grid-container">
<div class="link-grid-image" style="background-image: url(/images/apple-touch-icon-next.png);"></div>
<p>CSDN</p><p>Hexo博客NexT主题终极配置</p>
<a href="https://blog.csdn.net/panchao888888/article/details/80666352" target="_blank" rel="noopener"></a>
</div><div class="link-grid-container">
<div class="link-grid-image" style="background-image: url(/images/apple-touch-icon-next.png);"></div>
<p>CSDN</p><p>Hexo+NexT（三）：Next主题配置详解</p>
<a href="https://blog.csdn.net/loze/article/details/94210320" target="_blank" rel="noopener"></a>
</div></div>



]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建云Jupyter笔记本</title>
    <url>/2020/07/16/57078/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1>]]></content>
      <tags>
        <tag>jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title>python项目集</title>
    <url>/2020/04/11/18013/</url>
    <content><![CDATA[<ol>
<li><p><a href="https://github.com/3b1b/manim" target="_blank" rel="noopener"><strong>Manim - Mathematical Animation Engine</strong></a></p>
<ul>
<li>Manim 是解释性数学视频的动画引擎。用于以编程方式创建精确的动画，如 3Blue1Brown 的视频中所展示的样例。</li>
</ul>
<a id="more"></a>

<hr>
</li>
</ol>
<ol start="2">
<li><p><a href="https://github.com/s0md3v/XSStrike" target="_blank" rel="noopener"><strong>XSStrike</strong></a></p>
<ul>
<li>XSStrike 是一个 Cross Site Scripting 检测套件，配备四个手写解析器，一个智能有效负载生成器，一个强大的模糊引擎和一个非常快速的爬虫。</li>
</ul>
<hr>
</li>
</ol>
<ol start="3">
<li><p><a href="https://github.com/wangshub/Douyin-Bot" target="_blank" rel="noopener"><strong>如何在抖音上找到漂亮小姐姐（抖音机器人）</strong></a></p>
<ul>
<li>使用 Python+ADB 做的 Python 抖音机器人。可以实现自动翻页、颜值检测、人脸识别、自动点赞、自动关注、随机防 Ban、自动评论等功能。</li>
</ul>
<hr>
</li>
</ol>
<ol start="4">
<li><p><a href="https://github.com/AtsushiSakai/PythonRobotics" target="_blank" rel="noopener"><strong>PythonRobotics</strong></a></p>
<ul>
<li>这是机器人算法的 Python 代码集合，尤其适用于自主导航。易于阅读并能快速理解每个算法的基本思想、选择被广泛使用和实用的算法、最低依赖性。</li>
</ul>
<hr>
</li>
</ol>
<ol start="5">
<li><p><a href="https://github.com/s0md3v/Photon" target="_blank" rel="noopener"><strong>Photon</strong></a></p>
<ul>
<li>为 OSINT 设计的爬虫，速度极其夸张！</li>
</ul>
<hr>
</li>
</ol>
<ol start="6">
<li><p><a href="https://github.com/hardikvasa/google-images-download" target="_blank" rel="noopener"><strong>Google Images Download</strong></a></p>
<ul>
<li><p>这是一个命令行 python 程序，用于搜索 Google Images 上的关键字 / 关键短语，并可选择将图像下载到本地计算机；还可以从另一个 python 文件调用此脚本。</p>
<p>另外，这还是一个小型可立即运行的程序。如果只想为每个关键字下载最多 100 个图像，则无需安装依赖。如果你想要每个关键字超过 100 个图像，那么你需要安装 Selenium 库和 chromedriver。</p>
</li>
</ul>
<hr>
</li>
</ol>
<ol start="7">
<li><p><a href="https://github.com/jofpin/trape" target="_blank" rel="noopener"><strong>trape (stable) v2.0</strong></a></p>
<ul>
<li><p>Trape 是一种 OSINT 分析和研究工具，允许实时跟踪和执行智能社会工程学攻击。</p>
<p>它的创建目的是向全世界介绍大型互联网公司如何获取机密信息，例如其网站或服务的会话状态，并通过浏览器控制用户，但它的发展是为了帮助政府和组织、公司和研究人员跟踪网络犯罪分子。</p>
</li>
</ul>
<hr>
</li>
</ol>
<ol start="8">
<li><p><a href="https://github.com/xonsh/xonsh" target="_blank" rel="noopener"><strong>xonsh</strong></a></p>
<ul>
<li>xonsh 是一个基于 Python 的跨平台，Unix shell 语言和命令提示符。该语言是 Python 3.4 + 的超集，带有额外的 shell 原语。xonsh（发音为 conch）适用于专家和新手的日常使用。</li>
</ul>
<hr>
</li>
</ol>
<ol start="9">
<li><p><a href="https://github.com/shobrook/rebound" target="_blank" rel="noopener"><strong>rebound</strong></a></p>
<ul>
<li>Rebound 是一个命令行工具，可在收到编译器错误时立即获取 Stack Overflow 结果。只需使用 rebound 命令执行文件。</li>
</ul>
<hr>
</li>
</ol>
<ol start="10">
<li><p><a href="https://github.com/google/gif-for-cli" target="_blank" rel="noopener"><strong>GIF for Cli</strong></a></p>
<ul>
<li>接收 GIF，短视频或查询 Tenor GIF API 并将其转换为动画 ASCII 艺术。使用 ANSI 转义序列执行动画和颜色支持。</li>
</ul>
<hr>
</li>
</ol>
<ol start="11">
<li><p><a href="https://github.com/snipsco/snips-nlu" target="_blank" rel="noopener"><strong>Snips NLU</strong></a></p>
<ul>
<li>Snips NLU（自然语言理解）是一个 Python 库，允许解析用自然语言编写的句子并提取结构化信息。</li>
</ul>
<hr>
</li>
</ol>
<ol start="12">
<li><p><a href="https://github.com/Greenwolf/social_mapper" target="_blank" rel="noopener"><strong>Social Mapper</strong></a></p>
<ul>
<li>Social Mapper 是一种开源智能工具，它使用面部识别来大规模地关联不同站点的社交媒体配置文件。它采用自动化方法在流行的社交媒体网站上搜索目标名称和图片，以准确地检测和分组人员的存在，将结果输出到人类操作员可以快速查看的报告中。</li>
</ul>
<hr>
</li>
</ol>
<ol start="13">
<li><p><a href="https://github.com/socialcopsdev/camelot" target="_blank" rel="noopener"><strong>Camelot: PDF Table Extraction for Humans</strong></a></p>
<ul>
<li>Camelot 是一个 Python 库，任何人都可以轻松地从 PDF 文件中提取表格！</li>
</ul>
<hr>
</li>
</ol>
<ol start="14">
<li><p><a href="https://github.com/haskellcamargo/sclack" target="_blank" rel="noopener"><strong>Sclack</strong></a></p>
<ul>
<li>命令行版 Slack，超酷</li>
</ul>
<hr>
</li>
</ol>
<ol start="15">
<li><p><a href="https://github.com/danmacnish/cartoonify?=mybridge&utm_medium=blog&utm_campaign=read_more" target="_blank" rel="noopener"><strong>Draw This</strong></a></p>
<ul>
<li>一个绘制漫画的宝丽来相机。拍照后会弹出一个涂鸦图片，这张图片是相机对它所见所闻的最佳诠释。相机是用于物体识别的神经网络、谷歌快速提取数据集、热敏打印机和树莓派的混搭。</li>
</ul>
<hr>
</li>
</ol>
<ol start="16">
<li><p><a href="https://github.com/kennethreitz/twitter-scraper" target="_blank" rel="noopener"><strong>Twitter Scraper</strong></a></p>
<ul>
<li>作者逆向了 Twitter 前端 API，消除了官方 API 速率限制，非常快。</li>
</ul>
<hr>
</li>
</ol>
<ol start="17">
<li><p><a href="https://github.com/cosme12/SimpleCoin" target="_blank" rel="noopener"><strong>SimpleCoin</strong></a></p>
<ul>
<li>这是一个非常简单，不安全和不完整的用于 Python 中加密货币的区块链实现。该项目的目标是制定一种工作区块链货币，使其尽可能简单并用作教材。</li>
</ul>
<hr>
</li>
</ol>
<ol start="18">
<li><p><a href="https://github.com/BasioMeusPuga/Lector" target="_blank" rel="noopener"><strong>Lector</strong></a></p>
<ul>
<li>Qt 写的电子书阅读器。</li>
</ul>
<hr>
</li>
</ol>
<ol start="19">
<li><p><a href="https://github.com/sunainapai/makesite" target="_blank" rel="noopener"><strong>makesite.py</strong></a></p>
<ul>
<li>用 Python 中编写自己的简单、轻量级的静态站点生成器，完全控制静态网站 / 博客的生成。</li>
</ul>
<hr>
</li>
</ol>
<ol start="20">
<li><p><a href="https://github.com/rianhunter/dbxfs" target="_blank" rel="noopener"><strong>dbxfs</strong></a></p>
<ul>
<li>dbxfs 允许将 Dropbox 文件夹挂载，就像它是本地文件系统一样。它与官方 Dropbox 客户端的不同之处主要有两种：访问需要 Internet 连接；访问不需要磁盘空间，但如果磁盘空间可用，则会缓存。</li>
</ul>
<hr>
</li>
</ol>
<ol start="21">
<li><p><a href="https://github.com/M4cs/BabySploit" target="_blank" rel="noopener"><strong>BabySploit</strong></a></p>
<ul>
<li>BabySploit 是一个渗透测试工具包，旨在让您轻松学习如何使用更大、更复杂的框架，如 Metasploit。通过一个非常易于使用的 UI 和工具包，任何经验级别的人都可以使用 BabySploit。</li>
</ul>
<hr>
</li>
</ol>
<ol start="22">
<li><p><a href="https://github.com/RameshAditya/asciify" target="_blank" rel="noopener"><strong>ASCIIFY</strong></a></p>
<ul>
<li>使用 Python 的强大功能将图像转换为 ASCII Art。</li>
</ul>
<hr>
</li>
</ol>
<ol start="23">
<li><p><a href="https://github.com/YoongiKim/AutoCrawler" target="_blank" rel="noopener"><strong>AutoCrawler</strong></a></p>
<ul>
<li>Google，Naver 多进程图像抓取工具（高品质，高速度和可自定义）</li>
</ul>
<hr>
</li>
</ol>
<ol start="24">
<li><p><a href="https://github.com/Squarespace/datasheets" target="_blank" rel="noopener"><strong>datasheets</strong></a></p>
<ul>
<li>datasheets 是一个用于与 Google 表格连接的库，包括从 Google 表格中读取、写入数据和修改 Google 表格的格式</li>
</ul>
<hr>
</li>
</ol>
<ol start="25">
<li><p><a href="https://github.com/ryu577/pyray" target="_blank" rel="noopener"><strong>pyray</strong></a></p>
<ul>
<li>Python 中使用 POV ray 渲染复杂的 3D 对象和场景，动画以及更多普通的香草 Python。</li>
</ul>
<hr>
</li>
</ol>
<ol start="26">
<li><p><a href="https://github.com/mikeyy/nonoCAPTCHA" target="_blank" rel="noopener"><strong>nonoCAPTCHA</strong></a></p>
<ul>
<li>一个异步 Python 库，使用 Mozilla 的 DeepSpeech，PocketSphinx，Microsoft Azure 和 Amazon 的 Transcribe Speech-to-Text API，通过音频自动解决 ReCAPTCHA v2。使用 Pyppeteer 构建 Chrome 自动化框架，与 Puppeteer 相似，PyDub 可轻松将 MP3 文件转换为 WAV，aiohttp 用于异步简约 Web 服务器，Python 内置 AsyncIO 以方便使用。</li>
</ul>
<hr>
</li>
</ol>
<ol start="27">
<li><p><a href="https://github.com/Erotemic/ubelt" target="_blank" rel="noopener"><strong>Ubelt</strong></a></p>
<ul>
<li>Ubelt 是一个包含强大、经过测试、简单函数的可扩展 Python 标准库。</li>
</ul>
<hr>
</li>
</ol>
<ol start="28">
<li><p><a href="https://github.com/avidLearnerInProgress/pyCAIR" target="_blank" rel="noopener"><strong>pyCAIR</strong></a></p>
<ul>
<li>pyCAIR 是一个基于 Seam Carving for Content-Aware Image Resizing 的内容感知图像大小调整（CAIR）库。</li>
</ul>
<hr>
</li>
</ol>
<ol start="29">
<li><p><a href="https://github.com/sdushantha/soundcloud-dl" target="_blank" rel="noopener"><strong>soundcloud-dl</strong></a></p>
<ul>
<li>以专辑封面和标签形式下载 128kbps 的 SoundCloud 音乐。</li>
</ul>
<hr>
</li>
</ol>
<ol start="30">
<li><p><a href="https://github.com/thoppe/pixelhouse" target="_blank" rel="noopener"><strong>pixelhouse</strong></a></p>
<ul>
<li>一个极简的绘图库，用于在 python 中制作精美的动画。</li>
</ul>
<hr>
</li>
</ol>
<ol start="31">
<li><p><a href="https://github.com/cuducos/twitter-cleanup" target="_blank" rel="noopener"><strong>Twitter Clean-up</strong></a></p>
<ul>
<li>Twitter 账户清理工具</li>
</ul>
<hr>
</li>
</ol>
<ol start="32">
<li><p><a href="https://github.com/Aditya-Khadilkar/Face-tracking-with-Anime-characters" target="_blank" rel="noopener"><strong>Face-tracking-with-Anime-characters</strong></a></p>
<ul>
<li>靠近摄像头，图片里的妹子会害羞的扭过头</li>
</ul>
<hr>
</li>
</ol>
<ol start="33">
<li><p><a href="https://github.com/YouTubeDownload/YouTubeDownload" target="_blank" rel="noopener"><strong>YouTube Download</strong></a></p>
<ul>
<li>Youtube 下载客户端。</li>
</ul>
<hr>
</li>
</ol>
<ol start="34">
<li><p><a href="https://github.com/mileshenrichs/spotify-playlist-generator" target="_blank" rel="noopener"><strong>Spotify Playlist Generator</strong></a></p>
<ul>
<li>Spotify Playlist Generator 是一个 Python 脚本，每周都会使用新音乐自动构建一个新的 Spotify 播放列表。</li>
</ul>
<hr>
</li>
</ol>
<ol start="35">
<li><p><a href="https://github.com/tvytlx/render-py" target="_blank" rel="noopener"><strong>render-py</strong></a></p>
<ul>
<li>一个用 Python 编写的软件 3D 渲染器，旨在让每个人都能轻松理解。</li>
</ul>
<hr>
</li>
</ol>
<ol start="36">
<li><p><a href="https://github.com/dizballanze/m00dbot" target="_blank" rel="noopener"><strong>Depression and anxiety self-testing telegram bot</strong></a></p>
<ul>
<li>电报机器人用于抑郁和焦虑的自我测试。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>项目</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>开发者常用工具集</title>
    <url>/2020/04/10/63973/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不同岗位的程序员也有千差万别，前端、算法、架构设计、测试……不同的岗位日常使用的工具截然不同。收集一些在开发中常用的<strong>软件/网站/插件/命令行工具</strong>。</p>
<a id="more"></a>

<p>下面主要从4个方面介绍：</p>
<ul>
<li>PC端软件</li>
<li>网页工具</li>
<li>浏览器插件</li>
<li>命令行工具</li>
</ul>
<h1 id="PC端工具"><a href="#PC端工具" class="headerlink" title="PC端工具"></a>PC端工具</h1><h2 id="VS-Code"><a href="#VS-Code" class="headerlink" title="VS Code"></a>VS Code</h2><p>第一名当然归属于神器 vscode ，这些年的开发中，IDE是接触最多的工具，无论前端JS，做服务开发时用Java，还是做算法时用Python，都离不开IDE。</p>
<p>以往，是每种编程语言选择在这种语言表现最优的IDE，例如，codeblocks、eclipse、Pycharm、webstorm 等等，但是有了 vscode，这些我统统卸载了。</p>
<p><strong>远程开发、丰富的主题、简易的配置、轻量化</strong>等等，若干优点让我爱不释手，详情可以查看我的另一篇文章：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpJME5UTTFNekEyTXc9PSZtaWQ9MjI0NzQ4NDc1NSZpZHg9MSZzbj04NzJiNWRjMTQzMmIzYTA3MzBlN2YxOWNjZWIyYjlmMyZzY2VuZT0yMSN3ZWNoYXRfcmVkaXJlY3Q=">我最终还是选择了VS code！<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="Sublime"><a href="#Sublime" class="headerlink" title="Sublime"></a>Sublime</h2><p>sublime是我接触较早，使用时间也较长的一款工具，最初是用来开发Python，后来写代码转向了vs code，sublime也就纯粹的成为了一款编辑工具。</p>
<p>支持编码格式丰富、运行流畅、界面美观等等，虽然，相对于UE、notepad++说不出它绝对的优势在哪，我还是依然习惯于使用这款工具。</p>
<h2 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h2><p>不同模块之间调用有很多种方式，数据库、函数接口、restful。其中restful应该是使用最为频繁的，不同语言，在这个过程中就涉及到测试Web API &amp; HTTP，Postman就变的异常重要。</p>
<p>它支持GET, HEAD, POST, PUT等任何方式的请求，多种格式的header、body体，比起另外写一个测试脚本或者curl实在节省很多时间。</p>
<h2 id="Xshell"><a href="#Xshell" class="headerlink" title="Xshell"></a>Xshell</h2><p>开发过程中，服务器是无法绕开的，这时候终端模拟工具就显得异常重要，之前用过Putty、mobaxterm等，但是最后还是选择了xshell。</p>
<p>支持丰富的主题，轻松管理远程主机，强大的快捷功能，灵活的定制化，流畅的使用体验等等，让我越使用，越喜欢这款工具。</p>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>这里需要多说一句废话，<strong>要区分git和GitHub</strong>，GitHub是一个开源项目托管平台，git一款版本控制工具。</p>
<p>在团队开发过程中，版本控制是必不可少的，提交、检视、MR等等，一系列的版本控制流程，让代码规范和交付更叫可靠，这里就离不开git。另外，git也支持很多常用Linux命令，所以，git对于我来说使用频率也是非常高的一款工具。</p>
<h2 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h2><p>文档，在开发过程中当然是必不可少的，而markdown在开发中更加是举足轻重。Markdown编辑工具数不胜数，在线的、PC端的，比比皆是，但是我还是选择 typora 。界面简洁，支持实时预览，支持多种公式类型，支持TOC等标签。</p>
<h2 id="Listary"><a href="#Listary" class="headerlink" title="Listary"></a>Listary</h2><p>listary 在一定程度上和everything有一些重叠，都可以用于文件搜索，但是有了listary之后我就很少使用everything，因为非常方便，当然，它也有不足之处，比如不能像everything那样使用正则表达式匹配，但是这丝毫不妨害它对我的吸引，调出非常方便，<strong>双击ctrl</strong>即可，而，最吸引我的地方是快速定位功能，无论是在文件夹内部，还是在控制面板、或者是在桌面，只要敲击一下要找的东西名称中的一个字母即可，此外，listary还可以作为快速启动软件使用，能够结合不同软件进行定制化，使用简短的字符匹配某一款软件，快速打开使用。</p>
<h2 id="CopyTranslator"><a href="#CopyTranslator" class="headerlink" title="CopyTranslator"></a>CopyTranslator</h2><p>作为学生、科研人员或者算法工程师等职位难免会接触英文文章，读英语文章有哪些痛点呢？英语水平差，这个当然排第一，如果英语水平好了，就不要再找什么翻译软件了。</p>
<p>我在阅读文献翻译英文时主要受困于如下几点，</p>
<ul>
<li>来回切换屏幕、复制、粘贴比较麻烦。</li>
<li>人工翻译不仅贵而且效果不好。</li>
<li>翻译软件有限制，比如我们用谷歌或百度翻译的时候，复制一段文章，拷贝到翻译框里，到换行符的位置会中断，这样就会让翻译的混乱不堪，还需要一个一个的把换行符删掉。</li>
</ul>
<p>CopyTranslator让翻译过程中变得快捷方便，而且，这款软件还支持点按复制、专注模式，能同时解决上述3个痛点。</p>
<h1 id="网页工具"><a href="#网页工具" class="headerlink" title="网页工具"></a>网页工具</h1><h2 id="Bootschool"><a href="#Bootschool" class="headerlink" title="Bootschool"></a>Bootschool</h2><p><strong>bootschool</strong>是一个JS插件和网站模板分享网站,提供各种JS插件、jQuery特效、插件指导、网站模板与插件在线预览,jQuery插件下载及教程。</p>
<p>也许，读到这里很多对JS不感兴趣的会感觉到失望，其实日常工作中我做JS开发的时间也不多，我只所以使用这个网站是因为它有丰富有趣的小功能，例如，<strong>自定义banner</strong>。</p>
<p>在我们做Python、Spring Boot开发时，为了显示更加个性化，会输出一些字符串形式的banner信息，bootschool可以根据输入内容快速生成<strong>ASCII文字</strong>，当然，我们也可以用在其他方面，让原本单调的日志信息变得多姿多彩。</p>
<h2 id="Jsoneditoronline"><a href="#Jsoneditoronline" class="headerlink" title="Jsoneditoronline"></a>Jsoneditoronline</h2><p>json格式是开发中非常常见的，包括http请求，数据持久化等等。json阅读和格式化就是一项非常必要的工作，之前使用过一段时间json.cn，但是自从同事给我推荐<strong>jsoneditoronline</strong>这款在线工具之后就再也没有用过其他的。</p>
<p>这是一款来自<strong>谷歌</strong>的在线工具，支持差异化对比、格式检查等等非常丰富而强大的 json 编辑和格式化功能。</p>
<h2 id="Explainshell"><a href="#Explainshell" class="headerlink" title="Explainshell"></a>Explainshell</h2><p>作为IT/互联网相关的工作人员，哪怕不是开发者，也有可能会和Linux打交道，我们可以用Linux进行开发、运维等，因此，Linux就成为了一项非常重要的个人技能。</p>
<p>使用Linux过程中主要打交道的对象就是繁多的Linux命令和选项(options)就成了令人头疼的事情，举一个最为简单的例子:</p>
<p><code>ls -al</code></p>
<p>这个Linux命令包含两个部分，command和options，ls是查看命令，-a和-l分别代表：显示所有文件(包括以.开头的隐藏文件)、以列表形式显示。</p>
<p>这些常用的我们都知道，但是有很多使用频率较少的怎么办？我们可以借助<strong>explainshell</strong>。它是一款利用Python开发的Linux命令行工具，通过解析帮助文档，逐个匹配一行Linux命令中不同字符的含义，让你对Linux命令能够一目了然，是一款非常棒的Linux学习工具。</p>
<h2 id="Nicetool"><a href="#Nicetool" class="headerlink" title="Nicetool"></a>Nicetool</h2><p><strong>Nicetool</strong>包含超过400个简单易用的工具收录其中，使用领域涵盖生活常用、办公辅助，教育学习，视频媒体，网络工具，程序开发，工具无需注册下载，即用即走。</p>
<h2 id="Alltoall"><a href="#Alltoall" class="headerlink" title="Alltoall"></a>Alltoall</h2><p><strong>alltoall</strong>是一个在线转换工具网站，200+种文件格式，视频、音频、图片、文档、表格、电子书等等，再也不用为文件格式转换下载各种工具和软件了。</p>
<h1 id="浏览器插件"><a href="#浏览器插件" class="headerlink" title="浏览器插件"></a>浏览器插件</h1><h2 id="OneTab"><a href="#OneTab" class="headerlink" title="OneTab"></a>OneTab</h2><p>同事说“<strong>自从你给我推荐了这款插件，我再也离不开它了。</strong>”</p>
<p>浏览器标签页是一样令人头疼的东西，至少对于我来说是这样的，每当打开一些网页之后会发现标签页密密麻麻，非常混乱，关闭后又担心会用到，不关闭实在影响浏览器的使用，而且过多的打开网页会带来很多内存占用。很久以来，一直没有找到好的解决方法，直到遇到OneTab这款插件，能够一键关闭、恢复所有标签页，而且能够节省高达95%的内容占用。</p>
<p>只需单击一下，就可以把所有标签页转化成一个列表，如果再次需要某个网页的时候，可以单个或者全部恢复标签页。</p>
<h2 id="SwitchyOmega"><a href="#SwitchyOmega" class="headerlink" title="SwitchyOmega"></a>SwitchyOmega</h2><p>我觉得校园网也是让很多大学生头疼的一个问题，外网无法访问校园网资源，校园网访问外网速度缓慢。怎么样才能在这两种网络之间自如切换？手动设置IE代理？那样效率太低了，不仅步骤繁琐，而且不能自动切换。SwitchyOmega就可以轻松解决代理切换问题，让你在不同的网络环境下自如切换代理，选择最快的代理方法打开你要的网页。</p>
<h2 id="Octotree"><a href="#Octotree" class="headerlink" title="Octotree"></a>Octotree</h2><p>Octotree是当之无愧的Github神器，强烈的推荐给大家。</p>
<p>查看某个文件是我使用Github过程中最苦恼的一个点，需要逐层进入一个目录，然后再逐层退出目录，这样不仅费劲，而且，如果网速不太好的话，查看一个文件需要耗费很长时间，例如，</p>
<p>Octotree的出现能够让Github体验提升到一个全新的水平，它能够以树形结构展示Github项目，更加易于阅读，能够快速查看某个文件，能够让Github像大多数IDE那样。</p>
<p>除此之外，Octotree还有一项非常实用的功能–下载单个文件。</p>
<h2 id="Click-amp-Clean"><a href="#Click-amp-Clean" class="headerlink" title="Click&amp;Clean"></a>Click&amp;Clean</h2><p>浏览器是我们使用最多的一款工具之一，甚至没有其中的之一。每天我们花费大量的时间在浏览器上面，访问各种网址，也留下了很多访问的足迹，这就涉及一个问题，除了缓存垃圾之外就是隐私和安全信息。不知不觉中我们把自己的信息展露无疑。我认为有着Click&amp;Clean这款超强的隐私保护工具就再也不用担心这个问题了。</p>
<ul>
<li>清除浏览历史记录, 清除下载历史记录</li>
<li>清空缓存</li>
<li>删除 Cookie</li>
<li>清除已保存的密码</li>
<li>浏览器关闭时运行外部应用程序</li>
<li>关闭所有窗口/标签前清理</li>
<li>…</li>
</ul>
<h2 id="Tampermonkey"><a href="#Tampermonkey" class="headerlink" title="Tampermonkey"></a>Tampermonkey</h2><p>可以毫不谦虚的说，Tampermonkey是目前最为流行的用户脚本管理器，它适用于 Chrome, Microsoft Edge, Safari, Opera Next, 和 Firefox。</p>
<p>用户脚本是一个什么东西？简而言之，不同脚本可以实现不同的功能。</p>
<p>Tampermonkey可以对这些功能进行管理，让你的浏览器如虎添翼,Tampermonkey有很多可选的脚本。</p>
<h1 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h1><h2 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h2><p>提到命令行工具，首推的自然是这款大杀器，bash的替代工具。bash算得上一款中规中矩的shell工具，没有什么缺陷，但是也谈不上优秀，在很多方面考虑的还不够周到，例如，自动补全、语法、高亮显示、提示符等。</p>
<p>提到oh-my-zsh，那就厉害了，102kStar、250+插件、125+主题、1450+贡献者……从这一系列的数字中就可以体现出这款shell工具的生态有多么完善，也足以体现它有多么强大。</p>
<h2 id="Tldr"><a href="#Tldr" class="headerlink" title="Tldr"></a>Tldr</h2><p>用Linux的过程中难免会和各种参数打交道，距离比如<code>ps -aux</code>、<code>tar -jxvf</code>、<code>find -name</code>，每个”-“后面的就是各种命令参数，大家比较熟悉的查看命令解释的方法有”command ?” “man command”，就是命令后面加？或者man加命令。以man为例，解释很详细，但是带来的问题就是冗余，有很多信息是我们不想看到的，所以tldr就凸显出它的优点，简洁、实用。</p>
<h2 id="Tig"><a href="#Tig" class="headerlink" title="Tig"></a>Tig</h2><p>Tig是一个基于ncurses的git文本模式接口。它的功能主要是作为一个Git存储库浏览器，但也可以帮助在块级别上分段提交更改，并充当各种Git命令输出的分页器。</p>
<h2 id="Autojump"><a href="#Autojump" class="headerlink" title="Autojump"></a>Autojump</h2><p>我们在Linux下开发时会频繁的切换工作目录，要一步一步的cd，pwd实在太麻烦了，autojump通过记录命令行中使用最多的目录并给定相应权重的数据块来进行工作，不需要完全输入目录名，甚至输错目录名都没问题。</p>
<p><strong>使用方法：</strong></p>
<p>跳转到包含foo的路径只需下面这个命令即可，autojump会通过维护的数据库进行跳转， <code>j foo</code></p>
<h2 id="Script"><a href="#Script" class="headerlink" title="Script"></a>Script</h2><p>很多时候，为了安全，需要对工作内容进行备份和保存。而script就是一个隐藏的记录器，它可以记录终端会话的所有内容，形成文件，对总是忘记工作内容的同学真是福音。</p>
<p><strong>使用方法：</strong></p>
<p>在终端输入script,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; script</span><br></pre></td></tr></table></figure>

<p>会显示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Script started, file is typescript</span><br></pre></td></tr></table></figure>

<p>接着可以开始自己的操作，想退出输入exit即可，当前目录下会生成一个名为trypescript的文件，里面记录了刚才的操作。</p>
<h2 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h2><p>刚接触非桌面Linux的同学大多数会感觉Linux没有Windows或Mac那么直观，的确，我们面对的就是一行行命令，文件夹、应用图标什么的都没有，自然不直观。但是可以借助一些工具来增强目录的直观性，这里推荐的就是tree，可以以类似于图像的树状图排列目录和文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tree                   #以树状图列出当前目录结构</span></span><br><span class="line">.                        <span class="comment">#当前目录结构</span></span><br><span class="line">|-- README  </span><br><span class="line">|-- examples.desktop  </span><br><span class="line">|-- file  </span><br><span class="line">|-- file.new  </span><br><span class="line">|-- index.htm  </span><br><span class="line">|-- test  </span><br><span class="line">| |-- README  </span><br><span class="line">| |-- file  </span><br><span class="line">| |-- testfile  </span><br><span class="line">| |-- testfile1</span><br></pre></td></tr></table></figure>

<h2 id="Httpie"><a href="#Httpie" class="headerlink" title="Httpie"></a>Httpie</h2><p>不同组件之间相互访问可以通过很多方式，其中restful是比较常用的一种。这里就涉及http请求，我们需要测试数据能够正确的上传和下载。在处理http请求过程中使用较多的工具就是curl。curl有很多明显的弊端：对用户不够友好，命令冗长；可视化效果差，没有高亮。httpie就是curl的一个非常好的替代者，它的使用更加简洁明了，而且能够高亮显示请求结果。</p>
<h2 id="Glances"><a href="#Glances" class="headerlink" title="Glances"></a>Glances</h2><p>glances就如同它的汉语意思那样，“一眼”、“一瞥”，能够通过一个简单的命令对系统信息一目了然，了如指掌。glances利用Python编写的一个跨平台的监视工具，旨在通过curses或基于Web的界面提供大量监视信息。</p>
<p>你不仅可以通过终端命令行使用该工具，还可以web界面、API接口等对服务器进行远程监控，可以将统计信息导出到文件或数据库。</p>
<hr>
<p>文章转自：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvMXNjQWFOZi1uQXpqTmtXQy1OOFdYUQ==">原文链接<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>特别声明：如有侵权，告知笔者，立删此文！</strong></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>学爬虫，你需要学习的东西！</title>
    <url>/2020/03/26/14790/</url>
    <content><![CDATA[<p>当今大数据的时代，网络爬虫已经成为了获取数据的一个重要手段。</p>
<p>但要学习好爬虫并没有那么简单。首先知识点和方向实在是太多了，它关系到了计算机网络、编程基础、前端开发、后端开发、App 开发与逆向、网络安全、数据库、运维、机器学习、数据分析等各个方向的内容，它像一张大网一样把现在一些主流的技术栈都连接在了一起。正因为涵盖的方向多，因此学习的东西也非常零散和杂乱，很多初学者搞不清楚究竟要学习哪些知识，学习过程中遇到反爬也不知道用什么方法来解决，本篇我们来做一些归纳和总结。</p>
<a id="more"></a>

<h2 id="初学爬虫"><a href="#初学爬虫" class="headerlink" title="初学爬虫"></a>初学爬虫</h2><p>一些最基本的网站，往往不带任何反爬措施。比如某个博客站点，我们要爬全站的话就顺着列表页爬到文章页，再把文章的时间、作者、正文等信息爬下来就可以了。</p>
<p>那代码怎么写呢？用 Python 的 requests 等库就够了，写一个基本的逻辑，顺着把一篇篇文章的源码获取下来，解析的话用 XPath、BeautifulSoup、PyQuery 或者正则表达式，或者粗暴的字符串匹配把想要的内容抠出来，再加个文本写入存下来就完事了。</p>
<p>代码很简单，就几个方法调用。逻辑很简单，几个循环加存储。最后就能看到一篇篇文章就被我们存到自己的电脑里面了。当然有的同学可能不太会写代码或者都懒得写，那么利用基本的可视化爬取工具，如某爪鱼、某裔采集器也能通过可视化点选的方式把数据爬下来。</p>
<p>如果存储方面稍微扩展一下的话，可以对接上 MySQL、MongoDB、Elasticsearch、Kafka 等等来保存数据，实现持久化存储。以后查询或者操作会更方便。</p>
<p>反正，不管效率如何，一个完全没有反爬的网站用最最基本的方式就搞定了。</p>
<p>到这里，你就说你会爬虫了吗？不，还差的远呢。</p>
<h2 id="Ajax、动态渲染"><a href="#Ajax、动态渲染" class="headerlink" title="Ajax、动态渲染"></a>Ajax、动态渲染</h2><p>随着互联网的发展，前端技术也在不断变化，数据的加载方式也不再是单纯的服务端渲染了。现在你可以看到很多网站的数据可能都是通过接口的形式传输的，或者即使不是接口那也是一些 JSON 的数据，然后经过 JavaScript 渲染得出来的。</p>
<p>这时候，你要再用 requests 来爬那就不顶用了，因为 requests 爬下来的源码是服务端渲染得到的，浏览器看到页面的和 requests 获取的结果是不一样的。真正的数据是经过 JavaScript 执行的出来的，数据来源可能是 Ajax，也可能是页面里的某些 Data，也可能是一些 ifame 页面等等，不过大多数情况下可能是 Ajax 接口获取的。</p>
<p>所以很多情况下需要分析 Ajax，知道这些接口的调用方式之后再用程序来模拟。但是有些接口带着加密参数，比如 token、sign 等等，又不好模拟，咋整呢？</p>
<p>一种方法就是去分析网站的 JavaScript 逻辑，死抠里面的代码，揪出来这些参数是怎么构造的，找出思路来了之后再用爬虫模拟或重写就行了。如果你解出来了，那么直接模拟的方式效率会高非常多，这里面就需要一些 JavaScript 基础了，当然有些网站加密逻辑做的太牛逼了，你可能花一个星期也解不出来，最后放弃了。</p>
<p>那这样解不出来或者不想解，那咋办呢？这时候可以有一种简单粗暴的方法就是直接用模拟浏览器的方式来爬取，比如用 Puppeteer、Pyppeteer、Selenium、Splash 等，这样爬取到的源代码就是真正的网页代码，数据自然就好提取了，同时也就绕过分析 Ajax 和一些 JavaScript 逻辑的过程。这种方式就做到了可见即可爬，难度也不大，同时模拟了浏览器，也不太会有一些法律方面的问题。</p>
<p>但其实后面的这种方法也会遇到各种反爬的情况，现在很多网站都会去识别 webdriver，看到你是用的 Selenium 等工具，直接干掉或不返回数据，所以你碰到这种网站还得来专门解一下这个问题。</p>
<h2 id="多进程、多线程、协程"><a href="#多进程、多线程、协程" class="headerlink" title="多进程、多线程、协程"></a>多进程、多线程、协程</h2><p>上面的情况如果用单线程的爬虫来模拟是比较简单的，但是有个问题就是速度慢啊。</p>
<p>爬虫是 IO 密集型的任务，所以可能大多数情况下都在等待网络的响应，如果网络响应速度慢，那就得一直等着。但这个空余的时间其实可以让 CPU 去做更多事情。那怎么办呢？多开点线程吧。</p>
<p>所以这时候我们就可以在某些场景下加上多进程、多线程，虽然说多线程有 GIL 锁，但对于爬虫来说其实影响没那么大，所以用上多进程、多线程都可以成倍地提高爬取速度，对应的库就有 threading、multiprocessing 了。</p>
<p>异步协程就更牛逼了，用 aiohttp、gevent、tornado 等等的基本上你想搞多少并发就搞多少并发，但是还是悠着点，别把人家网站搞挂了。</p>
<p>总之，用上这几个，爬虫速度就提上来了。</p>
<p>但速度提上来了不一定是好事，反爬接着肯定就要来了，封你 IP、封你账号、弹验证码、返回假数据，所以有时候龟速爬似乎也是个解决办法？</p>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p>多线程、多进程、协程都能加速，但终究还是单机的爬虫。要真正做到规模化，还得来靠分布式爬虫来搞。</p>
<p>分布式的核心是什么？资源共享。比如爬取队列共享、去重指纹共享等等。</p>
<p>我们可以使用一些基础的队列或组件来实现分布式，比如 RabbitMQ、Celery、Kafka、Redis 等等，但经过很多人的尝试，自己去实现一个分布式爬虫，性能和扩展性总会出现一些问题，当然特别牛逼的除外哈。不少企业内部其实也有自己开发的一套分布式爬虫，和业务更紧密，这种当然是最好了。</p>
<p>现在主流的 Python 分布式爬虫还是基于 Scrapy 的，对接 Scrapy-Redis、Scrapy-Redis-BloomFilter 或者用 Scrapy-Cluster 等等，他们都是基于 Redis 来共享爬取队列的，总会多多少少遇到一些内存的问题。所以一些人也考虑对接到了其他的消息队列上面，比如 RabbitMQ、Kafka 等等，解决一些问题，效率也不差。</p>
<p>总之，要提高爬取效率，分布式还是必须要掌握的。</p>
<h2 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h2><p>爬虫难免遇到反爬，验证码就是其中之一。要会反爬，那首先就要会解验证码。</p>
<p>现在你可以看到很多网站都会有各种各样的验证码了，比如最简单的图形验证码，要是验证码的文字规整的话，OCR 过一遍或者基本的模型库都能识别，不想搞这个的话可以直接去对接个打码平台来搞，准确率还是有的。</p>
<p>然而你可能现在都见不到什么图形验证码了，都是一些行为验证码，如某验、某盾等等，国外也有很多，比如 reCaptcha 等等。一些稍微简单一点的，比如滑动的，你可以找点办法识别缺口，比如图像处理比对、深度学习识别都是可以的。轨迹呢自己写个模拟正常人行为的，加点抖动之类的。有了轨迹之后咋模拟呢，如果你牛逼，那么可以直接去分析验证码的 JavaScript 逻辑，把轨迹数据录入，那就能得到里面的一些加密参数，直接拿着这些参数放到表单或接口里面就能直接用了。当然也可以用模拟浏览器的方式来拖动，也能通过一定的方式拿到加密参数，或者直接用模拟浏览器的方式把登录一起做了，拿着 Cookies 来爬也行。</p>
<p>当然拖动只是一种验证码，还有文字点选、逻辑推理等，要是真不想搞，可以找打码平台来解出来再模拟，但毕竟花钱的，一些高手就会选择自己训练深度学习相关的模型，收集数据、标注、训练，针对不同的业务训练不同的模型。这样有了核心技术，也不用再去花钱找打码平台了，再研究下验证码的逻辑模拟一下，加密参数就能解出来了。不过有的验证码难得很，有的我也没搞定。</p>
<p>当然有些验证码可能是请求过于频繁而弹出来的，这种如果换个 IP 什么的也能解。</p>
<h2 id="封-IP"><a href="#封-IP" class="headerlink" title="封 IP"></a>封 IP</h2><p>封 IP 也是个令人头疼的事，行之有效的方法就是换代理了。</p>
<p>代理很多种，市面上免费的，收费的太多太多了。</p>
<p>首先可以把市面上免费的代理用起来，自己搭建一个代理池，收集现在全网所有的免费代理，然后加一个测试器一直不断测试，测试的网址可以改成你要爬的网址。这样测试通过的一般都能直接拿来爬你的目标网站。我自己也搭建过一个代理池，现在对接了一些免费代理，定时爬、定时测，还写了个 API 来取，放在 GitHub 了：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1B5dGhvbjNXZWJTcGlkZXIvUHJveHlQb29s77yM5omT5aW95LqG">https://github.com/Python3WebSpider/ProxyPool，打好了<i class="fa fa-external-link-alt"></i></span> Docker 镜像，提供了 Kubernetes 脚本，大家可以直接拿来用。</p>
<p>付费代理也是一样，很多商家提供了代理提取接口，请求一下就能获取几十几百个代理，我们可以同样把它们接入到代理池里面。但这个代理也分各种套餐，什么开放代理、独享代理等等的质量和被封的几率也是不一样的。</p>
<p>有的商家还利用隧道技术搭了代理，这样代理的地址和端口我们是不知道的，代理池是由他们来维护的，比如某布云，这样用起来更省心一些，但是可控性就差一些。</p>
<p>还有更稳定的代理，比如拨号代理、蜂窝代理等等，接入成本会高一些，但是一定程度上也能解决一些封 IP 的问题。</p>
<p>不过这些背后也不简单，为啥一个好好的高匿代理就是莫名其妙爬不了，背后的一些事就不多讲了。</p>
<p>##封账号</p>
<p>有些信息需要模拟登录才能爬嘛，如果爬的过快，人家网站直接把你的账号封禁了，就啥都没得说了。比如爬公众号的，人家把你 WX 号封了，那就全完了。</p>
<p>一种解决方法当然就是放慢频率，控制下节奏。</p>
<p>还有种方法就是看看别的终端，比如手机页、App 页、wap 页，看看有没有能绕过登录的法子。</p>
<p>另外比较好的方法，那就是分流。如果你号足够多，建一个池子，比如 Cookies 池、Token 池、Sign 池反正不管什么池吧，多个账号跑出来的 Cookies、Token 都放到这个池子里面，用的时候随机从里面拿一个。如果你想保证爬取效率不变，那么 100 个账号相比 20 个账号，对于每个账号对应的 Cookies、Token 的取用频率就变成原来的了 1/5，那么被封的概率也就随之降低了。</p>
<h2 id="奇葩的反爬"><a href="#奇葩的反爬" class="headerlink" title="奇葩的反爬"></a>奇葩的反爬</h2><p>上面说的是几种比较主流的反爬，当然还有非常多奇葩的反爬。比如返回假数据、返回图片化数据、返回乱序数据、返回骂人的数据、返回求饶的数据，那都具体情况看着办吧。</p>
<p>这些反爬也得小心点，之前见过一个反爬直接返回 <code>rm -rf /</code> 的也不是没有，你要是正好有个脚本模拟执行返回结果，后果自己想象哈。</p>
<h2 id="JavaScript-逆向"><a href="#JavaScript-逆向" class="headerlink" title="JavaScript 逆向"></a>JavaScript 逆向</h2><p>说到重头了。随着前端技术的进步和网站反爬意识的增强，很多网站选择在前端上下功夫，那就是在前端对一些逻辑或代码进行加密或混淆。当然这不仅仅是为了保护前端的代码不被轻易盗取，更重要的是反爬。比如很多 Ajax 接口都会带着一些参数，比如 sign、token 等等，这些前文也讲过了。这种数据我们可以用前文所说的 Selenium 等方式来爬，但总归来说效率太低了，毕竟它模拟的是网页渲染的整个过程，而真实的数据可能仅仅就藏在一个小接口里。</p>
<p>如果我们能够把一些接口的参数真正找出其中的逻辑，用代码来模拟执行，那效率就会有成倍的提升，而且还能在一定程度上规避上述的反爬现象。</p>
<p>但问题是什么？难啊。</p>
<p>Webpack 是一方面，前端代码都被压缩和转码成一些 bundle 文件，一些变量的含义已经丢失，不好还原。然后一些网站再加上一些 obfuscator 的机制，把前端代码变成你完全看不懂的东西，比如字符串拆散打乱、变量十六进制化、控制流扁平化、无限 debug、控制台禁用等等，前端的代码和逻辑已经面目全非。有的用 WebAssembly 等技术把前端核心逻辑直接编译，那就只能慢慢抠了，虽然说有些有一定的技巧，但是总归来说还是会花费很多时间。但一旦解出来了，那就万事大吉了。怎么说？就像奥赛题一样，解出来升天，解不出来 GG。</p>
<p>很多公司招聘爬虫工程师都会问有没有 JavaScript 逆向基础，破解过哪些网站，比如某宝、某多、某条等等，解出来某个他们需要的可能就直接录用你。每家网站的逻辑都不一样，难度也不一样。</p>
<h2 id="App"><a href="#App" class="headerlink" title="App"></a>App</h2><p>当然爬虫不仅仅是网页爬虫了，随着互联网时代的发展，现在越来越多的公司都选择将数据放到 App 上面，甚至有些公司只有 App 没有网站。所以数据只能通过 App 来爬。</p>
<p>咋爬呢？基本的就是抓包工具了，Charles、Fiddler 一把梭，抓到接口之后，直接拿来模拟就行了。</p>
<p>如果接口有加密参数怎么办呢？一种方法你可以边爬边处理，比如 mitmproxy 直接监听接口数据。另一方面你可以走 Hook，比如上 Xposed 也可以拿到。</p>
<p>那爬的时候又怎么实现自动化呢？总不能拿手来戳吧。其实工具也多，安卓原生的 adb 工具也行，Appium 现在已经是比较主流的方案了，当然还有其他的某精灵都是可以实现的。</p>
<p>最后，有的时候可能真的就不想走自动化的流程，我就想把里面的一些接口逻辑抠出来，那就得搞逆向了，IDA Pro、jdax、FRIDA 等工具就派上用场了，当然这个过程和 JavaScript 逆向一样很痛苦，甚至可能得读汇编指令。搞一个案例掉一把头发也不是不可能的。</p>
<h2 id="智能化"><a href="#智能化" class="headerlink" title="智能化"></a>智能化</h2><p>上面的这一通，都搞熟了，恭喜你已经超过了百分之八九十的爬虫玩家了，当然专门搞 JavaScript 逆向、App 逆向的都是站在食物链顶端的男人，这种严格来说已经不算爬虫范畴了，这种神我们就不算在里面了，反正我不是。</p>
<p>除了上面的一些技能，在一些场合下，我们可能也需要结合一些机器学习的技术，让我们的爬虫变得更智能起来。</p>
<p>比如现在很多博客、新闻文章，其页面结构相似度比较高，要提取的信息也比较类似。</p>
<p>比如如何区分一个页面是索引页还是详情页？如何提取详情页的文章链接？如何解析文章页的页面内容？这些其实都是可以通过一些算法来计算出来的。</p>
<p>所以，一些智能解析技术也营运而生，比如提取详情页，一位朋友写的 GeneralNewsExtractor 表现就非常好。</p>
<p>假如说我来了一个需求，我要爬取一万个新闻网站数据，要一个个写 XPath 吗？写死我吧。如果有了智能化解析技术，在容忍一定错误的条件下，完成这个就是分分钟的事情。</p>
<p>总之，如果我们能把这一块也学会了，我们的爬虫技术就会如虎添翼。</p>
<h2 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h2><p>这块也是一个重头戏。爬虫和运维也是息息相关。</p>
<p>比如写完一个爬虫，怎样去快速部署到 100 台主机上跑起来。</p>
<p>比如怎么灵活地监控每个爬虫的运行状态。</p>
<p>比如爬虫有处代码改动，如何去快速更新。</p>
<p>比如怎样监控一些爬虫的占用内存、消耗的 CPU 状况。</p>
<p>比如怎样科学地控制爬虫的定时运行、</p>
<p>比如爬虫出现了问题，怎样能及时收到通知，怎样设置科学的报警机制。</p>
<p>这里面，部署大家各有各的方法，比如用 Ansible 当然可以。如果用 Scrapy 的话有 Scrapyd，然后配合上一些管理工具也能完成一些监控和定时任务。不过我现在用的更多是还是 Docker + Kubernetes，再加上 DevOps 一套，比如 GitHub Actions、Azure Pipelines、Jenkins 等等，快速实现分发和部署。</p>
<p>定时任务大家有的用 crontab，有的用 apscheduler，有的用管理工具，有的用 Kubernetes，我的话用 Kubernetes 就多一些了，定时任务也是很好实现。</p>
<p>至于监控的话，也有很多，专门的一些爬虫管理工具自带了一些监控和报警功能。一些云服务也带了一些监控的功能。我用的是 Kubernetes + Prometheus + Grafana，什么 CPU、内存、运行状态，一目了然，报警机制在 Grafana 里面配一下也很方便，支持 Webhook、邮件甚至某钉。</p>
<p>数据的存储和监控，用 Kafka、Elasticsearch 个人感觉也挺方便的，我主要用的是后者，然后再和 Grafana 配合起来，数据爬取量、爬取速度等等监控也都一目了然。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>至此，爬虫的一些涵盖的知识点也就差不多了，怎么样，梳理一下，是不是计算机网络、编程基础、前端开发、后端开发、App 开发与逆向、网络安全、数据库、运维、机器学习都涵盖到了？上面总结的可以算是从爬虫小白到爬虫高手的路径了，里面每个方向其实可研究的点非常多，每个点做精了，都会非常了不起。</p>
<p>爬虫往往学着学着，就成为了一名全栈工程师或者全干工程师，因为你可能真的啥都会了。但是没办法啊，都是被爬虫逼的啊，如果不是生活所困，谁愿意一身才华呢？</p>
<p>然而有了才华之后呢？摸摸头顶，卧槽，我的头发呢？</p>
<p>嗯，大家都懂的。</p>
<p>最后最重要的，珍爱生命、珍爱每一根头发。</p>
<hr>
<p>文章转自<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvWF9SNHN2XzNsMHN2djVzN3djNGpHQQ==">https://mp.weixin.qq.com/s/X_R4sv_3l0svv5s7wc4jGA<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>特别声明：如有侵权，告知笔者，立删此文！</strong></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫项目集</title>
    <url>/2020/03/20/6480/</url>
    <content><![CDATA[<p><strong>学习 python，多拿些项目练习练习，因此寻了些爬虫项目，归纳如下：</strong></p>
<a id="more"></a>

<ol>
<li><p><a href="https://github.com/LiuXingMing/QQSpider" target="_blank" rel="noopener"><strong>QQSpider</strong></a>：QQ空间爬虫，包括日志、说说、个人信息等，一天可抓取 400 万条数据。</p>
<hr>
</li>
</ol>
<ol start="2">
<li><p><a href="https://github.com/Chyroc/WechatSogou" target="_blank" rel="noopener"><strong>WechatSogou</strong></a>：微信公众号爬虫。基于搜狗微信搜索的微信公众号爬虫接口，可以扩展成基于搜狗搜索的爬虫，返回结果是列表，每一项均是公众号具体信息字典。</p>
<hr>
</li>
</ol>
<ol start="3">
<li><p><a href="https://github.com/lanbing510/DouBanSpider" target="_blank" rel="noopener"><strong>DouBanSpider</strong></a>：豆瓣读书爬虫。可以爬下豆瓣读书标签下的所有图书，按评分排名依次储存，储存到 Excel 中，可以方便打架筛选搜罗，比如筛选评价人数 &gt; 1000的给分书籍；可依据不同的主题储存到 Excel 不同的 Sheet，采用 User-Agent 伪装为浏览器进行爬取，并加入随机延时来更好的模仿浏览器行为，避免爬虫被封。</p>
<hr>
</li>
</ol>
<ol start="4">
<li><p><a href="https://github.com/LiuRoy/zhihu_spider" target="_blank" rel="noopener"><strong>ZhiHuSpider</strong></a>：知乎爬虫。此项目的功能是爬取知乎用户信息以及人际拓扑关系，爬虫框架使用 Scrapy，数据储存使用 Mongo。</p>
<hr>
</li>
</ol>
<ol start="5">
<li><p><a href="https://github.com/airingursb/bilibili-user" target="_blank" rel="noopener"><strong>Bilibili-User</strong></a>：Bilibili 用户爬虫。总数据数：20119918，抓取字段：用户 id、昵称、性别、头像、等级、经验值、粉丝数、生日、地址、注册时间、签名、等级与经验值等。抓取后生成B站用户数据报告。</p>
<hr>
</li>
</ol>
<ol start="6">
<li><p><a href="https://github.com/LiuXingMing/SinaSpider" target="_blank" rel="noopener"><strong>SinaSpider</strong></a>：新浪微博爬虫，主要爬取新浪微博用户的个人信息、微博关注、粉丝和关注。代码获取新浪微博 Cookie 进行登陆，可以通过多账号登陆来防止新浪的返爬。主要使用 Scrapy 爬虫框架。</p>
<hr>
</li>
</ol>
<ol start="7">
<li><p><a href="https://github.com/gnemoug/distribute_crawler" target="_blank" rel="noopener"><strong>distribute_crawler</strong></a>：小说下载分布式爬虫。使用 Scrapy，Redis，MongoDB，graphite 实现的一个分布式网络爬虫，底层储存 MongoDB 集群，分布式使用 Redis 实现，爬虫状态显示使用 graphite 实现，主要正对一个小说站点。</p>
<hr>
</li>
</ol>
<ol start="8">
<li><p><a href="https://github.com/yanzhou/CnkiSpider" target="_blank" rel="noopener"><strong>CnkiSpider</strong></a>：中国知网爬虫。设置检索条件后，执行src/CnkiSpider.py抓取数据，抓取数据存储在/data目录下，每个数据文件的第一行为字段名称。</p>
<hr>
</li>
</ol>
<ol start="9">
<li><p><a href="https://github.com/lanbing510/LianJiaSpider" target="_blank" rel="noopener"><strong>LianJiaSpider</strong></a>：链家网爬虫。爬取北京地区链家历年二手房成交记录。涵盖链家爬虫一文的全部代码，包括链家模拟登录代码。</p>
<hr>
</li>
</ol>
<ol start="10">
<li><p><a href="https://github.com/taizilongxu/scrapy_jingdong" target="_blank" rel="noopener"><strong>scrapy_jingdong</strong></a>：京东爬虫。基于scrapy的京东网站爬虫，保存格式为csv。</p>
<hr>
</li>
</ol>
<ol start="11">
<li><p><a href="https://github.com/caspartse/QQ-Groups-Spider" target="_blank" rel="noopener"><strong>QQ-Groups-Spider</strong></a>：QQ 群爬虫。批量抓取 QQ 群信息，包括群名称、群号、群人数、群主、群简介等内容，最终生成 XLS(X) / CSV 结果文件。</p>
<hr>
</li>
</ol>
<ol start="12">
<li><p><a href="https://github.com/hanc00l/wooyun_public" target="_blank" rel="noopener"><strong>wooyun_public</strong></a>：乌云爬虫。乌云公开漏洞、知识库爬虫和搜索。全部公开漏洞的列表和每个漏洞的文本内容存在MongoDB中，大概约2G内容；如果整站爬全部文本和图片作为离线查询，大概需要10G空间、2小时（10M电信带宽）；爬取全部知识库，总共约500M空间。漏洞搜索使用了Flask作为web server，bootstrap作为前端。</p>
<hr>
</li>
</ol>
<ol start="13">
<li><p><a href="https://github.com/simapple/spider" target="_blank" rel="noopener"><strong>spider</strong></a>：hao123网站爬虫。以hao123为入口页面，滚动爬取外链，收集网址，并记录网址上的内链和外链数目，记录title等信息，windows7 32位上测试，目前每24个小时，可收集数据为10万左右。</p>
<hr>
</li>
</ol>
<ol start="14">
<li><p><a href="https://github.com/fankcoder/findtrip" target="_blank" rel="noopener"><strong>findtrip</strong></a>：机票爬虫（去哪儿和携程网）。Findtrip是一个基于Scrapy的机票爬虫，目前整合了国内两大机票网站（去哪儿 + 携程）。</p>
<hr>
</li>
</ol>
<ol start="15">
<li><p><a href="https://github.com/leyle/163spider" target="_blank" rel="noopener"><strong>163spider</strong></a>：基于requests、MySQLdb、torndb的网易客户端内容爬虫。</p>
<hr>
</li>
</ol>
<ol start="16">
<li><p><a href="https://github.com/fanpei91/doubanspiders" target="_blank" rel="noopener"><strong>doubanspiders</strong></a>：豆瓣电影、书籍、小组、相册、东西等爬虫集。</p>
<hr>
</li>
</ol>
<ol start="17">
<li><p><a href="https://github.com/Shu-Ji/baidu-music-spider" target="_blank" rel="noopener"><strong>baidu-music-spider</strong></a>：百度mp3全站爬虫，使用redis支持断点续传。</p>
<hr>
</li>
</ol>
<ol start="18">
<li><p><a href="https://github.com/pakoo/tbcrawler" target="_blank" rel="noopener"><strong>tbcrawler</strong></a>：淘宝和天猫的爬虫,可以根据搜索关键词,物品id来抓去页面的信息，数据存储在MongoDB。</p>
<hr>
</li>
</ol>
<ol start="19">
<li><p><a href="https://github.com/benitoro/stockholm" target="_blank" rel="noopener"><strong>stockholm</strong></a>：一个股票数据（沪深）爬虫和选股策略测试框架。根据选定的日期范围抓取所有沪深两市股票的行情数据。支持使用表达式定义选股策略。支持多线程处理。保存数据到JSON文件、CSV文件。</p>
<hr>
</li>
</ol>
<ol start="20">
<li><p><a href="https://github.com/k1995/BaiduyunSpider" target="_blank" rel="noopener"><strong>BaiduyunSpider</strong></a>：百度云盘爬虫。分布式百度网盘爬虫，使用当前最流行的技术框架。适合个人学习以及二次开发。爬虫基于 <code>Scrapy</code>，灵活简单、易扩展，方便二次开发。使用 <code>Scrapy-Redis</code> 作为分布式中间件，可同时部署多个爬虫实例，以提升采集效率。<code>Web</code>后台管理基于<code>React</code>，<code>Material Design</code> 设计风格。</p>
<hr>
</li>
</ol>
<ol start="21">
<li><p><a href="https://github.com/Qutan/Spider" target="_blank" rel="noopener"><strong>Spider</strong></a>：社交数据爬虫。支持微博，知乎，豆瓣。</p>
<hr>
</li>
</ol>
<ol start="22">
<li><p><a href="https://github.com/jhao104/proxy_pool" target="_blank" rel="noopener"><strong>proxy pool</strong></a>：Python爬虫代理IP池(proxy pool)。</p>
<hr>
</li>
</ol>
<ol start="23">
<li><p><a href="https://github.com/RitterHou/music-163" target="_blank" rel="noopener"><strong>music-163</strong></a>：爬取网易云音乐所有歌曲的评论。</p>
<hr>
</li>
</ol>
<ol start="24">
<li><p><a href="https://github.com/kulovecc/jandan_spider" target="_blank" rel="noopener"><strong>jandan_spider</strong></a>：爬取煎蛋妹纸图片。</p>
<hr>
</li>
</ol>
<ol start="25">
<li><p><a href="https://github.com/jackgitgz/CnblogsSpider" target="_blank" rel="noopener"><strong>CnblogsSpider</strong></a>：Cnblogs列表页爬虫。</p>
<hr>
</li>
</ol>
<ol start="26">
<li><p><a href="https://github.com/qiyeboy/spider_smooc" target="_blank" rel="noopener"><strong>spider_smooc</strong></a>：爬取慕课网视频。</p>
<hr>
</li>
</ol>
<ol start="27">
<li><p><a href="https://github.com/yanzhou/CnkiSpider" target="_blank" rel="noopener"><strong>CnkiSpider</strong></a>：中国知网爬虫。</p>
<hr>
</li>
</ol>
<ol start="28">
<li><p><a href="https://github.com/littlethunder/knowsecSpider2" target="_blank" rel="noopener"><strong>knowsecSpider2</strong></a>：知道创宇爬虫题目。</p>
<hr>
</li>
</ol>
<ol start="29">
<li><p><a href="https://github.com/x-spiders/aiss-spider" target="_blank" rel="noopener"><strong>aiss-spider</strong></a>：爱丝APP图片爬虫。</p>
<hr>
</li>
</ol>
<ol start="30">
<li><p><a href="https://github.com/szcf-weiya/SinaSpider" target="_blank" rel="noopener"><strong>SinaSpider</strong></a>：动态IP解决新浪的反爬虫机制，快速抓取内容。</p>
<hr>
</li>
</ol>
<ol start="31">
<li><p><a href="https://github.com/Kevinsss/csdn-spider" target="_blank" rel="noopener"><strong>csdn-spider</strong></a>：爬取CSDN上的博客文章。</p>
<hr>
</li>
</ol>
<ol start="32">
<li><p><a href="https://github.com/changetjut/ProxySpider" target="_blank" rel="noopener"><strong>ProxySpider</strong></a>：爬取西刺上的代理IP，并验证代理可用性。</p>
<hr>
</li>
</ol>
<ol start="33">
<li><p><a href="https://github.com/Python3WebSpider/ProxyPool" target="_blank" rel="noopener"><strong>ProxyPool</strong></a>：简易高效的代理池，提供如下功能：</p>
<ol>
<li><p>定时抓取免费代理网站，简易可扩展。</p>
</li>
<li><p>使用 Redis 对代理进行存储并对代理可用性进行排序。</p>
</li>
<li><p>定时测试和筛选，剔除不可用代理，留下可用代理。</p>
</li>
<li><p>提供代理 API，随机取用测试通过的可用代理。</p>
<p>代理池原理解析可见「<span class="exturl" data-url="aHR0cHM6Ly9jdWlxaW5nY2FpLmNvbS83MDQ4Lmh0bWw=">如何搭建一个高效的代理池<i class="fa fa-external-link-alt"></i></span>」，建议使用之前阅读。</p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>项目</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Kivy参考文档（三）</title>
    <url>/2020/03/03/20561/</url>
    <content><![CDATA[<h1 id="第二部分-编程指南"><a href="#第二部分-编程指南" class="headerlink" title="第二部分 编程指南"></a>第二部分 编程指南</h1><h2 id="与其他框架集成"><a href="#与其他框架集成" class="headerlink" title="与其他框架集成"></a>与其他框架集成</h2><p>1.0.8版中的新功能。</p>
<a id="more"></a>

<h3 id="在Kivy中使用Twisted"><a href="#在Kivy中使用Twisted" class="headerlink" title="在Kivy中使用Twisted"></a>在Kivy中使用Twisted</h3><hr>
<p><strong>注意：您可以使用kivy.support.install_twisted_reactor函数安装将在kivy事件循环内运行的扭曲反应堆。</strong></p>
<p><strong>传递给该函数的所有参数或关键字参数都将在threadedselect反应堆交错函数上传递。 这些通常是扭曲式反应堆的论据。 startRunning</strong></p>
<hr>
<p><strong>警告：与默认的双绞线电抗器不同，已安装的电抗器将不会处理任何信号，除非您将“ installSignalHandlers”关键字参数明确设置为1。 这样做是为了使kivy能够照常处理信号，除非您特别希望扭曲电抗器处理信号（例如SIGINT）。</strong></p>
<hr>
<ul>
<li><span class="exturl" data-url="aHR0cDovL3R3aXN0ZWRtYXRyaXguY29tL2RvY3VtZW50cy9jdXJyZW50L19kb3dubG9hZHMvc2ltcGxlc2Vydi5weQ==">http://twistedmatrix.com/documents/current/_downloads/simpleserv.py<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3R3aXN0ZWRtYXRyaXguY29tL2RvY3VtZW50cy9jdXJyZW50L19kb3dubG9hZHMvc2ltcGxlY2xpZW50LnB5">http://twistedmatrix.com/documents/current/_downloads/simpleclient.py<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>要尝试该示例，请首先运行echo_server_app.py，然后启动echo_client_app.py。 在文本框中输入内容后，当您按Enter键时，服务器将以简单的回显消息答复客户端应用发送的任何内容。</p>
<h4 id="服务器应用"><a href="#服务器应用" class="headerlink" title="服务器应用"></a>服务器应用</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># install_twisted_rector must be called before importing and using the reactor</span></span><br><span class="line"><span class="keyword">from</span> kivy.support <span class="keyword">import</span> install_twisted_reactor</span><br><span class="line"></span><br><span class="line">install_twisted_reactor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> twisted.internet <span class="keyword">import</span> reactor</span><br><span class="line"><span class="keyword">from</span> twisted.internet <span class="keyword">import</span> protocol</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span><span class="params">(protocol.Protocol)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dataReceived</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        response = self.factory.app.handle_message(data)</span><br><span class="line">        <span class="keyword">if</span> response:</span><br><span class="line">            self.transport.write(response)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoServerFactory</span><span class="params">(protocol.Factory)</span>:</span></span><br><span class="line">    protocol = EchoServer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, app)</span>:</span></span><br><span class="line">        self.app = app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> kivy.app <span class="keyword">import</span> App</span><br><span class="line"><span class="keyword">from</span> kivy.uix.label <span class="keyword">import</span> Label</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwistedServerApp</span><span class="params">(App)</span>:</span></span><br><span class="line">    label = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.label = Label(text=<span class="string">"server started\n"</span>)</span><br><span class="line">        reactor.listenTCP(<span class="number">8000</span>, EchoServerFactory(self))</span><br><span class="line">        <span class="keyword">return</span> self.label</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_message</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        msg = msg.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">        self.label.text = <span class="string">"received: &#123;&#125;\n"</span>.format(msg)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> msg == <span class="string">"ping"</span>:</span><br><span class="line">            msg = <span class="string">"Pong"</span></span><br><span class="line">        <span class="keyword">if</span> msg == <span class="string">"plop"</span>:</span><br><span class="line">            msg = <span class="string">"Kivy Rocks!!!"</span></span><br><span class="line">        self.label.text += <span class="string">"responded: &#123;&#125;\n"</span>.format(msg)</span><br><span class="line">        <span class="keyword">return</span> msg.encode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    TwistedServerApp().run()</span><br></pre></td></tr></table></figure>

<h4 id="客户应用"><a href="#客户应用" class="headerlink" title="客户应用"></a>客户应用</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># install_twisted_rector must be called before importing the reactor</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> unicode_literals</span><br><span class="line"><span class="keyword">from</span> kivy.support <span class="keyword">import</span> install_twisted_reactor</span><br><span class="line"></span><br><span class="line">install_twisted_reactor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># A Simple Client that send messages to the Echo Server</span></span><br><span class="line"><span class="keyword">from</span> twisted.internet <span class="keyword">import</span> reactor, protocol</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span><span class="params">(protocol.Protocol)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connectionMade</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.factory.app.on_connection(self.transport)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dataReceived</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        self.factory.app.print_message(data.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoClientFactory</span><span class="params">(protocol.ClientFactory)</span>:</span></span><br><span class="line">    protocol = EchoClient</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, app)</span>:</span></span><br><span class="line">        self.app = app</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startedConnecting</span><span class="params">(self, connector)</span>:</span></span><br><span class="line">        self.app.print_message(<span class="string">'Started to connect.'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clientConnectionLost</span><span class="params">(self, connector, reason)</span>:</span></span><br><span class="line">        self.app.print_message(<span class="string">'Lost connection.'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clientConnectionFailed</span><span class="params">(self, connector, reason)</span>:</span></span><br><span class="line">        self.app.print_message(<span class="string">'Connection failed.'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> kivy.app <span class="keyword">import</span> App</span><br><span class="line"><span class="keyword">from</span> kivy.uix.label <span class="keyword">import</span> Label</span><br><span class="line"><span class="keyword">from</span> kivy.uix.textinput <span class="keyword">import</span> TextInput</span><br><span class="line"><span class="keyword">from</span> kivy.uix.boxlayout <span class="keyword">import</span> BoxLayout</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># A simple kivy App, with a textbox to enter messages, and</span></span><br><span class="line"><span class="comment"># a large label to display all the messages received from</span></span><br><span class="line"><span class="comment"># the server</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwistedClientApp</span><span class="params">(App)</span>:</span></span><br><span class="line">    connection = <span class="literal">None</span></span><br><span class="line">    textbox = <span class="literal">None</span></span><br><span class="line">    label = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(self)</span>:</span></span><br><span class="line">        root = self.setup_gui()</span><br><span class="line">        self.connect_to_server()</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup_gui</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.textbox = TextInput(size_hint_y=<span class="number">.1</span>, multiline=<span class="literal">False</span>)</span><br><span class="line">        self.textbox.bind(on_text_validate=self.send_message)</span><br><span class="line">        self.label = Label(text=<span class="string">'connecting...\n'</span>)</span><br><span class="line">        layout = BoxLayout(orientation=<span class="string">'vertical'</span>)</span><br><span class="line">        layout.add_widget(self.label)</span><br><span class="line">        layout.add_widget(self.textbox)</span><br><span class="line">        <span class="keyword">return</span> layout</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect_to_server</span><span class="params">(self)</span>:</span></span><br><span class="line">        reactor.connectTCP(<span class="string">'localhost'</span>, <span class="number">8000</span>, EchoClientFactory(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_connection</span><span class="params">(self, connection)</span>:</span></span><br><span class="line">        self.print_message(<span class="string">"Connected successfully!"</span>)</span><br><span class="line">        self.connection = connection</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_message</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">        msg = self.textbox.text</span><br><span class="line">        <span class="keyword">if</span> msg <span class="keyword">and</span> self.connection:</span><br><span class="line">            self.connection.write(msg.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">            self.textbox.text = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_message</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        self.label.text += <span class="string">"&#123;&#125;\n"</span>.format(msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    TwistedClientApp().run()</span><br></pre></td></tr></table></figure>

<h2 id="打包您的应用程序"><a href="#打包您的应用程序" class="headerlink" title="打包您的应用程序"></a>打包您的应用程序</h2><h3 id="为Windows创建一个程序包"><a href="#为Windows创建一个程序包" class="headerlink" title="为Windows创建一个程序包"></a>为Windows创建一个程序包</h3><hr>
<p><strong>注意：本文档仅适用于kivy 1.9.1及更高版本。</strong></p>
<hr>
<p>为Windows平台打包应用程序只能在Windows OS内完成。 以下过程已在装有Kivy轮的Windows上进行了测试，有关替代安装，请参见最后。</p>
<p>软件包将是32位还是64位，具体取决于您使用哪个版本的Python。</p>
<h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><ul>
<li>最新的Kivy（如Installation_windows中所述安装）.</li>
<li>PyInstaller 3.1+（pip install –upgrade pyinstaller）.</li>
</ul>
<h3 id="PyInstaller默认钩子"><a href="#PyInstaller默认钩子" class="headerlink" title="PyInstaller默认钩子"></a>PyInstaller默认钩子</h3><p>本节适用于包含kivy钩子的PyInstaller（&gt; = 3.1）。 要覆盖默认钩子，需要对以下示例进行一些修改。 请参阅覆盖默认挂钩。</p>
<h4 id="打包一个简单的应用程序"><a href="#打包一个简单的应用程序" class="headerlink" title="打包一个简单的应用程序"></a>打包一个简单的应用程序</h4><p>在此示例中，我们将打包touchtracer示例项目并嵌入自定义图标。 kivy示例的位置是，当使用轮子时，安装到python \ share \ kivy-examples上，以及将github源代码安装为kivy \ examples时。 我们仅将通向示例的完整路径称为examples-path。 touchtracer示例位于examples-path \ demo \ touchtracer中，主文件名为main.py。</p>
<p>1.打开命令行外壳，并确保python在路径上（即python可以工作）。</p>
<p>2.创建一个文件夹，将在其中创建打包的应用程序。 例如，创建一个TouchApp文件夹，然后使用更改为该目录。 <code>cd TouchApp</code>。 然后输入：</p>
<p><code>python -m PyInstaller --name touchtracer examples-path\demo\touchtracer\main.py</code></p>
<p>您也可以将icon.ico文件添加到应用程序文件夹中，以便为可执行文件创建图标。 如果没有.ico文件，则可以使用网络应用程序ConvertICO将icon.png文件转换为ico。 将icon.ico保存在touchtracer目录中，然后键入：</p>
<p><code>python -m PyInstaller --name touchtracer --icon examples-path\demo\touchtracer\icon.ico examples-path\demo\touchtracer\main.py</code></p>
<p>有关更多选项，请查阅PyInstaller手册。</p>
<p>3.规格文件将是TouchApp中的touchtracer.spec。 现在，我们需要编辑spec文件以添加依赖项挂钩以正确构建exe。 使用您喜欢的编辑器打开规范文件，并在规范的开头添加以下几行（假设使用了sdl2，现在是默认设置）：</p>
<p><code>from kivy_deps import sdl2, glew</code></p>
<p>然后，找到COLLECT（）并添加touchtracer的数据（touchtracer.kv，Particle.png，…）：更改该行以添加Tree（）对象，例如 树（’examples-path \ demo \ touchtracer \‘）。 该树将搜索并将在touchtracer目录中找到的每个文件添加到最终包中。</p>
<p>要添加依赖关系，请在COLLECT中的第一个关键字参数之前为依赖关系的每个路径添加一个Tree对象。 例如。 * [[（sdl2.dep_bins + glew。dep_bins）中p的树（p）]看起来像这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">coll = COLLECT(exe, Tree(<span class="string">'examples-path\\demo\\touchtracer\\'</span>),</span><br><span class="line">                a.binaries,</span><br><span class="line">                a.zipfiles,</span><br><span class="line">                a.datas,</span><br><span class="line">                *[Tree(p) <span class="keyword">for</span> p <span class="keyword">in</span> (sdl2.dep_bins + glew.dep_bins)],</span><br><span class="line">                strip=<span class="literal">False</span>,</span><br><span class="line">                upx=<span class="literal">True</span>,</span><br><span class="line">                name=<span class="string">'touchtracer'</span>)</span><br></pre></td></tr></table></figure>
<p>4.现在，我们使用以下命令在TouchApp中构建规范文件：</p>
<p><code>python -m PyInstaller touchtracer.spec</code></p>
<p>5.编译后的软件包将位于<code>TouchApp\dist\touchtracer</code>目录中。</p>
<h4 id="使用gstreamer打包视频应用"><a href="#使用gstreamer打包视频应用" class="headerlink" title="使用gstreamer打包视频应用"></a>使用gstreamer打包视频应用</h4><p>接下来，我们将略微修改上面的示例，以打包将gstreamer用于视频的应用。 我们将使用在<code>examples-path\widgets\videoplayer.py</code>中找到的视频播放器示例。 在名为VideoPlayer的位置创建一个文件夹，然后在命令行上将当前目录更改为该文件夹并执行以下操作：</p>
<p><code>python -m PyInstaller --name gstvideo examples-path\widgets\videoplayer.py</code></p>
<p>创建gstvideo.spec文件。 如上编辑，这次也包括gstreamer依赖项：</p>
<p><code>from kivy_deps import sdl2, glew, gstreamer</code></p>
<p>并添加Tree（）以包括视频文件，例如 Tree（’examples-path \ widgets’）以及gstreamer依赖项，因此它应类似于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">coll = COLLECT(exe, Tree(<span class="string">'examples-path\\widgets'</span>),</span><br><span class="line">                a.binaries,</span><br><span class="line">                a.zipfiles,</span><br><span class="line">                a.datas,</span><br><span class="line">                *[Tree(p) <span class="keyword">for</span> p <span class="keyword">in</span> (sdl2.dep_bins + glew.dep_bins + gstreamer.dep_bins)],</span><br><span class="line">                strip=<span class="literal">False</span>,</span><br><span class="line">                upx=<span class="literal">True</span>,</span><br><span class="line">                name=<span class="string">'gstvideo'</span>)</span><br></pre></td></tr></table></figure>
<p>然后使用以下方法在VideoPlayer中构建规格文件：</p>
<p><code>python -m PyInstaller gstvideo.spec</code></p>
<p>并且您应该在<code>VideoPlayer\dist\gstvideo</code>中找到gstvideo.exe，该文件在运行时将播放视频。</p>
<hr>
<p><strong>注意：如果您使用的是Pygame，并且在打包应用中需要PyGame，则由于kivy问题＃1638，您必须在规范文件中添加以下代码。 导入后，添加以下内容：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getResource</span><span class="params">(identifier, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> identifier == <span class="string">'pygame_icon.tiff'</span>:</span><br><span class="line">        <span class="keyword">raise</span> IOError()</span><br><span class="line">    <span class="keyword">return</span> _original_getResource(identifier, *args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pygame.pkgdata</span><br><span class="line">_original_getResource = pygame.pkgdata.getResource</span><br><span class="line">pygame.pkgdata.getResource = getResource</span><br></pre></td></tr></table></figure>

<h3 id="覆盖默认钩子"><a href="#覆盖默认钩子" class="headerlink" title="覆盖默认钩子"></a>覆盖默认钩子</h3><h4 id="包含-排除视频和音频并减小应用程序大小"><a href="#包含-排除视频和音频并减小应用程序大小" class="headerlink" title="包含/排除视频和音频并减小应用程序大小"></a>包含/排除视频和音频并减小应用程序大小</h4><p>PyInstaller包含一个用于kivy的钩子，默认情况下会添加kivy使用的所有核心模块，例如音频，视频，拼写等（您仍然需要使用<code>Tree()</code>手动打包gstreamer dll-参见上面的示例）及其依赖项。如果未安装挂钩或为了减小应用程序大小，则可能不包括其中某些模块，例如如果未使用音频/视频，请使用备用挂钩。</p>
<p>Kivy在<code>hookspath()</code>中提供了备用钩子。此外，当且仅当PyInstaller没有默认钩子时，还必须提供<code>runtime_hooks()</code>。当覆盖钩子时，通常不需要覆盖后者。</p>
<p>备用<code>hookspath()</code>挂钩不包含任何kivy提供程序。要添加它们，必须将它们与<code>get_deps_minimal()</code>或<code>get_deps_all()</code>添加在一起。请参阅他们的文档和pyinstaller_hooks以获取更多详细信息。但从本质上讲，<code>get_deps_all()</code>会像默认钩子一样添加所有提供程序，而<code>get_deps_minimal()</code>仅添加在运行应用程序时加载的提供程序。每种方法都提供了可传递给Analysis的隐藏的kivy导入列表和排除的导入列表。</p>
<p>一个人也可以生成一个备用钩子，该钩子从字面上列出每个kivy提供程序模块，不需要的那些可以注释掉。 请参阅pyinstaller_hooks。</p>
<p>要在上面的示例中使用备用挂钩，请进行以下修改，以添加带有<code>hookspath()</code>和<code>runtime_hooks（如果需要）</code>以及<code>**get_deps_minimal()</code>或<code>**get_deps_all()</code>的挂钩，以指定提供程序。</p>
<p>例如，添加导入语句：</p>
<p><code>from kivy.tools.packaging.pyinstaller_hooks import get_deps_minimal, get_deps_all,hookspath, runtime_hooks</code></p>
<p>然后修改分析如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = Analysis([<span class="string">'examples-path\\demo\\touchtracer\\main.py'</span>],</span><br><span class="line">            ...</span><br><span class="line">            hookspath=hookspath(),</span><br><span class="line">            runtime_hooks=runtime_hooks(),</span><br><span class="line">            ...</span><br><span class="line">            **get_deps_all())</span><br></pre></td></tr></table></figure>
<p>包括默认钩子之类的所有内容。 要么：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = Analysis([<span class="string">'examples-path\\demo\\touchtracer\\main.py'</span>],</span><br><span class="line">            ...</span><br><span class="line">            hookspath=hookspath(),</span><br><span class="line">            runtime_hooks=runtime_hooks(),</span><br><span class="line">            ...</span><br><span class="line">            **get_deps_minimal(video=<span class="literal">None</span>, audio=<span class="literal">None</span>))</span><br></pre></td></tr></table></figure>
<p>例如 排除音频和视频提供程序，而对于其他核心模块，仅使用加载的那些。</p>
<p>关键是要提供备用的<code>hookspath()</code>，默认情况下不会列出所有kivy提供程序，而是手动对隐藏的导入添加所需的提供程序，同时使用<code>get_deps_minimal()</code>删除不需要的提供程序（在此示例中为音频和视频）。</p>
<h4 id="备用安装"><a href="#备用安装" class="headerlink" title="备用安装"></a>备用安装</h4><p>先前的例子使用例如 * [[（sdl2.dep_bins + glew.dep_bins + gstreamer.dep_bins）中p的树（p）]，使PyInstaller添加这些依赖项使用的所有dll。 如果未使用wheel方法安装kivy，则这些命令将不起作用，例如 kivy_deps.sdl2将无法导入。 相反，必须找到这些dll的位置，并以与示例类似的方式将它们手动传递给Tree类。</p>
<h3 id="为Android创建一个程序包"><a href="#为Android创建一个程序包" class="headerlink" title="为Android创建一个程序包"></a>为Android创建一个程序包</h3><p>您可以使用python-for-android项目为android创建软件包。 本页说明如何直接在您自己的计算机上下载和使用它（请参阅使用python-for-android打包）或使用Buildozer工具来自动化整个过程。 您还可以看到打包应用程序以供Kivy Launcher使用，以在不进行编译的情况下运行kivy程序。</p>
<p>对于新用户，我们建议使用Buildozer作为制作完整APK的最简单方法。 您也可以使用Kivy Launcher应用程序运行Kivy应用程序，而无需进行编译步骤。</p>
<p>Kivy应用程序可以在Play商店等Android市场上发布，只需执行一些额外步骤即可创建完全签名的APK。</p>
<p>Kivy项目包含用于访问Android API的工具，以完成振动，传感器访问，发短信等功能。这些信息以及有关设备调试的信息记录在Android主页上。</p>
<h4 id="Buildozer"><a href="#Buildozer" class="headerlink" title="Buildozer"></a>Buildozer</h4><p>Buildozer是使整个构建过程自动化的工具。 它会下载并设置python-for-android的所有必备组件，包括android SDK和NDK，然后构建一个可自动推送到设备的apk。</p>
<p>Buildozer当前仅在Linux中工作，并且是Alpha版本，但它已经可以很好地工作并且可以大大简化apk的构建。</p>
<p>您可以在<code>https://github.com/kivy/buildozer</code>上获得buildozer：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/kivy/buildozer.git</span><br><span class="line">cd buildozer</span><br><span class="line">sudo python setup.py install</span><br></pre></td></tr></table></figure>
<p>这将在您的系统中安装buildozer。 然后，导航到您的项目目录并运行：</p>
<p><code>buildozer init</code></p>
<p>这将创建一个控制构建配置的buildozer.spec文件。 您应该使用您的应用名称等对其进行适当的编辑。您可以设置变量以控制传递给python-for-android的大多数或所有参数。</p>
<p>安装buildozer的<span class="exturl" data-url="aHR0cHM6Ly9idWlsZG96ZXIucmVhZHRoZWRvY3MuaW8vZW4vbGF0ZXN0L2luc3RhbGxhdGlvbi5odG1sI3RhcmdldGluZy1hbmRyb2lk">依赖项<i class="fa fa-external-link-alt"></i></span>。</p>
<p>最后，插入您的android设备并运行：</p>
<p><code>buildozer android debug deploy run</code></p>
<p>在设备上构建，推送和自动运行apk。</p>
<p>Buildozer有许多可用的选项和工具可以为您提供帮助，以上步骤只是构建和运行APK的最简单方法。 完整文档可在<span class="exturl" data-url="aHR0cDovL2J1aWxkb3plci5yZWFkdGhlZG9jcy5vcmcvZW4vbGF0ZXN0Lw==">此处<i class="fa fa-external-link-alt"></i></span>获得。 您也可以在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tpdnkvYnVpbGRvemVy5LiK5p+l55yLQnVpbGRvemVy6Ieq6L+w5paH5Lu244CC">https://github.com/kivy/buildozer上查看Buildozer自述文件。<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="用python-for-android打包"><a href="#用python-for-android打包" class="headerlink" title="用python-for-android打包"></a>用python-for-android打包</h4><p>您还可以直接使用python-for-android进行打包，这可以为您提供更多控制权，但需要您手动下载Android工具链的各个部分。</p>
<p>有关完整的详细信息，请参见<span class="exturl" data-url="aHR0cHM6Ly9weXRob24tZm9yLWFuZHJvaWQucmVhZHRoZWRvY3MuaW8vZW4vbGF0ZXN0L3F1aWNrc3RhcnQv">python-for-android文档<i class="fa fa-external-link-alt"></i></span>。</p>
<h4 id="打包您的Kivy-Launcher应用程序"><a href="#打包您的Kivy-Launcher应用程序" class="headerlink" title="打包您的Kivy Launcher应用程序"></a>打包您的Kivy Launcher应用程序</h4><p>Kivy启动器是一个Android应用程序，可运行存储在SD卡上的所有Kivy示例。 要安装Kivy启动器，您必须：</p>
<p>1.前往Google Play商店的Kivy Launcher页面</p>
<p>2.点击安装</p>
<p>3.选择您的手机。 。 。 完成了！</p>
<p>如果您无法通过手机/平板电脑访问Google Play商店，则可以从<span class="exturl" data-url="aHR0cDovL2tpdnkub3JnLyNkb3dubG9hZOaJi+WKqOS4i+i9veW5tuWuieijhUFQS+OAgg==">http://kivy.org/#download手动下载并安装APK。<i class="fa fa-external-link-alt"></i></span></p>
<p>一旦安装了Kivy启动器，您就可以将Kivy应用程序放在外部存储目录的Kivy目录中（即使在内部存储器中的设备中，通常也可以在/ sdcard上找到）。</p>
<p><code>/sdcard/kivy/&lt;yourapplication&gt;</code></p>
<p><yourapplication>应该是包含以下内容的目录：</yourapplication></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Your main application file:</span></span><br><span class="line">main.py</span><br><span class="line"><span class="comment"># Some info Kivy requires about your app on android:</span></span><br><span class="line">android.txt</span><br></pre></td></tr></table></figure>
<p>android.txt文件必须包含：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">title=&lt;Application Title&gt;</span><br><span class="line">author=&lt;Your Name&gt;</span><br><span class="line">orientation=&lt;portrait|landscape&gt;</span><br></pre></td></tr></table></figure>
<p>这些选项只是一个非常基本的配置。 如果使用上述工具创建自己的APK，则可以选择许多其他设置。</p>
<p>安装示例</p>
<p>Kivy附带了许多示例，这些示例可能是开始尝试Kivy启动器的好地方。 您可以如下运行它们：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#. Download the `Kivy demos for Android &lt;https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/kivy/kivydemo-for-android.zip&gt;`_</span></span><br><span class="line"><span class="comment">#. Unzip the contents and go to the folder `kivydemo-for-android`</span></span><br><span class="line"><span class="comment">#. Copy all the the subfolders here to</span></span><br></pre></td></tr></table></figure>
<p>/sdcard/kivy</p>
<p>1.运行启动器，然后选择“图片”，“展示”，“ Touchtracer”，“ Cymunk”或其他演示之一。</p>
<h4 id="投放市场"><a href="#投放市场" class="headerlink" title="投放市场"></a>投放市场</h4><p>如果您使用Buildozer或python-for-android构建了自己的APK，则可以创建一个发行版本，该发行版本可能会在Play商店或其他Android市场上发行。 为此，您必须使用release参数（例如，buildozer android release）运行Buildozer，或者如果使用python-for-android，请使用–release选项来build.py。 这会创建一个发布</p>
<p>bin目录中的APK，您必须正确对其进行签名和zipalign。 Android文档（<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vc3R1ZGlvL3B1Ymxpc2gvYXBw">https://developer.android.com/studio/publish/app<i class="fa fa-external-link-alt"></i></span> signing.html＃signing-manually）中描述了执行此操作的步骤-所有必需的工具都随Android SDK一起提供。</p>
<h4 id="定位Android"><a href="#定位Android" class="headerlink" title="定位Android"></a>定位Android</h4><p>Kivy旨在跨平台相同地运行，因此做出了一些明确的设计决策。 它包括自己的一组小部件，默认情况下，它会构建具有所有必需的核心依赖关系和库的APK。</p>
<p>可以直接或以（某种）跨平台方式定位特定的Android功能。 有关更多详细信息，请参见《 Android上的Kivy》的“使用Android API”部分。</p>
<h3 id="Kivy-on-Android"><a href="#Kivy-on-Android" class="headerlink" title="Kivy on Android"></a>Kivy on Android</h3><p>您可以在（或多或少）具有OpenGL ES 2.0（最低Android 2.2）的任何设备上的Android上运行Kivy应用程序。 这是现代设备的标准配置。 Google报告说<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYW5kcm9pZC5jb20vYWJvdXQvZGFzaGJvYXJkcy9pbmRleC5odG1s">99.9％的设备<i class="fa fa-external-link-alt"></i></span>可以满足要求。</p>
<p>Kivy APK是普通的Android应用，您可以像分发其他应用一样分发，包括在Play商店等商店中。 它们在暂停或重新启动时行为正常，可以使用Android服务，并可以访问大多数常规Java API，如下所述。</p>
<p>请按照以下说明学习如何为Android打包您的应用，如何在设备上调试代码以及如何使用Android API（例如振动和读取传感器）。</p>
<h4 id="Android套件"><a href="#Android套件" class="headerlink" title="Android套件"></a>Android套件</h4><p>Kivy项目提供了在Android上打包您的应用程序所需的所有必要工具，包括构建自己的独立APK，该APK可在Play商店等市场上分发。 “创建Android包”文档中对此进行了全面介绍。</p>
<h4 id="在Android平台上调试应用程序"><a href="#在Android平台上调试应用程序" class="headerlink" title="在Android平台上调试应用程序"></a>在Android平台上调试应用程序</h4><p>您可以通过Android logcat流查看代码的常规输出（stdout，stderr）以及常规的Kivy日志。 可通过Android SDK提供的adb访问此文件。 您可能需要在设备的开发人员选项中启用adb，然后将设备连接到计算机并运行：</p>
<p><code>adb logcat</code></p>
<p>您会看到所有日志，包括stdout / stderr和Kivy记录器。</p>
<p>如果您将应用程序与Buildozer打包在一起，则adb工具可能不在$ PATH中，并且上述命令可能不起作用。 您可以改为运行：</p>
<p><code>buildozer android logcat</code></p>
<p>运行Buildozer安装的版本，或在<code>$ HOME/.buildozer/android/platform</code>中找到SDK工具。<br>您还可以使用<span class="exturl" data-url="aHR0cHM6Ly9wbGF5Lmdvb2dsZS5jb20vc3RvcmUvYXBwcy9kZXRhaWxzP2lkPW9yZy5raXZ5LnB5Z2FtZSZobD1lbg==">Kivy Launcher<i class="fa fa-external-link-alt"></i></span>运行和调试应用程序。 如果以这种方式运行应用程序，则会在应用程序文件夹的<code>/.kivy/logs</code>子文件夹中找到日志文件。</p>
<h4 id="使用Android-API"><a href="#使用Android-API" class="headerlink" title="使用Android API"></a>使用Android API</h4><p>尽管Kivy是Python框架，但Kivy项目维护的工具可以轻松使用常规的Java API，适用于从振动到传感器到通过SMS或电子邮件发送消息的所有内容。</p>
<p>对于新用户，我们建议使用Plyer。 对于更高级的访问或当前未包装的API，您可以直接使用Pyjnius。 Kivy还提供了用于基本Android功能的android模块。</p>
<p>用户提供的Android代码和示例可在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tpdnkva2l2eS93aWtpI21vYmlsZXM=">Kivy Wiki<i class="fa fa-external-link-alt"></i></span>上找到。</p>
<p>夹层</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tpdnkvcGx5ZXI=">Plyer<i class="fa fa-external-link-alt"></i></span>是pythonic的，独立于平台的API，可使用各种平台（尤其是移动平台）上常见的功能。 这样的想法是，您的应用程序可以调用简单地调用Plyer函数，例如向用户呈现通知，而Plyer会以正确的方式进行操作，而不管平台或操作系统如何。 在内部，Plyer使用Pyjnius（在Android上），Pyobjus（在iOS上）和某些台式机平台上特定于平台的API。</p>
<p>例如，以下代码将使您的Android设备振动，或引发NotImplemented- Error，您可以在其他平台（例如没有适当硬件的台式机）上适当处理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> plyer <span class="keyword">import</span> vibrator</span><br><span class="line">vibrator.vibrate(<span class="number">10</span>) <span class="comment"># vibrate for 10 seconds</span></span><br></pre></td></tr></table></figure>
<p>Plyer支持的API列表正在迅速增长，您可以在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tpdnkvcGx5ZXI=">Plyer自述文件<i class="fa fa-external-link-alt"></i></span>中查看完整列表。</p>
<p>平壤</p>
<p>Pyjnius是一个Python模块，可让您直接从Python访问Java类，将参数自动转换为正确的类型，并轻松将Java结果转换为Python。</p>
<p>Pyjnius可以从<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tpdnkvcHlqbml1cw==">github<i class="fa fa-external-link-alt"></i></span>获得，并且有<span class="exturl" data-url="aHR0cDovL3B5am5pdXMucmVhZHRoZWRvY3Mub3JnL2VuL2xhdGVzdC8=">自己的文档<i class="fa fa-external-link-alt"></i></span>。</p>
<p>这是一个简单的示例，展示了Pyjnius能够访问常规Android振动API的功能，与上述plyer代码的结果相同：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 'autoclass' takes a java class and gives it a Python wrapper</span></span><br><span class="line"><span class="keyword">from</span> jnius <span class="keyword">import</span> autoclass</span><br><span class="line"></span><br><span class="line"><span class="comment"># Context is a normal java class in the Android API</span></span><br><span class="line">Context = autoclass(<span class="string">'android.content.Context'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># PythonActivity is provided by the Kivy bootstrap app in python-for-android</span></span><br><span class="line">PythonActivity = autoclass(<span class="string">'org.renpy.android.PythonActivity'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># The PythonActivity stores a reference to the currently running activity</span></span><br><span class="line"><span class="comment"># We need this to access the vibrator service</span></span><br><span class="line">activity = PythonActivity.mActivity</span><br><span class="line"></span><br><span class="line"><span class="comment"># This is almost identical to the java code for the vibrator</span></span><br><span class="line">vibrator = activity.getSystemService(Context.VIBRATOR_SERVICE)</span><br><span class="line">vibrator.vibrate(<span class="number">10000</span>) <span class="comment"># The value is in milliseconds - this is 10s</span></span><br></pre></td></tr></table></figure>
<p>该代码直接遵循Java API函数来调用振动器，Pyjnius会自动将api转换为Python代码，然后将我们的调用转换回等效的java。 它比Plyer的版本更加冗长和类似Java，在这种情况下没有好处，尽管Plyer并未包装Pyjnius可用的所有API。</p>
<p>Pyjnius还具有实现Java接口的强大功能，这对于包装某些API非常重要，但此处未进行记录-您可以查看Pyjnius<span class="exturl" data-url="aHR0cDovL3B5am5pdXMucmVhZHRoZWRvY3Mub3JnL2VuL2xhdGVzdC8=">自己的文档<i class="fa fa-external-link-alt"></i></span>。</p>
<p>Android模块</p>
<p>适用于Android的Python包含一个python模块（实际上是cython包装Java），用于访问一组有限的Android API。 如上所述，这已经被更灵活的Pyjnius和Plyer所取代，但有时仍然有用。 可用的功能在<a href="http://python-for-android.readthedocs.org/en/latest/" target="_blank" rel="noopener"><code>python-for-android</code>文档</a>中给出。</p>
<p>其中包括用于结算/IAP和创建/访问Android服务的代码，上述其他工具尚不提供此代码。</p>
<h4 id="项目和经过测试的设备的状态"><a href="#项目和经过测试的设备的状态" class="headerlink" title="项目和经过测试的设备的状态"></a>项目和经过测试的设备的状态</h4><p>前面这些部分描述了Kivy的Android构建工具的存在，其局限性以及已知可以运行的某些设备。</p>
<p>Android工具现在非常稳定，几乎可以在任何设备上使用。 我们的最低要求是OpenGL ES 2.0和Android 2.2。 这些现在很常见-Kivy甚至可以在Android智能手表上运行！</p>
<p>当前的技术限制是Android构建工具只能编译ARM APK，而ARM APK不能在具有x86处理器的Android设备上运行（目前很少见）。 这应该尽快添加。</p>
<p>由于Kivy在大多数设备上都能正常工作，因此支持的手机/平板电脑列表已淘汰-如果所有Android设备都符合上述条件，则它们可能会正常工作。</p>
<h3 id="为OS-X创建软件包"><a href="#为OS-X创建软件包" class="headerlink" title="为OS X创建软件包"></a>为OS X创建软件包</h3><hr>
<p><strong>注意：本指南描述了打包Kivy应用程序的多种方法。 建议与PyInstaller包装在一起使用。</strong></p>
<hr>
<h4 id="使用PyInstaller和Homebrew"><a href="#使用PyInstaller和Homebrew" class="headerlink" title="使用PyInstaller和Homebrew"></a>使用PyInstaller和Homebrew</h4><hr>
<p><strong>注意：将您的应用程序打包到您要支持的最旧的OS X版本上。</strong></p>
<hr>
<p>完整指南</p>
<p>1.安装自制软件</p>
<p>2.安装Python：</p>
<p><code>$ brew install python</code></p>
<hr>
<p><strong>注意：要使用Python 3，请在下面的指南中brew安装python3并将pip替换为pip3。</strong></p>
<hr>
<p>3.使用–build-bottle（重新）安装依赖项，以确保它们可以在其他计算机上使用：</p>
<p><code>$ brew reinstall --build-bottle sdl2 sdl2_image sdl2_ttf sdl2_mixer</code></p>
<hr>
<p><strong>注意：如果您的项目依赖于GStreamer或其他附加库，请使用–build-bottle重新安装它们，如下所述。</strong></p>
<hr>
<p>4.安装Cython和Kivy：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ pip install Cython==<span class="number">0.29</span><span class="number">.14</span></span><br><span class="line">$ pip install -U kivy</span><br></pre></td></tr></table></figure>
<p>5.安装PyInstaller：</p>
<p><code>$ pip install -U pyinstaller</code></p>
<p>6.使用main.py的路径打包应用程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ pyinstaller -y --clean --windowed --name touchtracer \</span><br><span class="line">  --exclude-module _tkinter \</span><br><span class="line">  --exclude-module Tkinter \</span><br><span class="line">  --exclude-module enchant \</span><br><span class="line">  --exclude-module twisted \</span><br><span class="line">  /usr/local/share/kivy-examples/demo/touchtracer/main.py</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>注意：这将不会复制其他图像或声音文件。 您需要为此修改创建的.spec文件。</strong></p>
<hr>
<p>编辑规格文件</p>
<p>specs文件名为touchtracer.spec，位于您运行pyinstaller命令的目录中。</p>
<p>您需要更改COLLECT（）调用以添加touchtracer的数据（touchtracer.kv，Particle.png，…）。 更改该行以添加Tree（）对象。 该树将搜索并将在touchtracer目录中找到的每个文件添加到最终包中。 您的COLLECT部分应如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">coll = COLLECT(exe, Tree(<span class="string">'/usr/local/share/kivy-examples/demo/touchtracer/'</span>),</span><br><span class="line">                a.binaries,</span><br><span class="line">                a.zipfiles,</span><br><span class="line">                a.datas,</span><br><span class="line">                strip=<span class="literal">None</span>,</span><br><span class="line">                upx=<span class="literal">True</span>,</span><br><span class="line">                name=<span class="string">'touchtracer'</span>)</span><br></pre></td></tr></table></figure>
<p>这将添加所需的挂钩，以便PyInstaller获取所需的Kivy文件。我们完了。您的规格已准备就绪，可以执行。</p>
<p>建立规范并创建DMG</p>
<p>1.打开控制台。</p>
<p>2.转到PyInstaller目录，并建立规范：</p>
<p><code>$ pyinstaller -y --clean --windowed touchtracer.spec</code></p>
<p>3.执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ pushd dist</span><br><span class="line">$ hdiutil create ./Touchtracer.dmg -srcfolder touchtracer.app -ov</span><br><span class="line">$ popd</span><br></pre></td></tr></table></figure>

<p>4.现在，您将在dist目录中获得一个<code>Touchtracer.dmg</code>。</p>
<p>附加图书馆</p>
<p>GStreamer</p>
<p>如果您的项目依赖于GStreamer：</p>
<p><code>$ brew reinstall --build-bottle gstreamer gst-plugins-{base,good,bad,ugly}</code></p>
<hr>
<p><strong>注意：如果您的项目需要Ogg Vorbis支持，请确保在上述命令中添加–with-libvorbis选项。</strong></p>
<hr>
<p>如果您使用的是Homebrew的Python，则在合并此拉取请求之前，还需要执行以下步骤：</p>
<p><code>$ brew reinstall --with-python --build-bottle https://github.com/cbenhagen/homebrew/raw/patch-3/Library/Formula/gst-python.rb</code></p>
<h4 id="在没有Homebrew的情况下使用PyInstaller"><a href="#在没有Homebrew的情况下使用PyInstaller" class="headerlink" title="在没有Homebrew的情况下使用PyInstaller"></a>在没有Homebrew的情况下使用PyInstaller</h4><p>首先在不使用Homebrew的情况下安装Kivy及其依赖项，如<span class="exturl" data-url="aHR0cDovL2tpdnkub3JnL2RvY3MvaW5zdGFsbGF0aW9uL2luc3RhbGxhdGlvbi5odG1sI2RldmVsb3BtZW50LXZlcnNpb27miYDov7DjgII=">http://kivy.org/docs/installation/installation.html#development-version所述。<i class="fa fa-external-link-alt"></i></span></p>
<p>一旦安装了kivy及其dep，就需要安装PyInstaller。</p>
<p>假设我们使用了像testpackaging这样的文件夹：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cd testpackaging</span><br><span class="line">git clone http://github.com/pyinstaller/pyinstaller</span><br></pre></td></tr></table></figure>
<p>在此目录中创建一个名为<code>touchtracer.spec</code>的文件，并向其中添加以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- mode: python -*-</span></span><br><span class="line">block_cipher = <span class="literal">None</span></span><br><span class="line"><span class="keyword">from</span> kivy.tools.packaging.pyinstaller_hooks <span class="keyword">import</span> get_deps_all, hookspath,runtime_hooks</span><br><span class="line">a = Analysis([<span class="string">'/path/to/yout/folder/containing/examples/demo/touchtracer/main.py'</span>],</span><br><span class="line">             pathex=[<span class="string">'/path/to/yout/folder/containing/testpackaging'</span>],</span><br><span class="line">             binaries=<span class="literal">None</span>,</span><br><span class="line">             win_no_prefer_redirects=<span class="literal">False</span>,</span><br><span class="line">             win_private_assemblies=<span class="literal">False</span>,</span><br><span class="line">             cipher=block_cipher,</span><br><span class="line">             hookspath=hookspath(),</span><br><span class="line">             runtime_hooks=runtime_hooks(),</span><br><span class="line">             **get_deps_all())</span><br><span class="line">pyz = PYZ(a.pure, a.zipped_data,</span><br><span class="line">          cipher=block_cipher)</span><br><span class="line">exe = EXE(pyz,</span><br><span class="line">            a.scripts,</span><br><span class="line">            exclude_binaries=<span class="literal">True</span>,</span><br><span class="line">            name=<span class="string">'touchtracer'</span>,</span><br><span class="line">            debug=<span class="literal">False</span>,</span><br><span class="line">            strip=<span class="literal">False</span>,</span><br><span class="line">            upx=<span class="literal">True</span>,</span><br><span class="line">            console=<span class="literal">False</span> )</span><br><span class="line">coll = COLLECT(exe, Tree(<span class="string">'../kivy/examples/demo/touchtracer/'</span>),</span><br><span class="line">                Tree(<span class="string">'/Library/Frameworks/SDL2_ttf.framework/Versions/A/Frameworks/FreeType.framework'</span>),</span><br><span class="line">                a.binaries,</span><br><span class="line">                a.zipfiles,</span><br><span class="line">                a.datas,</span><br><span class="line">                strip=<span class="literal">False</span>,</span><br><span class="line">                upx=<span class="literal">True</span>,</span><br><span class="line">                name=<span class="string">'touchtracer'</span>)</span><br><span class="line">app = BUNDLE(coll,</span><br><span class="line">                name=<span class="string">'touchtracer.app'</span>,</span><br><span class="line">                icon=<span class="literal">None</span>,</span><br><span class="line">                bundle_identifier=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>使用相关路径更改路径：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = Analysis（[<span class="string">'/ path / to / yout / folder / contains / examples / demo / touchtracer / main.py'</span>]，				pathex = [<span class="string">'/ path / to / yout / folder /包含/ testpackaging'</span>]，</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">coll = COLLECT（exe，Tree（<span class="string">'../ kivy / examples / demo / touchtracer /'</span>），</span><br></pre></td></tr></table></figure>

<p>然后运行以下命令：</p>
<figure class="highlight plain"><figcaption><span>/ pyinstaller.py touchtracer.spec```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在适当的地方用您的应用替换touchtracer。 这将在dist &#x2F;文件夹中为您提供一个&lt;yourapp&gt; .app。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 使用Buildozer</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;pip install git+http:&#x2F;&#x2F;github.com&#x2F;kivy&#x2F;buildozer cd &#x2F;to&#x2F;where&#x2F;I&#x2F;Want&#x2F;to&#x2F;package buildozer init</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>注意：必须在OS X内使用以下方法打包Kivy应用程序，不再支持32位平台。</strong></p>
<hr>
<p>编辑buildozer.spec并添加您的应用程序的详细信息。 依赖关系可以添加到“ requirements =”部分。</p>
<p>默认情况下，将忽略需求中指定的kivy版本。</p>
<p>如果您在/Applications/Kivy.app上有一个Kivy.app，则将其用于打包。 否则，将下载并使用kivy.org中使用Kivy master的最新版本。</p>
<p>如果要打包python 3.x.x，只需从kivy.org的下载部分下载名为Kivy3.7z的软件包，然后将其解压缩到/ Applications中的Kivy.app，然后运行：</p>
<figure class="highlight plain"><figcaption><span>osx debug```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">将应用打包后，如果不需要视频支持，则可能要删除不需要的包，例如gstreamer。 相同的逻辑适用于您不使用的其他内容，只需将程序包减小到运行该应用程序所需的最小状态即可。</span><br><span class="line"></span><br><span class="line">作为示例，我们包括针对Python 2（9.xMB）和3（15.xMB）使用此方法打包的展示示例，您可以在以下位置找到这些包：[https:&#x2F;&#x2F;drive.google.com&#x2F;drive&#x2F;folders &#x2F;0B1WO07-OL50_alFzSXJUajBFdnc。](https:&#x2F;&#x2F;drive.google.com&#x2F;drive&#x2F;folders&#x2F;0B1WO07-OL50_alFzSXJUajBFdnc)</span><br><span class="line"></span><br><span class="line">而已。 请享用！</span><br><span class="line"></span><br><span class="line">Buildozer现在使用Kivy SDK打包您的应用程序。 如果要控制的应用程序详细信息比buildozer当前提供的更多，则可以直接使用SDK，如以下部分中所述。</span><br><span class="line"></span><br><span class="line">#### 使用Kivy SDK</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">**注意：Kivy.app目前无法下载。 有关详细信息，请参见此问题。**</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">**注意：必须在OS X内使用以下方法打包Kivy应用程序，不再支持32位平台。**</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">从1.9.0版开始，Kivy以自包含，可移植的发行版发布用于OS X平台。</span><br><span class="line"></span><br><span class="line">可以使用Kivy SDK使用以下描述的方法来打包和分发应用程序，从而更轻松地包含SDL2和GStreamer之类的框架。</span><br><span class="line"></span><br><span class="line">1.确保从下载页面获得未修改的Kivy SDK（Kivy.app）。</span><br><span class="line"></span><br><span class="line">2.运行以下命令：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">&gt; mkdir packaging</span><br><span class="line">&gt; cd packaging</span><br><span class="line">packaging&gt; git clone https:&#x2F;&#x2F;github.com&#x2F;kivy&#x2F;kivy-sdk-packager</span><br><span class="line">packaging&gt; cd kivy-sdk-packager&#x2F;osx</span><br><span class="line">osx&gt; cp -a &#x2F;Applications&#x2F;Kivy.app .&#x2F;Kivy.App</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>注意：以上步骤很重要，您必须确保保留路径和权限。 诸如cp -rf之类的命令将复制但使该应用程序无法使用，并在以后导致错误。</strong></p>
<hr>
<p>3.现在，您需要做的就是通过运行以下命令将编译后的应用程序包含在Kivy.app中：</p>
<figure class="highlight plain"><figcaption><span>./package-app.sh</span><a href="/path/to/your/<app_folder_name>/```">link</a></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">其中&lt;app_folder_name&gt;是您的应用程序的名称。</span><br><span class="line"></span><br><span class="line">这会将Kivy.app复制到&lt;app_folder_name&gt; .app，并将应用程序的已编译副本包含到此程序包中。</span><br><span class="line"></span><br><span class="line">4.就是这样，您已经准备好部署独立的软件包！ 现在，您可以按照下面的说明进一步自定义应用。</span><br><span class="line"></span><br><span class="line">安装模块</span><br><span class="line"></span><br><span class="line">osx上的Kivy软件包使用其自己的虚拟环境，当您使用kivy命令运行应用程序时会激活该环境。 要安装任何模块，您需要像这样安装模块：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;$ kivy -m pip install &lt;modulename&gt;</span><br></pre></td></tr></table></figure>

<p>模块/文件安装在哪里？</p>
<p>在应用内的便携式venv中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">如果您安装了安装二进制文件的模块，例如kivy-garden，那么该二进制文件仅可从上面的venv中获得，如下所示：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;kivy -m pip install kivy-garden</span><br></pre></td></tr></table></figure>

<p>仅当您激活此环境时，花园lib才可用。</p>
<p>源<code>/Applications/Kivy.app/Contents/Resources/venv/bin/activate</code>花园安装mapview停用</p>
<p>安装二进制文件</p>
<p>只需将二进制文件复制到<code>Kivy.app/Contents/Resources/venv/bin/</code>目录。</p>
<p>包括其他框架</p>
<p>Kivy.app附带提供的SDL2和Gstreamer框架。 要包括除提供的框架以外的框架，请执行以下操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git clone http://github.com/tito/osxrelocator</span><br><span class="line">export PYTHONPATH=~/path/to/osxrelocator</span><br><span class="line">cd Kivy.app</span><br><span class="line">python -m osxrelocator -r . /Library/Frameworks/&lt;Framework_name&gt;.framework/ \</span><br><span class="line"><span class="meta">@executable_path/../Frameworks/&lt;Framework_name&gt;.framework/</span></span><br></pre></td></tr></table></figure>

<p>不要忘记用您的框架替换<Framework_name>。 该工具osxrelocator实质上更改了框架中lib的路径，以使它们相对于.app中的可执行文件，从而使Framework可随.app移植。</Framework_name></p>
<p>缩小应用程序大小</p>
<p>该应用目前具有相当大的尺寸，但是不需要的部分可以从包装中取出。</p>
<p>例如，如果您不使用GStreamer，则只需将其从<code>YourApp.app/Contents/Frameworks</code>中删除。 同样，您可以从<code>/ Applications / Kivy.app/Contents/Resources/kivy/examples/</code>或<code>kivy/tools，kivy/docs</code>等中删除examples文件夹。</p>
<p>这样，可以使程序包仅包含应用程序所需的部分。</p>
<p>调整设定</p>
<p>您可以通过编辑<code>YourApp/Contents/info.plist</code>来更改应用程序的图标和其他设置，以适应您的需求。</p>
<p>创建一个DMG</p>
<p>要使用您的应用程序制作DMG，请使用以下命令：</p>
<figure class="highlight plain"><figcaption><span>./create-osx-dmg.sh YourApp.app```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">请注意末尾缺少&#x2F;。 这应该为您提供一个压缩的dmg，它将进一步缩小您的分布式应用程序的大小。</span><br><span class="line"></span><br><span class="line">### 为IOS创建一个包</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">**注意：目前，kivy-iOS使用Python 2.7和3.7构建软件包。**</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">可以通过4个步骤来说明为IOS创建软件包的整个过程：</span><br><span class="line"></span><br><span class="line">1.编译发行版（适用于IOS的python +模块）</span><br><span class="line"></span><br><span class="line">2.创建一个Xcode项目（并链接您的源代码）</span><br><span class="line"></span><br><span class="line">3.更新Xcode项目</span><br><span class="line"></span><br><span class="line">4.自定义Xcode项目</span><br><span class="line"></span><br><span class="line">#### 先决条件</span><br><span class="line"></span><br><span class="line">您需要安装一些依赖项，例如Cython，自动工具等。我们建议您使用[Homebrew](http:&#x2F;&#x2F;mxcl.github.com&#x2F;homebrew&#x2F;)安装这些依赖项：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">brew install autoconf automake libtool pkg-config</span><br><span class="line">brew link libtool</span><br><span class="line">sudo easy_install pip</span><br><span class="line">sudo pip install Cython&#x3D;&#x3D;0.29.14</span><br></pre></td></tr></table></figure>

<p>有关更多详细信息，请参见IOS先决条件。 在开始第二步之前，只需确保一切正常即可！</p>
<h4 id="编译发行版"><a href="#编译发行版" class="headerlink" title="编译发行版"></a>编译发行版</h4><p>打开一个终端，然后键入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ git clone git://github.com/kivy/kivy-ios</span><br><span class="line">$ cd kivy-ios</span><br><span class="line">$ ./toolchain.py build kivy</span><br></pre></td></tr></table></figure>

<p>大部分python发行版都打包在python27.zip中。 如果您遇到任何问题，请参考<span class="exturl" data-url="aHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9mb3J1bS8jIWZvcnVtL2tpdnktdXNlcnM=">我们的用户组<i class="fa fa-external-link-alt"></i></span>或<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tpdnkva2l2eS1pb3M=">kivy-ios项目<i class="fa fa-external-link-alt"></i></span>页面。</p>
<h4 id="创建一个Xcode项目"><a href="#创建一个Xcode项目" class="headerlink" title="创建一个Xcode项目"></a>创建一个Xcode项目</h4><p>在继续下一步之前，请确保您的应用程序入口点是一个名为main.py的文件。</p>
<p>我们提供了一个脚本，用于创建一个初始的Xcode项目。 在下面的命令行中，将test替换为您的项目名称。 它必须是一个没有空格或非法字符的名称：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ ./toolchain.py create &lt;title&gt; &lt;app_directory&gt;</span><br><span class="line">$ ./toolchain.py create Touchtracer ~/code/kivy/examples/demo/touchtracer</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>注意：您必须使用到应用程序目录的标准路径。</strong></p>
<hr>
<p>将创建一个名为<title> -ios的目录，其中包含一个Xcode项目。 您可以打开Xcode项目：</title></p>
<figure class="highlight plain"><figcaption><span>open touchtracer-ios/touchtracer.xcodeproj```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">然后单击“播放”，然后欣赏。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">**注意：每按一次Play，您的应用程序目录将被同步到&lt;title&gt; -ios &#x2F; YourApp目录。 不要直接在-ios目录中进行更改。**</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">#### 更新Xcode项目</span><br><span class="line"></span><br><span class="line">假设您要向项目添加numpy，但在创建XCode项目之前并未对其进行编译。 首先，确保它是构建的：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;$ .&#x2F;toolchain.py build numpy</span><br></pre></td></tr></table></figure>

<p>然后，更新您的Xcode项目：</p>
<p><code>$ ./toolchain.py update touchtracer-ios</code></p>
<p>运行所有已编译配方所需的所有库/框架都将添加到您的Xcode项目中。</p>
<h4 id="自定义Xcode项目"><a href="#自定义Xcode项目" class="headerlink" title="自定义Xcode项目"></a>自定义Xcode项目</h4><p>有多种自定义和配置应用程序的方法。 请参阅<span class="exturl" data-url="aHR0cDovL3d3dy5naXRodWIuY29tL2tpdnkva2l2eS1pb3M=">kivy-ios文档<i class="fa fa-external-link-alt"></i></span>以获取更多信息。</p>
<h4 id="已知的问题"><a href="#已知的问题" class="headerlink" title="已知的问题"></a>已知的问题</h4><p>当前在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tpdnkva2l2eS1pb3MvaXNzdWVz">“问题”<i class="fa fa-external-link-alt"></i></span>页面上跟踪了iOS打包的所有已知问题。 如果您遇到此处未列出的特定于iOS包装的问题，请随时提交新的问题，我们将尽快与您联系。</p>
<p>尽管大多数技术都不适合在此处编写，但一个重要的已知问题是当前无法删除某些库（例如用于音频的SDL_Mixer），因为kivy项目需要这样做。 我们将在以后的版本中修复此问题和其他问题。</p>
<h4 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h4><p>申请异常退出！</p>
<p>默认情况下，控制台和文件的所有打印语句都将被忽略。 如果在运行应用程序时遇到问题，可以通过在main.m中注释掉以下行来激活日志：</p>
<p>123</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Kivy</category>
      </categories>
      <tags>
        <tag>kivy</tag>
      </tags>
  </entry>
  <entry>
    <title>Kivy参考文档（二）</title>
    <url>/2020/03/03/23592/</url>
    <content><![CDATA[<h1 id="第二部分-编程指南"><a href="#第二部分-编程指南" class="headerlink" title="第二部分 编程指南"></a>第二部分 编程指南</h1><h2 id="小部件"><a href="#小部件" class="headerlink" title="小部件"></a>小部件</h2><h3 id="小部件简介"><a href="#小部件简介" class="headerlink" title="小部件简介"></a>小部件简介</h3><p>小部件是Kivy中GUI界面的基本构建块。 它提供了可用于在屏幕上绘制的画布。 它接收事件并对它们做出反应。 有关Widget类的详细说明，请参阅模块文档。</p>
<a id="more"></a>

<h3 id="操纵小部件树"><a href="#操纵小部件树" class="headerlink" title="操纵小部件树"></a>操纵小部件树</h3><p>Kivy中的小部件组织在树中。 您的应用程序具有一个根窗口小部件，该窗口小部件通常具有可以具有自己的子代的子代。 小部件的子代表示为children属性，即Kivy ListProperty。</p>
<p>窗口小部件树可以通过以下方法进行操作：</p>
<ul>
<li><code>add_widget()</code>：将小部件添加为子级</li>
<li><code>remove_widget()</code>：从子级列表中删除小部件</li>
<li><code>clear_widgets()</code>：从小部件中删除所有子项</li>
</ul>
<p>例如，如果要在BoxLayout中添加按钮，则可以执行以下操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">layout = BoxLayout(padding=<span class="number">10</span>)</span><br><span class="line">button = Button(text=<span class="string">'My first button'</span>)</span><br><span class="line">layout.add_widget(button)</span><br></pre></td></tr></table></figure>
<p>按钮已添加到布局：按钮的父属性将设置为布局； 版式会将按钮添加到其子级列表中。 要从布局中删除按钮：</p>
<p><code>layout.remove_widget(button)</code></p>
<p>移除后，按钮的父级属性将设置为“无”，并且布局将从其子级列表中移除按钮。</p>
<p>如果要清除窗口小部件内的所有子项，请使用<code>clear_widgets()</code>方法：</p>
<p><code>layout.clear_widgets()</code></p>
<hr>
<p><strong>警告：切勿操纵孩子列出自己的名字，除非您真的知道自己在做什么。 小部件树与图形树相关联。 例如，如果您将一个小部件添加到子级列表中而未将其画布添加到图形树中，则该小部件将是子级，是的，但是不会在屏幕上绘制任何内容。 而且，您可能在进一步调用<code>add_widget</code>，<code>remove_widget</code>和<code>clear_widgets</code>时遇到问题。</strong></p>
<hr>
<h3 id="遍历树"><a href="#遍历树" class="headerlink" title="遍历树"></a>遍历树</h3><p>Widget类实例的子代列表属性包含所有子代。 您可以通过以下操作轻松遍历树：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">root = BoxLayout()</span><br><span class="line"><span class="comment"># ... add widgets to root ...</span></span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> root.children:</span><br><span class="line">    print(child)</span><br></pre></td></tr></table></figure>
<p>但是，必须谨慎使用。 如果要使用上一节中显示的方法之一修改子级列表，则必须使用该列表的副本，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> root.children[:]:</span><br><span class="line">    <span class="comment"># manipulate the tree. For example here, remove all widgets that have a</span></span><br><span class="line">    <span class="comment"># width &lt; 100</span></span><br><span class="line">    <span class="keyword">if</span> child.width &lt; <span class="number">100</span>:</span><br><span class="line">        root.remove_widget(child)</span><br></pre></td></tr></table></figure>
<p>默认情况下，小部件不会影响其子级的大小/位置。 pos属性是屏幕坐标中的绝对位置（除非您使用relativelayout。稍后会详细介绍），尺寸是绝对尺寸。</p>
<h3 id="小部件Z索引"><a href="#小部件Z索引" class="headerlink" title="小部件Z索引"></a>小部件Z索引</h3><p>窗口小部件绘制的顺序基于窗口小部件在窗口小部件树中的位置。 add_widget方法采用一个索引参数，该参数可用于指定其在小部件树中的位置：</p>
<p><code>root.add_widget(widget, index)</code></p>
<p>索引较低的窗口小部件将在索引较高的窗口小部件上方绘制。 请记住，索引的默认值为0，因此，除非另行指定，否则以后添加的小部件将在其他小部件之上绘制。</p>
<h3 id="使用布局进行组织"><a href="#使用布局进行组织" class="headerlink" title="使用布局进行组织"></a>使用布局进行组织</h3><p>layout是一种特殊的小部件，可控制其子级的大小和位置。有不同种类的布局，可以对孩子进行不同的自动组织。 布局使用<em>size_hint</em>和<em>pos_hint</em>属性确定其子级的大小和pos。</p>
<p><strong>BoxLayout</strong>: 以相邻方式（垂直或水平）方式排列小部件，以填充所有空间。 子级的size_hint属性可用于更改允许每个子级的比例，或为其中一些设置固定大小。</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3KiHR1.png" alt="3KiHR1.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/21/3KFAL8.png" alt="3KFAL8.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/21/3KFNFJ.png" alt="3KFNFJ.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/21/3KF0Qx.png" alt="3KF0Qx.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/21/3KkZX6.png" alt="3KkZX6.png"></p>
<p><strong>GridLayout</strong>: 在网格中排列小部件。您必须至少指定网格的一维，以便kivy可以计算元素的大小以及如何排列它们。</p>
<p><strong>StackLayout</strong>: 将小部件彼此相邻排列，但在其中一个尺寸中设置一个固定的大小，而不会试图使其适合整个空间。 这对于显示相同预定义大小的子代很有用。</p>
<p><strong>AnchorLayout</strong>: 一个简单的布局只关心孩子的位置。 它允许将子级放置在相对于布局边框的位置。 size_hint不兑现。</p>
<p><strong>FloatLayout</strong>: 允许放置具有任意位置和大小（绝对值或相对于布局大小）的子级。 默认的size_hint（1，1）将使每个子级与整个布局具有相同的大小，因此如果您有多个子级，则可能需要更改此值。 您可以将size_hint设置为（None，None）以将绝对大小与大小一起使用。 此小部件还接受pos_hint，这是相对于布局位置的dict设置位置。</p>
<p><strong>RelativeLayout</strong>: 行为与FloatLayout一样，只是子位置相对于布局位置而不是屏幕相对。</p>
<p>检查各个布局的文档以更深入地了解。</p>
<p><em>size_hint</em> 和 <em>pos_hint</em>:</p>
<ul>
<li><em>floatlayout</em></li>
<li><em>boxlayout</em></li>
<li><em>gridlayout</em></li>
<li><em>stacklayout</em></li>
<li><em>relativelayout</em></li>
<li><em>anchorlayout</em></li>
</ul>
<p><em>size_hint</em>是<em>size_hint_x</em>和<em>size_hint_y</em>的<em>ReferenceListProperty</em>。 它接受0到1或无的值，默认为（1，1）。 这表示如果窗口小部件位于布局中，则布局将在两个方向（相对于布局大小）上尽可能多地分配其位置。</p>
<p>例如，将<em>size_hint</em>设置为（0.5，0.8），将使窗口小部件的宽度在布局内的宽度为50％，高度为高度的80％。</p>
<p>考虑以下示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">BoxLayout:</span><br><span class="line">    Button:</span><br><span class="line">        text: <span class="string">'Button 1'</span></span><br><span class="line">        <span class="comment"># default size_hint is 1, 1, we don't need to specify it explicitly</span></span><br><span class="line">        <span class="comment"># however it's provided here to make things clear</span></span><br><span class="line">        size_hint: <span class="number">1</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>现在，通过键入以下内容来加载kivy目录，但是将$ KIVYDIR替换为您的安装目录（可通过<code>os.path.dirname（kivy .__ file__）</code>发现）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cd $KIVYDIR/examples/demo/kivycatalog</span><br><span class="line">python main.py</span><br></pre></td></tr></table></figure>
<p>将会出现一个新窗口。点击左侧“欢迎”微调框下方的区域，然后用上方的kv代码替换其中的文字。</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3KECW9.png" alt="3KECW9.png"></p>
<p>从上图可以看到，Button占据了布局大小的100％。</p>
<p>将size_hint_x / size_hint_y更改为.5将使小部件占据布局宽度/高度的50％。</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3KEZdO.png" alt="3KEZdO.png"></p>
<p>您可以在此处看到，尽管我们将<code>size_hint_x</code>和<code>size_hint_y</code>都指定为.5，但似乎只接受<code>size_hint_y</code>。这是因为在垂直方向上，<code>boxlayout</code>控制<code>size_hint_y</code>，在水平方向上则控制<code>size_hint_x</code>。受控尺寸的大小取决于总编号。在<code>boxlayout</code>中的孩子。在此示例中，一个孩子的<code>size_hint_y</code>受控制.5 /.5 = 1）。因此，小部件占据了父级布局高度的100％。</p>
<p>让我们向布局添加另一个按钮，看看会发生什么。</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3KEv6I.png" alt="3KEv6I.png"></p>
<p><code>boxlayout</code>本质上将其子级之间的可用空间平均分配。 在我们的示例中，该比例为50-50，因为我们有两个孩子。 让我们在其中一个孩子上使用<code>size_hint</code>并查看结果。</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3KVu7T.png" alt="3KVu7T.png"></p>
<p>如果子级指定<code>size_hint</code>，则此值指定<code>Widget</code>将超出<code>BoxLayout</code>为其指定大小的空间。 在我们的示例中，第一个<code>Button</code>为<code>size_hint_x</code>指定.5。 小部件的空间的计算方式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">first child<span class="string">'s size_hint divided by</span></span><br><span class="line"><span class="string">first child'</span>s size_hint + second child<span class="string">'s size_hint + ...n(no of children)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">.5/(.5+1) = .333...</span></span><br></pre></td></tr></table></figure>
<p><code>BoxLayout</code>的其余宽度由其余的子项分配。 在我们的示例中，这意味着第二个<code>Button</code>占用布局宽度的66.66％。</p>
<p>试用<code>size_hint</code>使其适应。</p>
<p>如果要控制窗口小部件的绝对大小，可以将<code>size_hint_x / size_hint_y</code>或两者都设置为<code>None</code>，以便使用窗口小部件的<code>width</code>和<code>height</code>属性。</p>
<p><code>pos_hint</code>是字典，默认为空。 至于<code>size_hint</code>，布局使用<code>pos_hint</code>的方式有所不同，但是通常您可以将值添加到任何pos属性<code>（x，y，right，top，center_x，center_y）</code>，以使Widget相对于其父项定位。</p>
<p>让我们在<code>kivycatalog</code>中尝试以下代码，以直观地了解<code>pos_hint</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FloatLayout:</span><br><span class="line">    Button:</span><br><span class="line">        text: <span class="string">"We Will"</span></span><br><span class="line">        pos: <span class="number">100</span>, <span class="number">100</span></span><br><span class="line">        size_hint: <span class="number">.2</span>, <span class="number">.4</span></span><br><span class="line">    Button:</span><br><span class="line">        text: <span class="string">"Wee Wiill"</span></span><br><span class="line">        pos: <span class="number">200</span>, <span class="number">200</span></span><br><span class="line">        size_hint: <span class="number">.4</span>, <span class="number">.2</span></span><br><span class="line">    Button:</span><br><span class="line">        text: <span class="string">"ROCK YOU!!"</span></span><br><span class="line">        pos_hint: &#123;<span class="string">'x'</span>: <span class="number">.3</span>, <span class="string">'y'</span>: <span class="number">.6</span>&#125;</span><br><span class="line">        size_hint: <span class="number">.5</span>, <span class="number">.2</span></span><br></pre></td></tr></table></figure>
<p>这给了我们：</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3KVfUS.png" alt="3KVfUS.png"></p>
<p>与<code>size_hint</code>一样，您应该尝试<code>pos_hint</code>来了解其对小部件位置的影响。</p>
<h3 id="在布局中添加背景"><a href="#在布局中添加背景" class="headerlink" title="在布局中添加背景"></a>在布局中添加背景</h3><p>有关布局的常见问题之一是：</p>
<p><code>“如何将背景图像/颜色/视频/ ...添加到布局中”</code></p>
<p>布局本质上没有视觉表现形式：默认情况下它们没有画布说明。 但是，您可以轻松地将画布指令添加到布局实例，就像添加彩色背景一样：</p>
<p>在<strong>Python</strong>中:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> kivy.graphics <span class="keyword">import</span> Color, Rectangle</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> layout_instance.canvas.before:</span><br><span class="line">        Color(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>) <span class="comment"># green; colors range from 0-1 instead of 0-255</span></span><br><span class="line">        self.rect = Rectangle(size=layout_instance.size, pos=layout_instance.pos)</span><br></pre></td></tr></table></figure>

<p>不幸的是，这只会在布局的初始位置和大小处绘制一个矩形。 为了确保在布局内部绘制矩形，当布局大小/位置发生变化时，我们需要听取任何更改并更新矩形的大小和位置。 我们可以这样做，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> layout_instance.canvas.before:</span><br><span class="line">    Color(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>) <span class="comment"># green; colors range from 0-1 instead of 0-255</span></span><br><span class="line">    self.rect = Rectangle(size=layout_instance.size, pos=layout_instance.pos)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_rect</span><span class="params">(instance, value)</span>:</span></span><br><span class="line">    instance.rect.pos = instance.pos</span><br><span class="line">    instance.rect.size = instance.size</span><br><span class="line">    <span class="comment"># listen to size and position changes</span></span><br><span class="line">    layout_instance.bind(pos=update_rect, size=update_rect)</span><br></pre></td></tr></table></figure>

<p>在kv文件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FloatLayout:</span><br><span class="line">    canvas.before:</span><br><span class="line">        Color:</span><br><span class="line">            rgba: 0, 1, 0, 1</span><br><span class="line">        Rectangle:</span><br><span class="line">            # self here refers to the widget i.e BoxLayout</span><br><span class="line">            pos: self.pos</span><br><span class="line">            size: self.size</span><br></pre></td></tr></table></figure>

<p>kv声明设置了一个隐式绑定：最后两行kv行确保当<em>floatlayout</em>的<em>pos</em>更改时，矩形的<em>pos</em>和<em>size</em>值将更新。</p>
<p>现在，将上面的代码片段放入Kivy App的外壳中。</p>
<p>纯<strong>Python</strong>方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> kivy.app <span class="keyword">import</span> App</span><br><span class="line"><span class="keyword">from</span> kivy.graphics <span class="keyword">import</span> Color, Rectangle</span><br><span class="line"><span class="keyword">from</span> kivy.uix.floatlayout <span class="keyword">import</span> FloatLayout</span><br><span class="line"><span class="keyword">from</span> kivy.uix.button <span class="keyword">import</span> Button</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootWidget</span><span class="params">(FloatLayout)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># make sure we aren't overriding any important functionality</span></span><br><span class="line">        super(RootWidget, self).__init__(**kwargs)</span><br><span class="line">        <span class="comment"># let's add a Widget to this layout</span></span><br><span class="line">        self.add_widget(</span><br><span class="line">            Button(</span><br><span class="line">                text=<span class="string">"Hello World"</span>,</span><br><span class="line">                size_hint=(<span class="number">.5</span>, <span class="number">.5</span>),</span><br><span class="line">                pos_hint=&#123;<span class="string">'center_x'</span>: <span class="number">.5</span>, <span class="string">'center_y'</span>: <span class="number">.5</span>&#125;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainApp</span><span class="params">(App)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = root = RootWidget()</span><br><span class="line">        root.bind(size=self._update_rect, pos=self._update_rect)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> root.canvas.before:</span><br><span class="line">            Color(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>) <span class="comment"># green; colors range from 0-1 not 0-255</span></span><br><span class="line">            self.rect = Rectangle(size=root.size, pos=root.pos)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_update_rect</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        self.rect.pos = instance.pos</span><br><span class="line">        self.rect.size = instance.size</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    MainApp().run()</span><br></pre></td></tr></table></figure>

<p>使用<strong>kv</strong>语言：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> kivy.app <span class="keyword">import</span> App</span><br><span class="line"><span class="keyword">from</span> kivy.lang <span class="keyword">import</span> Builder</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root = Builder.load_string(<span class="string">'''</span></span><br><span class="line"><span class="string">FloatLayout:</span></span><br><span class="line"><span class="string">    canvas.before:</span></span><br><span class="line"><span class="string">        Color:</span></span><br><span class="line"><span class="string">            rgba: 0, 1, 0, 1</span></span><br><span class="line"><span class="string">        Rectangle:</span></span><br><span class="line"><span class="string">            # self here refers to the widget i.e FloatLayout</span></span><br><span class="line"><span class="string">            pos: self.pos</span></span><br><span class="line"><span class="string">            size: self.size</span></span><br><span class="line"><span class="string">    Button:</span></span><br><span class="line"><span class="string">        text: 'Hello World!!'</span></span><br><span class="line"><span class="string">        size_hint: .5, .5</span></span><br><span class="line"><span class="string">        pos_hint: &#123;'center_x':.5, 'center_y': .5&#125;</span></span><br><span class="line"><span class="string">'''</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainApp</span><span class="params">(App)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    MainApp().run()</span><br></pre></td></tr></table></figure>
<p>这两个应用程序应如下所示：</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3Kmyv9.png" alt="3Kmyv9.png"></p>
<h4 id="向自定义布局规则-类的背景添加颜色"><a href="#向自定义布局规则-类的背景添加颜色" class="headerlink" title="向自定义布局规则/类的背景添加颜色"></a>向自定义布局规则/类的背景添加颜色</h4><p>如果我们需要使用多个布局，那么将背景添加到布局实例的方法很快就会变得很麻烦。 为了解决这个问题，您可以将Layout子类化，并创建自己的添加背景的布局。</p>
<p>使用<strong>Python</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> kivy.app <span class="keyword">import</span> App</span><br><span class="line"><span class="keyword">from</span> kivy.graphics <span class="keyword">import</span> Color, Rectangle</span><br><span class="line"><span class="keyword">from</span> kivy.uix.boxlayout <span class="keyword">import</span> BoxLayout</span><br><span class="line"><span class="keyword">from</span> kivy.uix.floatlayout <span class="keyword">import</span> FloatLayout</span><br><span class="line"><span class="keyword">from</span> kivy.uix.image <span class="keyword">import</span> AsyncImage</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootWidget</span><span class="params">(BoxLayout)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomLayout</span><span class="params">(FloatLayout)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># make sure we aren't overriding any important functionality</span></span><br><span class="line">        super(CustomLayout, self).__init__(**kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> self.canvas.before:</span><br><span class="line">            Color(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>) <span class="comment"># green; colors range from 0-1 instead of 0-255</span></span><br><span class="line">            self.rect = Rectangle(size=self.size, pos=self.pos)</span><br><span class="line"></span><br><span class="line">        self.bind(size=self._update_rect, pos=self._update_rect)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_update_rect</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        self.rect.pos = instance.pos</span><br><span class="line">        self.rect.size = instance.size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainApp</span><span class="params">(App)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(self)</span>:</span></span><br><span class="line">        root = RootWidget()</span><br><span class="line">        c = CustomLayout()</span><br><span class="line">        root.add_widget(c)</span><br><span class="line">        c.add_widget(</span><br><span class="line">            AsyncImage(</span><br><span class="line">                source=<span class="string">"http://www.everythingzoomer.com/wp-content/uploads/2013/01/Monday-joke-289x277.jpg"</span>,</span><br><span class="line">                size_hint= (<span class="number">1</span>, <span class="number">.5</span>),</span><br><span class="line">                pos_hint=&#123;<span class="string">'center_x'</span>:<span class="number">.5</span>, <span class="string">'center_y'</span>:<span class="number">.5</span>&#125;))</span><br><span class="line">        root.add_widget(AsyncImage(source=<span class="string">'http://www.stuffistumbledupon.com/wpcontent/uploads/2012/05/Have-you-seen-this-dog-because-its-awesome-meme-puppy-doggy.jpg'</span>))</span><br><span class="line">        c = CustomLayout()</span><br><span class="line">        c.add_widget(</span><br><span class="line">            AsyncImage(</span><br><span class="line">                source=<span class="string">"http://www.stuffistumbledupon.com/wp-content/uploads/2012/04/Get-a-Girlfriend-Meme-empty-wallet.jpg"</span>,</span><br><span class="line">                size_hint= (<span class="number">1</span>, <span class="number">.5</span>),</span><br><span class="line">                pos_hint=&#123;<span class="string">'center_x'</span>:<span class="number">.5</span>, <span class="string">'center_y'</span>:<span class="number">.5</span>&#125;))</span><br><span class="line">        root.add_widget(c)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    MainApp().run()</span><br></pre></td></tr></table></figure>

<p>使用<strong>kv</strong>语言：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> kivy.app <span class="keyword">import</span> App</span><br><span class="line"><span class="keyword">from</span> kivy.uix.floatlayout <span class="keyword">import</span> FloatLayout</span><br><span class="line"><span class="keyword">from</span> kivy.uix.boxlayout <span class="keyword">import</span> BoxLayout</span><br><span class="line"><span class="keyword">from</span> kivy.lang <span class="keyword">import</span> Builder</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Builder.load_string(<span class="string">'''</span></span><br><span class="line"><span class="string">&lt;CustomLayout&gt;</span></span><br><span class="line"><span class="string">    canvas.before:</span></span><br><span class="line"><span class="string">        Color:</span></span><br><span class="line"><span class="string">            rgba: 0, 1, 0, 1</span></span><br><span class="line"><span class="string">        Rectangle:</span></span><br><span class="line"><span class="string">            pos: self.pos</span></span><br><span class="line"><span class="string">            size: self.size</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;RootWidget&gt;</span></span><br><span class="line"><span class="string">    CustomLayout:</span></span><br><span class="line"><span class="string">        AsyncImage:</span></span><br><span class="line"><span class="string">            source: 'http://www.everythingzoomer.com/wp-content/uploads/2013/01/Monday-joke-289x277.jpg'</span></span><br><span class="line"><span class="string">            size_hint: 1, .5</span></span><br><span class="line"><span class="string">            pos_hint: &#123;'center_x':.5, 'center_y': .5&#125;</span></span><br><span class="line"><span class="string">AsyncImage:</span></span><br><span class="line"><span class="string">    source: 'http://www.stuffistumbledupon.com/wp-content/uploads/2012/05/Have-you-seen-this-dog-because-its-awesome-meme-puppy-doggy.jpg'</span></span><br><span class="line"><span class="string">CustomLayout</span></span><br><span class="line"><span class="string">    AsyncImage:</span></span><br><span class="line"><span class="string">        source: 'http://www.stuffistumbledupon.com/wp-content/uploads/2012/04/Get-a-Girlfriend-Meme-empty-wallet.jpg'</span></span><br><span class="line"><span class="string">        size_hint: 1, .5</span></span><br><span class="line"><span class="string">        pos_hint: &#123;'center_x':.5, 'center_y': .5&#125;</span></span><br><span class="line"><span class="string">'''</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootWidget</span><span class="params">(BoxLayout)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomLayout</span><span class="params">(FloatLayout)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainApp</span><span class="params">(App)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> RootWidget()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    MainApp().run()</span><br></pre></td></tr></table></figure>

<p>这两个应用程序应如下所示：</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3K17Jx.png" alt="3K17Jx.png"></p>
<p>在自定义布局类中定义背景，以确保将在每个CustomLayout实例中使用它。</p>
<p>现在，要将图像或颜色全局添加到内置Kivy布局的背景中，我们需要覆盖相关布局的kv规则。 考虑GridLayout：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;GridLayout&gt;</span><br><span class="line">    canvas.before:</span><br><span class="line">        Color:</span><br><span class="line">            rgba: <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        BorderImage:</span><br><span class="line">            source: <span class="string">'../examples/widgets/sequenced_images/data/images/button_white.png'</span></span><br><span class="line">            pos: self.pos</span><br><span class="line">            size: self.size</span><br></pre></td></tr></table></figure>

<p>然后，当我们将此代码段放入Kivy应用程序中时：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> kivy.app <span class="keyword">import</span> App</span><br><span class="line"><span class="keyword">from</span> kivy.uix.floatlayout <span class="keyword">import</span> FloatLayout</span><br><span class="line"><span class="keyword">from</span> kivy.lang <span class="keyword">import</span> Builder</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Builder.load_string(<span class="string">'''</span></span><br><span class="line"><span class="string">&lt;GridLayout&gt;</span></span><br><span class="line"><span class="string">    canvas.before:</span></span><br><span class="line"><span class="string">        BorderImage:</span></span><br><span class="line"><span class="string">            # BorderImage behaves like the CSS BorderImage</span></span><br><span class="line"><span class="string">            border: 10, 10, 10, 10</span></span><br><span class="line"><span class="string">            source: '../examples/widgets/sequenced_images/data/images/button_white.png'</span></span><br><span class="line"><span class="string">            pos: self.pos</span></span><br><span class="line"><span class="string">            size: self.size</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;RootWidget&gt;</span></span><br><span class="line"><span class="string">    GridLayout:</span></span><br><span class="line"><span class="string">        size_hint: .9, .9</span></span><br><span class="line"><span class="string">        pos_hint: &#123;'center_x': .5, 'center_y': .5&#125;</span></span><br><span class="line"><span class="string">        rows:1</span></span><br><span class="line"><span class="string">        Label:</span></span><br><span class="line"><span class="string">            text: "I don't suffer from insanity, I enjoy every minute of it"</span></span><br><span class="line"><span class="string">            text_size: self.width-20, self.height-20</span></span><br><span class="line"><span class="string">            valign: 'top'</span></span><br><span class="line"><span class="string">        Label:</span></span><br><span class="line"><span class="string">            text: "When I was born I was so surprised; I didn't speak for a year and a half."</span></span><br><span class="line"><span class="string">            text_size: self.width-20, self.height-20</span></span><br><span class="line"><span class="string">            valign: 'middle'</span></span><br><span class="line"><span class="string">            halign: 'center'</span></span><br><span class="line"><span class="string">        Label:</span></span><br><span class="line"><span class="string">            text: "A consultant is someone who takes a subject you understand and makes it sound confusing"</span></span><br><span class="line"><span class="string">            text_size: self.width-20, self.height-20</span></span><br><span class="line"><span class="string">            valign: 'bottom'</span></span><br><span class="line"><span class="string">            halign: 'justify'</span></span><br><span class="line"><span class="string">'''</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootWidget</span><span class="params">(FloatLayout)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainApp</span><span class="params">(App)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> RootWidget()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    MainApp().run()</span><br></pre></td></tr></table></figure>

<p>结果应如下所示：</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3K3sne.png" alt="3K3sne.png"></p>
<p>当我们覆盖GridLayout类的规则时，在我们的应用程序中对此类的任何使用都会显示该图像。</p>
<p><strong>动画背景怎么样？</strong></p>
<p>您可以设置诸如Rectangle / BorderImage / Ellipse /之类的绘图指令。 。 。 使用特定的纹理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Rectangle:</span><br><span class="line">    texture: reference to a texture</span><br></pre></td></tr></table></figure>
<p>我们使用它来显示动画背景：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> kivy.app <span class="keyword">import</span> App</span><br><span class="line"><span class="keyword">from</span> kivy.uix.floatlayout <span class="keyword">import</span> FloatLayout</span><br><span class="line"><span class="keyword">from</span> kivy.uix.gridlayout <span class="keyword">import</span> GridLayout</span><br><span class="line"><span class="keyword">from</span> kivy.uix.image <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> kivy.properties <span class="keyword">import</span> ObjectProperty</span><br><span class="line"><span class="keyword">from</span> kivy.lang <span class="keyword">import</span> Builder</span><br><span class="line"></span><br><span class="line">Builder.load_string(<span class="string">'''</span></span><br><span class="line"><span class="string">    &lt;CustomLayout&gt;</span></span><br><span class="line"><span class="string">        canvas.before:</span></span><br><span class="line"><span class="string">            BorderImage:</span></span><br><span class="line"><span class="string">                # BorderImage behaves like the CSS BorderImage</span></span><br><span class="line"><span class="string">                border: 10, 10, 10, 10</span></span><br><span class="line"><span class="string">                texture: self.background_image.texture</span></span><br><span class="line"><span class="string">                pos: self.pos</span></span><br><span class="line"><span class="string">                size: self.size</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;RootWidget&gt;</span></span><br><span class="line"><span class="string">    CustomLayout:</span></span><br><span class="line"><span class="string">        size_hint: .9, .9</span></span><br><span class="line"><span class="string">        pos_hint: &#123;'center_x': .5, 'center_y': .5&#125;</span></span><br><span class="line"><span class="string">        rows:1</span></span><br><span class="line"><span class="string">        Label:</span></span><br><span class="line"><span class="string">            text: "I don't suffer from insanity, I enjoy every minute of it"</span></span><br><span class="line"><span class="string">            text_size: self.width-20, self.height-20</span></span><br><span class="line"><span class="string">            valign: 'top'</span></span><br><span class="line"><span class="string">        Label:</span></span><br><span class="line"><span class="string">            text: "When I was born I was so surprised; I didn't speak for a year and a half."</span></span><br><span class="line"><span class="string">            text_size: self.width-20, self.height-20</span></span><br><span class="line"><span class="string">            valign: 'middle'</span></span><br><span class="line"><span class="string">            halign: 'center'</span></span><br><span class="line"><span class="string">        Label:</span></span><br><span class="line"><span class="string">            text: "A consultant is someone who takes a subject you understand and makes it sound confusing"</span></span><br><span class="line"><span class="string">text_size: self.width-20, self.height-20</span></span><br><span class="line"><span class="string">            valign: 'bottom'</span></span><br><span class="line"><span class="string">            halign: 'justify'</span></span><br><span class="line"><span class="string">'''</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomLayout</span><span class="params">(GridLayout)</span>:</span></span><br><span class="line"></span><br><span class="line">    background_image = ObjectProperty(</span><br><span class="line">        Image(</span><br><span class="line">            source=<span class="string">'../examples/widgets/sequenced_images/data/images/button_white_animated.zip'</span>,</span><br><span class="line">            anim_delay=<span class="number">.1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootWidget</span><span class="params">(FloatLayout)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainApp</span><span class="params">(App)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> RootWidget()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    MainApp().run()</span><br></pre></td></tr></table></figure>
<p>要尝试了解此处发生的情况，请从第13行开始：</p>
<p><code>texture: self.background_image.texture</code></p>
<p>这指定每当<em>background_image</em>的<em>texture</em>属性更新时，<em>BorderImage</em>的<em>texture</em>属性将被更新。 我们在第40行定义<em>background_image</em>属性：</p>
<p><code>background_image = ObjectProperty(...</code></p>
<p>这会将background_image设置为ObjectProperty，在其中添加Image小部件。 图像小部件具有纹理属性； 在其中看到<code>self.background_image.texture</code>的位置，它为此属性设置了一个引用（纹理）。 “图像”小部件支持动画：动画更改后，图像的纹理就会更新，而BorderImage指令的纹理会在此过程中更新。</p>
<p>您也可以将自定义数据混入纹理中。 有关详细信息，请参见Texture的文档。</p>
<h3 id="嵌套布局"><a href="#嵌套布局" class="headerlink" title="嵌套布局"></a>嵌套布局</h3><p>是! 看到这个过程可以扩展是很有趣的。</p>
<h3 id="大小和位置指标"><a href="#大小和位置指标" class="headerlink" title="大小和位置指标"></a>大小和位置指标</h3><p>Kivy的默认长度单位是像素，默认情况下所有尺寸和位置均以像素为单位。 您可以用其他单位表示它们，这对于在设备之间实现更好的一致性很有用（它们会自动转换为以像素为单位的大小）。</p>
<p>可用的单位是pt，mm，cm，inch，dp和sp。 您可以在指标文档中了解它们的用法。</p>
<p>您还可以尝试使用屏幕，以模拟应用程序的各种设备屏幕。</p>
<h3 id="使用屏幕管理器进行屏幕分离"><a href="#使用屏幕管理器进行屏幕分离" class="headerlink" title="使用屏幕管理器进行屏幕分离"></a>使用屏幕管理器进行屏幕分离</h3><p>如果您的应用程序由各种屏幕组成，则可能需要一种简单的方法来从一个屏幕导航到另一个屏幕。 幸运的是，这里有ScreenManager类，它允许您分别定义屏幕，以及将TransitionBase从一个设置为另一个。</p>
<h2 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h2><h3 id="画布介绍"><a href="#画布介绍" class="headerlink" title="画布介绍"></a>画布介绍</h3><p>AWidgets图形表示形式是使用画布呈现的，您可以将其视为无限的绘图板或一组绘图指令。 您可以将许多说明应用（添加）到画布上，但是有两个主要变化：</p>
<ul>
<li>上下文说明</li>
<li>顶点指令</li>
</ul>
<p>上下文指令不会绘制任何内容，但是会更改顶点指令的结果。</p>
<p>画布可以包含指令的两个子集。 它们是canvas.before和canvas。 在指导小组之后。 这些组中的指令将分别在canvas组之前和之后执行。 这意味着它们将出现在它们的下方（之前执行）和上方（之后执行）。 在用户访问它们之前，不会创建这些组。</p>
<p>要将画布指令添加到小部件，请使用画布上下文：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWidget</span><span class="params">(Widget)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        super(MyWidget, self).__init__(**kwargs)</span><br><span class="line">        <span class="keyword">with</span> self.canvas:</span><br><span class="line">            <span class="comment"># add your instruction for main canvas here</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> self.canvas.before:</span><br><span class="line">            <span class="comment"># you can use this to add instructions rendered before</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> self.canvas.after:</span><br><span class="line">            <span class="comment"># you can use this to add instructions rendered after</span></span><br></pre></td></tr></table></figure>

<h3 id="上下文说明"><a href="#上下文说明" class="headerlink" title="上下文说明"></a>上下文说明</h3><p>上下文指令可操纵opengl上下文。 您可以旋转，平移和缩放画布。 您还可以附加纹理或更改图形颜色。 这是最常用的一种，但其他一些也确实有用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with self.canvas.before:</span><br><span class="line">    Color(1, 0, .4, mode&#x3D;&#39;rgb&#39;)</span><br></pre></td></tr></table></figure>

<h3 id="图纸说明"><a href="#图纸说明" class="headerlink" title="图纸说明"></a>图纸说明</h3><p>绘制指令的范围从非常简单的指令（例如绘制直线或多边形）到更复杂的指令（例如网格或贝塞尔曲线）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> self.canvas:</span><br><span class="line">    <span class="comment"># draw a line using the default color</span></span><br><span class="line">    Line(points=(x1, y1, x2, y2, x3, y3))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># lets draw a semi-transparent red square</span></span><br><span class="line">    Color(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">.5</span>, mode=<span class="string">'rgba'</span>)</span><br><span class="line">    Rectangle(pos=self.pos, size=self.size)</span><br></pre></td></tr></table></figure>

<h3 id="操作说明"><a href="#操作说明" class="headerlink" title="操作说明"></a>操作说明</h3><p>有时您想更新或删除添加到画布的说明。 可以根据您的需要以各种方式完成此操作：</p>
<p>您可以保留您的说明的参考并进行更新：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWidget</span><span class="params">(Widget)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        super(MyWidget, self).__init__(**kwargs)</span><br><span class="line">        <span class="keyword">with</span> self.canvas:</span><br><span class="line">            self.rect = Rectangle(pos=self.pos, size=self.size)</span><br><span class="line"></span><br><span class="line">        self.bind(pos=self.update_rect)</span><br><span class="line">        self.bind(size=self.update_rect)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_rect</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">        self.rect.pos = self.pos</span><br><span class="line">        self.rect.size = self.size</span><br></pre></td></tr></table></figure>
<p>或者，您可以清洁画布并重新开始：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWidget</span><span class="params">(Widget)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        super(MyWidget, self).__init__(**kwargs)</span><br><span class="line">        self.draw_my_stuff()</span><br><span class="line"></span><br><span class="line">        self.bind(pos=self.draw_my_stuff)</span><br><span class="line">        self.bind(size=self.draw_my_stuff)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">draw_my_stuff</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">        self.canvas.clear()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> self.canvas:</span><br><span class="line">            self.rect = Rectangle(pos=self.pos, size=self.size)</span><br></pre></td></tr></table></figure>
<p>注意，更新指令被认为是最佳实践，因为它涉及较少的开销并且避免创建新指令。</p>
<h2 id="Kv-语言"><a href="#Kv-语言" class="headerlink" title="Kv 语言"></a>Kv 语言</h2><h3 id="语言背后的概念"><a href="#语言背后的概念" class="headerlink" title="语言背后的概念"></a>语言背后的概念</h3><p>随着您的应用程序变得越来越复杂，小部件树的构造和绑定的显式声明通常变得冗长且难以维护。 KV语言是一种克服这些缺点的尝试。</p>
<p>KV语言有时也称为kvlang或kivy语言，它允许您以声明性方式创建小部件树，并以自然方式将小部件属性彼此绑定或回调。 它允许非常快速的原型和对UI的灵活更改。 它还有助于分离应用程序逻辑及其用户界面。</p>
<h3 id="如何加载KV"><a href="#如何加载KV" class="headerlink" title="如何加载KV"></a>如何加载KV</h3><p>有两种方法可以将Kv代码加载到您的应用程序中：</p>
<ul>
<li><p>按照名称约定：</p>
<ul>
<li><p>Kivy会以小写形式查找与您的App类同名的Kv文件，如果以“ App”结尾则减去“ App”，例如：</p>
</li>
<li><p><code>MyApp -&gt; my.kv</code></p>
</li>
<li><p>如果此文件定义了Root Widget，它将附加到应用程序的root属性，并用作应用程序Widget树的基础。</p>
</li>
</ul>
</li>
<li><p><strong>Builder</strong>：您可以告诉Kivy直接加载字符串或文件。 如果此字符串或文件定义了根窗口小部件，则该方法将返回它：</p>
<ul>
<li><code>Builder.load_file(&#39;path/to/file.kv&#39;)</code></li>
<li>或：</li>
<li><code>Builder.load_string(kv_string)</code></li>
</ul>
</li>
</ul>
<h3 id="文本规则"><a href="#文本规则" class="headerlink" title="文本规则"></a>文本规则</h3><p>Kv源构成规则，用于描述Widget的内容。 您可以有一个根规则，也可以有任何数量的类或模板规则。</p>
<p>通过声明根窗口小部件的类（不带任何缩进）来声明根规则，后跟：，并将其设置为App实例的根属性：</p>
<p><code>Widget:</code></p>
<p>一个类规则，由&lt;&gt;之间的小部件类的名称声明，后跟定义该类任何实例的外观和行为：</p>
<p><code>&lt;MyWidget&gt;:</code></p>
<p>规则使用缩进来进行分隔，例如Python。 缩进每个级别应为四个空格，如Python样式指南所建议。</p>
<p>以下是Kv语言专用的三个关键字：</p>
<ul>
<li><em>app</em>：始终引用您的应用程序的实例。</li>
<li><em>root</em>：指当前规则中的基本窗口小部件/模板</li>
<li><em>self</em>：始终引用当前小部件</li>
</ul>
<h3 id="特殊语法"><a href="#特殊语法" class="headerlink" title="特殊语法"></a>特殊语法</h3><p>有一种特殊的语法可以定义整个Kv上下文的值。</p>
<p>要从kv访问Python模块和类，请使用＃：import</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#:import name x.y.z</span></span><br><span class="line"><span class="comment">#:import isdir os.path.isdir</span></span><br><span class="line"><span class="comment">#:import np numpy</span></span><br></pre></td></tr></table></figure>
<p>等效于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> x.y <span class="keyword">import</span> z <span class="keyword">as</span> name</span><br><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> isdir</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>
<p>在Python中。</p>
<p>要设置全局值，请使用＃：set</p>
<p><code>#:set name value</code></p>
<p>等效于：</p>
<p><code>name = value</code></p>
<p>在 Python 里面</p>
<h3 id="实例化孩子"><a href="#实例化孩子" class="headerlink" title="实例化孩子"></a>实例化孩子</h3><p>要将某个类的窗口小部件实例声明为子窗口小部件，只需在规则内声明该孩子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MyRootWidget:</span><br><span class="line">    BoxLayout:</span><br><span class="line">        Button:</span><br><span class="line">        Button:</span><br></pre></td></tr></table></figure>
<p>上面的示例定义了我们的根窗口小部件，即MyRootWidget的实例，具有一个作为BoxLayout实例的子级，并且BoxLayout进一步具有了两个子级，即Button类的实例。</p>
<p>此代码的Python等效项可能是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">root = MyRootWidget()</span><br><span class="line">box = BoxLayout()</span><br><span class="line">box.add_widget(Button())</span><br><span class="line">box.add_widget(Button())</span><br><span class="line">root.add_widget(box)</span><br></pre></td></tr></table></figure>
<p>您可能会发现阅读和书写都不太好。</p>
<p>当然，在Python中，您可以在创建小部件时将关键字参数传递给小部件以指定其行为。 例如，要设置网格布局的列数，我们将执行以下操作：</p>
<p><code>grid = GridLayout(cols=3)</code></p>
<p>要在kv中执行相同的操作，可以直接在规则中设置子窗口小部件的属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">GridLayout:</span><br><span class="line">    cols: <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>该值作为Python表达式求值，并且表达式中使用的所有属性都将被观察，这意味着，如果您在Python中有类似的东西（假定self是具有数据ListProperty的小部件）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">grid = GridLayout(cols=len(self.data))</span><br><span class="line">self.bind(data=grid.setter(<span class="string">'cols'</span>))</span><br></pre></td></tr></table></figure>
<p>要在数据更改时更新显示，现在可以执行以下操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">GridLayout:</span><br><span class="line">    cols: len(root.data)</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>注意：窗口小部件名称应以大写字母开头，而属性名称应以小写字母开头。 鼓励遵循PEP8命名约定。</strong></p>
<hr>
<h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><p>您可以使用“：”语法绑定到Kv中的事件，即将回调与事件相关联：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Widget:</span><br><span class="line">    on_size: my_callback()</span><br></pre></td></tr></table></figure>
<p>您可以使用args关键字传递信号分配的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TextInput:</span><br><span class="line">    on_text: app.search(args[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>可以使用更复杂的表达式，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pos: self.center_x - self.texture_size[<span class="number">0</span>] / <span class="number">2.</span>, self.center_y - self.texture_size[<span class="number">1</span>] / <span class="number">2.</span></span><br></pre></td></tr></table></figure>
<p>此表达式侦听center_x，center_y和texture_size的更改。 如果其中之一发生更改，则将重新计算表达式以更新pos字段。</p>
<p>您还可以在kv语言中处理on_事件。 例如，TextInput类具有focus属性，可以在kv语言内部访问自动生成的on_focus事件，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TextInput:</span><br><span class="line">    on_focus: print(args)</span><br></pre></td></tr></table></figure>

<h3 id="延伸画布"><a href="#延伸画布" class="headerlink" title="延伸画布"></a>延伸画布</h3><p>Kv lang可以用来定义小部件的画布指令，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MyWidget:</span><br><span class="line">    canvas:</span><br><span class="line">        Color:</span><br><span class="line">            rgba: <span class="number">1</span>, <span class="number">.3</span>, <span class="number">.8</span>, <span class="number">.5</span></span><br><span class="line">        Line:</span><br><span class="line">            points: zip(self.data.x, self.data.y)</span><br></pre></td></tr></table></figure>
<p>当属性值更改时，它们也会更新。</p>
<p>当然，您可以使用canvas.before和canvas.after。</p>
<h3 id="引用小部件"><a href="#引用小部件" class="headerlink" title="引用小部件"></a>引用小部件</h3><p>在小部件树中，通常需要访问/引用其他小部件。 Kv语言提供了一种使用ID的方法。 将它们视为只能在Kv语言中使用的类级别变量。 考虑以下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;MyFirstWidget&gt;:</span><br><span class="line">    Button:</span><br><span class="line">        id: f_but</span><br><span class="line">    TextInput:</span><br><span class="line">        text: f_but.state</span><br><span class="line">&lt;MySecondWidget&gt;:</span><br><span class="line">    Button:</span><br><span class="line">        id: s_but</span><br><span class="line">    TextInput:</span><br><span class="line">        text: s_but.state</span><br></pre></td></tr></table></figure>
<p>id的范围仅限于声明它的规则，因此在s_上面的代码中，但不能在<MySecondWidget>规则之外进行访问。</MySecondWidget></p>
<hr>
<p>警告：为ID分配值时，请记住该值不是字符串。 没有引号：好-&gt; id：值，差-&gt; id：“值”</p>
<hr>
<p>id是对窗口小部件的弱引用，而不是窗口小部件本身。 结果，存储id不足以防止小部件被垃圾回收。 展示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;MyWidget&gt;:</span><br><span class="line">    label_widget: label_widget</span><br><span class="line">    Button:</span><br><span class="line">        text: <span class="string">'Add Button'</span></span><br><span class="line">        on_press: root.add_widget(label_widget)</span><br><span class="line">    Button:</span><br><span class="line">        text: <span class="string">'Remove Button'</span></span><br><span class="line">        on_press: root.remove_widget(label_widget)</span><br><span class="line">    Label:</span><br><span class="line">        id: label_widget</span><br><span class="line">        text: <span class="string">'widget'</span></span><br></pre></td></tr></table></figure>
<p>尽管对Label_widget的引用存储在MyWidget中，但是一旦其他引用被删除，仅使对象保持活动状态是不够的，因为它只是一个weakref。 因此，单击删除按钮（删除对窗口小部件的任何直接引用）并调整窗口大小（调用垃圾收集器，导致删除label_widget）后，单击添加按钮将窗口小部件重新添加后， ReferenceError：不再存在弱引用对象。</p>
<p>为了使小部件保持活动状态，必须保留对label_widget小部件的直接引用。 在这种情况下，使用<code>id .__ self__</code>或<code>label_widget .__ self__</code>实现。 正确的方法是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;MyWidget&gt;:</span><br><span class="line">    label_widget: label_widget.__self__</span><br></pre></td></tr></table></figure>

<h3 id="在您的Python代码中访问在Kv-lang内部定义的小部件"><a href="#在您的Python代码中访问在Kv-lang内部定义的小部件" class="headerlink" title="在您的Python代码中访问在Kv lang内部定义的小部件"></a>在您的Python代码中访问在Kv lang内部定义的小部件</h3><p>请考虑以下my.kv中的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;MyFirstWidget&gt;:</span><br><span class="line">    <span class="comment"># both these variables can be the same name and this doesn't lead to</span></span><br><span class="line">    <span class="comment"># an issue with uniqueness as the id is only accessible in kv.</span></span><br><span class="line">    txt_inpt: txt_inpt</span><br><span class="line">    Button:</span><br><span class="line">        id: f_but</span><br><span class="line">    TextInput:</span><br><span class="line">        id: txt_inpt</span><br><span class="line">        text: f_but.state</span><br><span class="line">        on_text: root.check_status(f_but)</span><br></pre></td></tr></table></figure>
<p>在myapp.py中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFirstWidget</span><span class="params">(BoxLayout)</span>:</span></span><br><span class="line"></span><br><span class="line">    txt_inpt = ObjectProperty(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_status</span><span class="params">(self, btn)</span>:</span></span><br><span class="line">        print(<span class="string">'button state is: &#123;state&#125;'</span>.format(state=btn.state))</span><br><span class="line">        print(<span class="string">'text input text is: &#123;txt&#125;'</span>.format(txt=self.txt_inpt))</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>txt_inpt</code>定义为在类内部初始化为None的ObjectProperty。</p>
<p><code>txt_inpt = ObjectProperty(None)</code></p>
<p>此时self.txt_inpt为None。 在Kv lang中，此属性已更新，以保存ID txt_inpt引用的TextInput实例：</p>
<p><code>txt_inpt: txt_inpt</code></p>
<p>从那时起，self.txt_inpt包含对由ID txt_input标识的窗口小部件的引用，并且可以在类中的任何位置使用，例如在函数check_status中。 与这种方法相比，您也可以将id传递给需要使用它的函数，例如在f_but的情况下，在上面的代码中。</p>
<p>有一种使用id查找对象访问Kv中带有id标签的对象的简单方法。 您可以按照以下步骤进行操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;Marvel&gt;</span><br><span class="line">    Label:</span><br><span class="line">        id: loki</span><br><span class="line">        text: <span class="string">'loki: I AM YOUR GOD!'</span></span><br><span class="line">    Button:</span><br><span class="line">        id: hulk</span><br><span class="line">        text: <span class="string">"press to smash loki"</span></span><br><span class="line">        on_release: root.hulk_smash()</span><br></pre></td></tr></table></figure>
<p>在您的Python代码中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Marvel</span><span class="params">(BoxLayout)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hulk_smash</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.ids.hulk.text = <span class="string">"hulk: puny god!"</span></span><br><span class="line">        self.ids[<span class="string">"loki"</span>].text = <span class="string">"loki: &gt;_&lt;!!!"</span> <span class="comment"># alternative syntax</span></span><br></pre></td></tr></table></figure>
<p>解析您的kv文件后，kivy会收集所有标有id的小部件，并将它们放在此self.ids字典类型属性中。 这意味着您还可以遍历这些小部件并访问它们的字典样式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key, val <span class="keyword">in</span> self.ids.items():</span><br><span class="line">    print(<span class="string">"key=&#123;0&#125;, val=&#123;1&#125;"</span>.format(key, val))</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>注意：尽管self.ids方法非常简洁，但是使用ObjectProperty通常被视为“最佳实践”。 这将创建直接引用，提供更快的访问权限，并且更加明确。</strong></p>
<hr>
<h3 id="动态类"><a href="#动态类" class="headerlink" title="动态类"></a>动态类</h3><p>考虑下面的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;MyWidget&gt;:</span><br><span class="line">    Button:</span><br><span class="line">        text: <span class="string">"Hello world, watch this text wrap inside the button"</span></span><br><span class="line">        text_size: self.size</span><br><span class="line">        font_size: <span class="string">'25sp'</span></span><br><span class="line">        markup: <span class="literal">True</span></span><br><span class="line">    Button:</span><br><span class="line">        text: <span class="string">"Even absolute is relative to itself"</span></span><br><span class="line">        text_size: self.size</span><br><span class="line">        font_size: <span class="string">'25sp'</span></span><br><span class="line">        markup: <span class="literal">True</span></span><br><span class="line">    Button:</span><br><span class="line">        text: <span class="string">"Repeating the same thing over and over in a comp = fail"</span></span><br><span class="line">        text_size: self.size</span><br><span class="line">        font_size: <span class="string">'25sp'</span></span><br><span class="line">        markup: <span class="literal">True</span></span><br><span class="line">    Button:</span><br></pre></td></tr></table></figure>
<p>不必为每个按钮重复相同的值，我们只需使用模板即可，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;MyBigButt@Button&gt;:</span><br><span class="line">    text_size: self.size</span><br><span class="line">    font_size: <span class="string">'25sp'</span></span><br><span class="line">    markup: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">&lt;MyWidget&gt;:</span><br><span class="line">    MyBigButt:</span><br><span class="line">    text: <span class="string">"Hello world, watch this text wrap inside the button"</span></span><br><span class="line">MyBigButt:</span><br><span class="line">    text: <span class="string">"Even absolute is relative to itself"</span></span><br><span class="line">MyBigButt:</span><br><span class="line">    text: <span class="string">"repeating the same thing over and over in a comp = fail"</span></span><br><span class="line">MyBigButt:</span><br></pre></td></tr></table></figure>
<p>仅通过声明该规则而创建的此类继承自Button类，并允许我们更改其所有实例的默认值并创建绑定，而无需在Python端添加任何新代码。</p>
<h3 id="在多个小部件中重复使用样式"><a href="#在多个小部件中重复使用样式" class="headerlink" title="在多个小部件中重复使用样式"></a>在多个小部件中重复使用样式</h3><p>请考虑以下my.kv中的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;MyFirstWidget&gt;:</span><br><span class="line">    Button:</span><br><span class="line">        on_press: root.text(txt_inpt.text)</span><br><span class="line">    TextInput:</span><br><span class="line">        id: txt_inpt</span><br><span class="line"></span><br><span class="line">&lt;MySecondWidget&gt;:</span><br><span class="line">    Button:</span><br><span class="line">        on_press: root.text(txt_inpt.text)</span><br><span class="line">    TextInput:</span><br><span class="line">        id: txt_inpt</span><br></pre></td></tr></table></figure>
<p>在myapp.py中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFirstWidget</span><span class="params">(BoxLayout)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">text</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        print(<span class="string">'text input text is: &#123;txt&#125;'</span>.format(txt=val))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySecondWidget</span><span class="params">(BoxLayout)</span>:</span></span><br><span class="line"></span><br><span class="line">    writing = StringProperty(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">text</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        self.writing = val</span><br></pre></td></tr></table></figure>
<p>因为两个类共享相同的.kv样式，所以如果我们对两个小部件都使用该样式，则可以简化此设计。 您可以在.kv中执行以下操作。 在my.kv中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;MyFirstWidget,MySecondWidget&gt;:</span><br><span class="line">    Button:</span><br><span class="line">        on_press: root.text(txt_inpt.text)</span><br><span class="line">    TextInput:</span><br><span class="line">        id: txt_inpt</span><br></pre></td></tr></table></figure>
<p>通过用逗号分隔类名，声明中列出的所有类将具有相同的kv属性。</p>
<h3 id="使用Kivy语言进行设计"><a href="#使用Kivy语言进行设计" class="headerlink" title="使用Kivy语言进行设计"></a>使用Kivy语言进行设计</h3><p>Kivy语言的目的之一是将表示和逻辑的关注点分开。 表示（布局）端由您的kv文件解决，逻辑由您的.py文件解决。</p>
<h4 id="代码放在py文件中"><a href="#代码放在py文件中" class="headerlink" title="代码放在py文件中"></a>代码放在py文件中</h4><p>让我们从一个小例子开始：一个名为main.py的Python文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kivy</span><br><span class="line">kivy.require(<span class="string">'1.0.5'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> kivy.uix.floatlayout <span class="keyword">import</span> FloatLayout</span><br><span class="line"><span class="keyword">from</span> kivy.app <span class="keyword">import</span> App</span><br><span class="line"><span class="keyword">from</span> kivy.properties <span class="keyword">import</span> ObjectProperty, StringProperty</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controller</span><span class="params">(FloatLayout)</span>:</span></span><br><span class="line">    <span class="string">'''Create a controller that receives a custom widget from the kv lang file.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Add an action to be called from the kv lang file.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    label_wid = ObjectProperty()</span><br><span class="line">    info = StringProperty()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_action</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.label_wid.text = <span class="string">'My label after button press'</span></span><br><span class="line">        self.info = <span class="string">'New info text'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ControllerApp</span><span class="params">(App)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Controller(info=<span class="string">'Hello world'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ControllerApp().run()</span><br></pre></td></tr></table></figure>
<p>在此示例中，我们将创建具有2个属性的Controller类：</p>
<ul>
<li>有关接收一些文本的信息</li>
<li>label_wid用于接收标签小部件</li>
</ul>
<p>另外，我们正在创建将使用这两个属性的do_action（）方法。 它将更改信息文本并更改label_wid小部件中的文本。</p>
<h4 id="布局进入controller-kv"><a href="#布局进入controller-kv" class="headerlink" title="布局进入controller.kv"></a>布局进入controller.kv</h4><p>在没有相应的.kv文件的情况下执行该应用程序将可以工作，但是屏幕上将不会显示任何内容。 这是预料之中的，因为Controller类中没有小部件，所以它只是一个FloatLayout。 我们可以围绕Controller类在名为controller.kv的文件中创建UI，该文件将在我们运行ControllerApp时加载。 kivy.app.App.load_kv（）方法中描述了如何完成此操作以及加载了哪些文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#:kivy 1.0</span></span><br><span class="line"></span><br><span class="line">&lt;Controller&gt;:</span><br><span class="line">    label_wid: my_custom_label</span><br><span class="line"></span><br><span class="line">    BoxLayout:</span><br><span class="line">        orientation: <span class="string">'vertical'</span></span><br><span class="line">        padding: <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    Button:</span><br><span class="line">        text: <span class="string">'My controller info is: '</span> + root.info</span><br><span class="line">        on_press: root.do_action()</span><br><span class="line"></span><br><span class="line">    Label:</span><br><span class="line">        id: my_custom_label</span><br><span class="line">        text: <span class="string">'My label before button press'</span></span><br></pre></td></tr></table></figure>
<p>垂直BoxLayout中的一个标签和一个按钮。 似乎很简单。 这里发生三件事：</p>
<p>1.使用控制器中的数据。 在控制器中更改info属性后，表达式文本：“我的控制器信息为：” + root.info将自动重新评估，从而更改Button中的文本。</p>
<p>2.将数据提供给控制器。 表达式ID：my_custom_label分配了创建的Label my_custom_label的ID。 然后，在表达式label_wid中使用my_custom_label：my_custom_label将Label小部件的实例提供给Controller。</p>
<p>3.使用Controller的on_press方法在Button中创建自定义回调。</p>
<ul>
<li>root和self是保留关键字，可在任何地方使用。 root表示规则中的顶部小部件，self表示当前小部件。</li>
<li>您可以使用规则中声明的任何ID，与root和self相同。 例如，您可以在on_press（）中执行此操作：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Button:</span><br><span class="line">    on_press: root.do_action(); my_custom_label.font_size = <span class="number">18</span></span><br></pre></td></tr></table></figure>
就是这样。 现在，当我们运行main.py时，将加载controller.kv，以便出现Button和Label并响应我们的触摸事件。</li>
</ul>
<hr>
<p><strong>下一篇<span class="exturl" data-url="aHR0cDovL3d3dy5zaHVvc2h1b3l1bi5jbi9hcmNoaXZlcy80ODM4NS5odG1s">《Kivy参考文档（三）》<i class="fa fa-external-link-alt"></i></span></strong></p>
<hr>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Kivy</category>
      </categories>
      <tags>
        <tag>kivy</tag>
      </tags>
  </entry>
  <entry>
    <title>Kivy参考文档（一）</title>
    <url>/2020/02/12/48385/</url>
    <content><![CDATA[<p>版本2.0.0.dev0</p>
<p><strong>本文机器翻译，仅供个人参考，详情请看</strong><br><span class="exturl" data-url="aHR0cDovL3d3dy5raXZ5Lm9yZw==">官网地址<i class="fa fa-external-link-alt"></i></span></p>
<p>欢迎使用Kivy的文档。 Kivy是一个用于快速开发的开源软件库配备新颖用户界面的应用程序，例如多点触控应用程序。</p>
<p>我们建议您开始使用入门。然后转到<a href="#1.1">《编程指南》</a>。我们<br>如果您不耐烦，也可以<a href="#2.0">创建一个应用程序</a>。</p>
<p>您可能想知道为什么您应该对使用Kivy感兴趣。 有一份文件概述我们鼓励您阅读我们的哲学，以及详细的体系结构概述。</p>
<p>如果您想为Kivy做出贡献，请务必阅读Contributing。 如果您的疑虑未在文档，请随时与我们联系。</p>
<a id="more"></a>

<h1 id="第一部分-KIVY-项目"><a href="#第一部分-KIVY-项目" class="headerlink" title="第一部分 KIVY 项目"></a>第一部分 KIVY 项目</h1><p>文档的这一部分说明了Kivy设计的基本思想以及为什么要这么用它。</p>
<h2 id="哲学"><a href="#哲学" class="headerlink" title="哲学"></a>哲学</h2><p>如果您想知道Kivy到底是什么，以及它与其他解决方案的不同之处，这文件适合您。</p>
<h3 id="何必？"><a href="#何必？" class="headerlink" title="何必？"></a>何必？</h3><p>您为什么要使用Kivy？ 毕竟，有很多很棒的工具包（或框架或平台）免费提供。 您有Qt和Flash，仅举两个应用程序的不错选择发展。 这些众多解决方案中的许多解决方案已经支持Multi-Touch，那么它的作用是什么？奇异果特别值得一用吗？</p>
<h4 id="新鲜"><a href="#新鲜" class="headerlink" title="新鲜"></a>新鲜</h4><p>Kivy是为今天和明天制作的。 诸如Multi-Touch之类的新颖输入法已经越来越多重要。 我们从头开始创建Kivy，专门用于这种交互。 这意味着我们能够从人机交互的角度重新思考许多事情，而较旧的（并非意味着“过时的”，而不是“完善的”）工具包具有其传统，这通常是一种负担。 我们没有尝试迫使这种使用计算机的新方法成为现有模型的紧身胸衣（例如单指针）鼠标互动）。 我们希望让它蓬勃发展，并让您探索各种可能性。 这才是真正的使Kivy与众不同。</p>
<h4 id="快速"><a href="#快速" class="headerlink" title="快速"></a>快速</h4><p>Kivy很快。 这适用于应用程序开发和应用程序执行速度。 我们已经优化Kivy在很多方面。 我们在C层上实现了对时间要求严格的功能，以利用现有编译器的功能。更重要的是，我们还使用智能算法将成本降到最低操作。在我们的上下文中，我们也会在有意义的地方使用GPU。 计算能力在某些任务和算法方面，当今的图形卡的数量远远超过了当今的CPU。画画。 这就是为什么我们尝试让GPU尽可能多地完成工作，从而增加性能相当。</p>
<h4 id="灵活"><a href="#灵活" class="headerlink" title="灵活"></a>灵活</h4><p>Kivy非常灵活。 这意味着它可以在各种不同的设备上运行，包括Android驱动的智能手机和平板电脑。 我们支持所有主要操作系统（Windows，Linux，OS X）。 灵活一点也意味着Kivy的快速发展使其可以迅速适应新技术。 多于曾经，我们增加了对新的外部设备和软件协议的支持，有时甚至他们被释放了。 最后，Kivy的灵活性还在于它可以与多种不同的第三方解决方案。 例如，在Windows上，我们支持WM_TOUCH，意味着任何具有Windows 7 Pen＆Touch驱动程序的设备都可以与Kivy一起使用。 在OS X上您可以使用Apple具备Multi-Touch功能的设备，例如触控板和鼠标。 在Linux上，您可以使用HID内核输入事件。 除此之外，我们还支持TUIO（有形用户界面对象）和其他输入源的数量。</p>
<h4 id="专注"><a href="#专注" class="headerlink" title="专注"></a>专注</h4><p>Kivy专注。 您可以用几行代码编写一个简单的应用程序。 创建Kivy程序使用Python编程语言，该语言具有广泛的功能和强大的功能，而且易于使用。 在此外，我们创建了自己的描述语言，即Kivy语言，用于创建复杂的用户接口。 使用该语言，您可以快速设置，连接和安排应用程序元素。我们认为，让您专注于应用程序的本质比强制更重要您将摆弄编译器设置。 我们减轻了您的负担。</p>
<h4 id="已资助"><a href="#已资助" class="headerlink" title="已资助"></a>已资助</h4><p>Kivy由其领域的专业人员积极开发。 Kivy是受社区影响的专业人士开发和商业支持的解决方案。 我们的一些核心开发人员开发Kivy是为了活的。 Kivy在这里停留。 这不是一个很小的消失的学生项目。</p>
<h4 id="免费"><a href="#免费" class="headerlink" title="免费"></a>免费</h4><p>Kivy是免费使用。 您不必为此付费。 如果您要赚钱，甚至不用付费通过销售使用Kivy的应用程序赚钱。</p>
<h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><p>您可以通过多种方式为Kivy做出贡献。代码补丁只是其中的一件事您可以提交以帮助该项目的其他项目。我们也欢迎您提供反馈，错误报告，功能要求，文档改进，广告和宣传，测试，图形贡献等其他想法。如果您想提供帮助，请与我们联系，我们将为您提供帮助。</p>
<h3 id="讨论区"><a href="#讨论区" class="headerlink" title="讨论区"></a>讨论区</h3><p>关于Kivy开发的讨论发生在Github的问题上，并拉动了对特定事物的要求。对于两者都不适合的问题，讨论会在<span class="exturl" data-url="aHR0cHM6Ly9jaGF0Lmtpdnkub3JnLw==">#dev Discord频道<i class="fa fa-external-link-alt"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9mb3J1bS8jIWZvcnVtL2tpdnktZGV2">kivy-dev<i class="fa fa-external-link-alt"></i></span>上进行谷歌组。 如果不确定如何捐款，请来寻求指导在进行构想之前，先确认您的构想是否适合项目。 如果您要-或提供支持-您可以加入<span class="exturl" data-url="aHR0cHM6Ly9jaGF0Lmtpdnkub3JnLw==">#support Discord频道<i class="fa fa-external-link-alt"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9mb3J1bS8jIWZvcnVtL2tpdnktdXNlcnM=">kivy-users谷歌论坛<i class="fa fa-external-link-alt"></i></span>。</p>
<h3 id="行为守则"><a href="#行为守则" class="headerlink" title="行为守则"></a>行为守则</h3><p>为了建立一个开放和欢迎的社区，我们作为贡献者和维护者需要确保参与我们的项目和我们的姐妹项目是无骚扰和积极的经历为了每一个。</p>
<p>因此，至关重要的是，所有互动都应以尊重，开放的态度进行和感激。有关这些准则的更全面讨论，请参阅<span class="exturl" data-url="aHR0cHM6Ly93d3cuY29udHJpYnV0b3ItY292ZW5hbnQub3JnL3ZlcnNpb24vMS80L2NvZGUtb2YtY29uZHVjdC5odG1s">贡献者盟约<i class="fa fa-external-link-alt"></i></span>。本文档提供了对您的期望的准确描述，两者都是核心开发人员或首次贡献者。</p>
<h3 id="反馈"><a href="#反馈" class="headerlink" title="反馈"></a>反馈</h3><p>到目前为止，这是做出贡献的最简单方法。如果您将Kivy用于自己的项目，不要犹豫，分享。显然，它不必是高级企业应用程序。 真是难以置信激发人们知道您使用您开发的东西以及它能使他们做什么的动机。如果你有您想告诉我们的事情，请不要犹豫。 屏幕截图和视频也非常欢迎！ 我们也对您入门时遇到的问题感兴趣。请感到鼓舞报告您遇到的任何障碍，例如缺少文档，误导性指示或类似内容。我们是完美主义者，所以即使是错字，也请告诉我们。</p>
<h3 id="报告问题"><a href="#报告问题" class="headerlink" title="报告问题"></a>报告问题</h3><p>如果发现任何错误，崩溃，段错误，缺少文档，拼写无效或很奇怪示例，请花2分钟报告此问题。</p>
<p>1.通过编辑将日志记录级别移至调试级别 <code>&lt;user_directory&gt;/.kivy/config.ini:</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[kivy]</span><br><span class="line">log_level &#x3D; debug</span><br></pre></td></tr></table></figure>
<p>2.再次执行您的代码，然后将完整的输出复制/粘贴到<span class="exturl" data-url="aHR0cDovL2dpc3QuZ2l0aHViLmNvbS/vvIzljIXmi6zmnaXoh6pLaXZ555qE5pel5b+X5ZKMcHl0aG9u">http://gist.github.com/，包括来自Kivy的日志和python<i class="fa fa-external-link-alt"></i></span> backtrace。</p>
<p>3.打开 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tpdnkva2l2eS9pc3N1ZXMv">https://github.com/kivy/kivy/issues/<i class="fa fa-external-link-alt"></i></span></p>
<p>4.设置您的问题的标题</p>
<p>5.确切说明要重现该问题的方法，并粘贴发布在其上的输出的链接 <span class="exturl" data-url="aHR0cDovL2dpc3QuZ2l0aHViLmNvbS8=">http://gist.github.com/<i class="fa fa-external-link-alt"></i></span></p>
<p>6.验证问题，您就完成了！</p>
<p>如果您愿意，也可以尝试解决该错误，并通过向我们发送补丁来做出贡献：）阅读下一节以了解如何执行此操作。</p>
<h3 id="代码贡献"><a href="#代码贡献" class="headerlink" title="代码贡献"></a>代码贡献</h3><p>代码贡献（补丁，新功能）是帮助项目发展的最明显方法。由于这很常见，因此请您遵循我们的工作流程以最有效地与我们合作。遵守我们的工作流程可确保您的贡献不会被遗忘或丢失。 还有你的名字将始终与您所做的更改相关联，这基本上意味着我们代码中的永恒声誉历史记录（如果您不想这样做，可以选择退出）。</p>
<h4 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h4><ul>
<li>如果尚未完成，请阅读<span class="exturl" data-url="aHR0cDovL3d3dy5weXRob24ub3JnL2Rldi9wZXBzL3BlcC0wMDA4Lw==">PEP8<i class="fa fa-external-link-alt"></i></span>有关python编码样式的信息。</li>
<li>像这样激活对git commit的pep8检查：</li>
</ul>
<p><code>make hook</code></p>
<p>这将通过pep8检查器传递添加到git临时区域（即将提交）的代码进行提交时进行编程，并确保没有引入pep8错误。 如果您这样做，提交将被拒绝：请更正错误，然后重试。</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ul>
<li>照顾性能问题：阅读<span class="exturl" data-url="aHR0cDovL3dpa2kucHl0aG9uLm9yZy9tb2luL1B5dGhvblNwZWVkL1BlcmZvcm1hbmNlVGlwcw==">Python性能提示<i class="fa fa-external-link-alt"></i></span></li>
<li>Kivy的cpu密集部分用cython编写：如果您要进行大量计算，请考虑也使用它。<h4 id="Git-amp-GitHub"><a href="#Git-amp-GitHub" class="headerlink" title="Git &amp; GitHub"></a>Git &amp; GitHub</h4>我们将git用作代码库的版本控制系统。 如果您从未使用过git或类似的工具DVCS（甚至任何VCS）之前，我们强烈建议您看一下有关可用于git在线。<span class="exturl" data-url="aHR0cDovL2Jvb2suZ2l0LXNjbS5jb20v">Git社区书<i class="fa fa-external-link-alt"></i></span>或<span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS92aWRlb3M=">Git视频<i class="fa fa-external-link-alt"></i></span>都是学习git的好方法。当我们说git是一个很棒的工具时，请相信我们。 乍一看似乎令人生畏，但过了一会儿（希望）像我们一样爱它。 但是，教给你git远远超出了本文的范围文献。</li>
</ul>
<p>此外，我们使用<span class="exturl" data-url="aHR0cDovL2dpdGh1Yi5jb20v">GitHub<i class="fa fa-external-link-alt"></i></span>托管代码。 在下文中，我们将假设您有一个（免费的）GitHub帐户。 虽然这部分是可选的，但它允许您的补丁程序与我们的补丁程序紧密集成上游代码库。 如果您不想使用GitHub，我们假设您知道自己在做什么无论如何。</p>
<h4 id="代码工作流程"><a href="#代码工作流程" class="headerlink" title="代码工作流程"></a>代码工作流程</h4><p>因此，这是从我们的工作流程开始的初始设置（您只需安装一次即可安装Kivy）。基本上，您会按照dev-install的安装说明进行操作，但是您不会克隆我们的存储库，你叉它。 步骤如下：</p>
<p>1.登录到GitHub</p>
<p>2.单击fork按钮，创建<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tpdnkva2l2eQ==">Kivy存储库<i class="fa fa-external-link-alt"></i></span>的fork。</p>
<p>3.将我们的存储库的分支克隆到计算机上。您的fork将具有git远程名称“origin”，您将进入“master”分支：</p>
<p><code>git clone https://github.com/username/kivy.git</code></p>
<p>4.编译并设置PYTHONPATH或安装（请参阅dev-install）。</p>
<p>5.安装我们的预提交钩子，以确保您的代码不违反我们的样式指南，方法是执行从克隆的根目录建立钩子。这将在任何时候运行我们的styleguide检查您进行提交，并且如果您更改的部分中有违规行为，您的提交将为流产了。修复并重试。</p>
<p>6.将Kivy仓库添加为远程资源：</p>
<p><code>git remote add kivy https://github.com/kivy/kivy.git</code></p>
<p>现在，无论何时要创建补丁，都可以按照以下步骤操作：</p>
<p>1.查看我们的错误跟踪器中是否有针对该修补程序或功能的故障单，并宣布您将如果还没有受让人，请继续研究。</p>
<p>2.在本地存储库中为该特定对象创建一个新的，命名适当的分支功能或错误修正。（为每个功能保留一个新分支，确保我们可以轻松地加入您所做的更改，而不会提取任何其他本不应该被提取的东西。）：</p>
<p><code>git checkout -b new_feature</code></p>
<p>3.修改代码以执行所需的操作（例如，对其进行修复）。</p>
<p>4.测试代码。 即使是较小的修复，也请尝试这样做。 你永远不知道你是否有引入了一些未经测试的怪异错误。</p>
<p>5.对每个修订或每个功能执行一次或多次最小的原子提交。 最小/原子意味着保持提交干净。不要提交逻辑上不属于的其他内容此修复程序或功能。这与每更改一行创建一个提交无关。 使用git必要时添加-p。</p>
<p>6.给每个提交一个适当的提交消息，以便其他不熟悉的人对此事，您应该对自己的改变有所了解。</p>
<p>7.对更改满意后，请拉动我们的上游存储库并进行合并与您的本地存储库。 我们可以拉您的东西，但是既然您确切知道更改后，您应该进行合并：</p>
<p><code>git pull kivy master</code></p>
<p>8.将本地分支推送到GitHub上的远程存储库中：</p>
<p><code>git push origin new_feature</code></p>
<p>9.通过GitHub中的按钮发送请求，其中包含您所做的更改的描述存储库的界面。（这就是我们最初分叉的原因。您的存储库已链接反对我们的。）</p>
<p><strong>警告：如果更改代码库中需要编译的部分，则将具有重新编译以使更改生效。make命令将执行此操作为您服务（如果您想知道它的作用，请参见Makefile）。如果您需要清洁当前目录从编译文件，执行<code>make clean</code>。如果你想摆脱一切不受版本控制的文件，请运行<code>make distclean</code>（警告：如果您进行更改，不受版本控制，此命令将删除它们！）</strong></p>
<p>现在，我们将收到您的拉取请求。我们将检查您的更改是否干净且合理（如果您在进行所有操作之前与我们进行了交谈，我们会告诉您是否有意义）。如果是这样的话，我们将拉动它们，您将立即获得业力。恭喜，您是英雄！</p>
<h3 id="文档贡献"><a href="#文档贡献" class="headerlink" title="文档贡献"></a>文档贡献</h3><h1 id="第二部分-编程指南"><a href="#第二部分-编程指南" class="headerlink" title="第二部分 编程指南"></a>第二部分 编程指南</h1><h2 id="Kivy-基础"><a href="#Kivy-基础" class="headerlink" title="Kivy 基础"></a><h2 id="1.1">Kivy 基础</h2></h2><h3 id="安装Kivy环境"><a href="#安装Kivy环境" class="headerlink" title="安装Kivy环境"></a>安装Kivy环境</h3><p>Kivy依赖于许多Python库，例如pygame，gstreamer，PIL，Cairo等。他们是并非全部都需要，但是根据您正在使用的平台，安装它们可能会很麻烦。对于在Windows和MacOS X上，我们提供了一个可移植的软件包，您可以将其解压缩并使用。</p>
<p>请查看以下页面之一，以获取详细的安装说明：</p>
<ul>
<li>安装windows</li>
<li>安装osx</li>
<li>安装linux</li>
<li>安装rpi</li>
</ul>
<p>另外，可以在此处找到开发版本的说明：</p>
<ul>
<li>安装<h3 id="创建一个应用程序"><a href="#创建一个应用程序" class="headerlink" title="创建一个应用程序"></a>创建一个应用程序</h3>创建kivy应用程序很简单：</li>
<li>子类化App类</li>
<li>实现其build（）方法，使其返回Widget实例（您的Widget树的根）</li>
<li>实例化此类，并调用其run（）方法。</li>
</ul>
<p>这是最小应用程序的示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kivy</span><br><span class="line">kivy.require(<span class="string">'1.0.6'</span>) <span class="comment"># replace with your current kivy version !</span></span><br><span class="line"><span class="keyword">from</span> kivy.app <span class="keyword">import</span> App</span><br><span class="line"><span class="keyword">from</span> kivy.uix.label <span class="keyword">import</span> Label</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span><span class="params">(App)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Label(text=<span class="string">'Hello world'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    MyApp().run()</span><br></pre></td></tr></table></figure>
<p>您可以将其保存到文本文件，例如main.py，然后运行它。</p>
<h3 id="Kivy-App生命周期"><a href="#Kivy-App生命周期" class="headerlink" title="Kivy App生命周期"></a>Kivy App生命周期</h3><p>首先，让我们熟悉Kivy应用的生命周期。</p>
<p><img src="https://s2.ax1x.com/2020/02/12/1b6xkn.png" alt="1b6xkn.png"></p>
<p>正如您在上面看到的，出于所有意图和目的，我们进入应用程序的入口是<code>run()</code>方法，在我们的例子中是<code>MyApp().run()</code>。 我们将回到这一点，但让我们从第三行开始：</p>
<p><code>from kivy.app import App</code></p>
<p>您的应用的基本类必须继承自该应用类。 它存在于<code>kivy_installation_dir/kivy/app.py</code>中。</p>
<hr>
<p><strong>注意：如果您想深入研究Kivy App类的功能，请继续打开该文件。我们鼓励您打开代码并仔细阅读。 Kivy基于Python，并使用Sphinx进行文档，因此每个类的文档都在实际文件中。</strong></p>
<hr>
<p>同样在第2行：</p>
<p><code>from kivy.uix.label import Label</code></p>
<p>这里要注意的一件事是软件包/类的布局方式。 uix模块是包含用户界面元素（如布局和小部件）的部分。</p>
<p>移至第5行：</p>
<p><code>class MyApp(App):</code></p>
<p>这是我们定义Kivy应用程序的基类的地方。 您只需要更改此行中应用程序MyApp的名称。</p>
<p>移至第7行：</p>
<p><code>def build(self):</code></p>
<p>如上图突出显示，显示了Kivy App生命周期，这是您可以在其中使用的功能应该初始化并返回您的Root Widget。这是我们在第8行上所做的：</p>
<p><code>return Label(text=&#39;Hello world&#39;)</code></p>
<p>在这里，我们使用文本“ Hello World”初始化Label并返回其实例。 此标签将成为根此应用程序的小部件。</p>
<hr>
<p><strong>注意：Python使用缩进来表示代码块，因此请注意，在提供的代码中上面的第9行，类和函数定义结束。</strong></p>
<hr>
<p>现在进入将使我们的应用程序在第11行和第12行运行的部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    MyApp().run()</span><br></pre></td></tr></table></figure>
<p>在这里，类<code>MyApp</code>被初始化并调用其<code>run()</code>方法。 这将初始化并启动我们的Kivy应用。</p>
<h3 id="运行应用程序"><a href="#运行应用程序" class="headerlink" title="运行应用程序"></a>运行应用程序</h3><p>要运行该应用程序，请按照您的操作系统的说明进行操作：</p>
<ul>
<li>Linux请按照以下说明在Linux上运行Kivy应用程序：</li>
</ul>
<p><code>$ python main.py</code></p>
<ul>
<li>Windows请按照以下说明在Windows上运行Kivy应用程序：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python main.py</span><br><span class="line"># or</span><br><span class="line">C:\appdir&gt;kivy.bat main.py</span><br></pre></td></tr></table></figure></li>
<li>Mac OS X请按照以下说明在OS X上运行Kivy应用程序：</li>
</ul>
<p><code>$ kivy main.py</code></p>
<p>Android您的应用程序需要一些补充文件才能在Android上运行。请参阅创建Android包以获取更多参考。</p>
<p>应打开一个窗口，显示一个覆盖整个标签的标签（带有“ Hello World”文本）窗口区域。 这里的所有都是它的。</p>
<h3 id="定制应用程序"><a href="#定制应用程序" class="headerlink" title="定制应用程序"></a>定制应用程序</h3><p>让我们扩展这个应用程序，例如一个简单的UserName / Password页面。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> kivy.app <span class="keyword">import</span> App</span><br><span class="line"><span class="keyword">from</span> kivy.uix.gridlayout <span class="keyword">import</span> GridLayout</span><br><span class="line"><span class="keyword">from</span> kivy.uix.label <span class="keyword">import</span> Label</span><br><span class="line"><span class="keyword">from</span> kivy.uix.textinput <span class="keyword">import</span> TextInput</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginScreen</span><span class="params">(GridLayout)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        super(LoginScreen, self).__init__(**kwargs)</span><br><span class="line">        self.cols = <span class="number">2</span></span><br><span class="line">        self.add_widget(Label(text=<span class="string">'User Name'</span>))</span><br><span class="line">        self.username = TextInput(multiline=<span class="literal">False</span>)</span><br><span class="line">        self.add_widget(self.username)</span><br><span class="line">        self.add_widget(Label(text=<span class="string">'password'</span>))</span><br><span class="line">        self.password = TextInput(password=<span class="literal">True</span>, multiline=<span class="literal">False</span>)</span><br><span class="line">        self.add_widget(self.password)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span><span class="params">(App)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> LoginScreen()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    MyApp().run()</span><br></pre></td></tr></table></figure>
<p>在第2行，我们导入<code>Gridlayout</code>：</p>
<p><code>from kivy.uix.gridlayout import GridLayout</code></p>
<p>此类用作第9行中定义的<code>RootWidget（LoginScreen）</code>的基础：</p>
<p><code>class LoginScreen(GridLayout):</code></p>
<p>在<code>LoginScreen</code>类的第12行，我们重写了<code>__init __（）</code>方法，以便添加小部件并添加到定义他们的行为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def __init__(self, **kwargs):</span><br><span class="line">    super(LoginScreen, self).__init__(**kwargs)</span><br></pre></td></tr></table></figure>
<p>为了实现原始类的功能，请不要忘记调用<code>super</code>超载。 还要注意，优良作法是在调用<code>super</code>时不要忽略<code>** kwarg</code>，因为它们是有时在内部使用。</p>
<p>移至15行及以后：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.cols = <span class="number">2</span></span><br><span class="line">self.add_widget(Label(text=<span class="string">'User Name'</span>))</span><br><span class="line">self.username = TextInput(multiline=<span class="literal">False</span>)</span><br><span class="line">self.add_widget(self.username)</span><br><span class="line">self.add_widget(Label(text=<span class="string">'password'</span>))</span><br><span class="line">self.password = TextInput(password=<span class="literal">True</span>, multiline=<span class="literal">False</span>)</span><br><span class="line">self.add_widget(self.password)</span><br></pre></td></tr></table></figure>
<p>我们要求<code>GridLayout</code>在两列中管理其子项，并为以下项添加<code>Label</code>和<code>TextInput</code>用户名和密码。</p>
<p>运行上面的代码将为您提供一个如下所示的窗口：</p>
<p><img src="https://s2.ax1x.com/2020/02/13/1qSgc6.png" alt="1qSgc6.png"></p>
<p>尝试重新调整窗口大小，您将看到屏幕上的小部件会根据无需做任何事情的窗口大小。 这是因为小部件使用大小提示默认。</p>
<p>上面的代码无法处理用户的输入，也不进行验证或其他任何操作。我们会在接下来的部分中深入研究此功能以及小部件的大小和位置。</p>
<h2 id="控制环境"><a href="#控制环境" class="headerlink" title="控制环境"></a>控制环境</h2><p>许多环境变量可用于控制Kivy的初始化和行为。</p>
<p>例如，为了将文本呈现限制为PIL实现：</p>
<p><code>$ KIVY_TEXT=pil python main.py</code></p>
<p>导入kivy之前应设置环境变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">'KIVY_TEXT'</span>] = <span class="string">'pil'</span></span><br><span class="line"><span class="keyword">import</span> kivy</span><br></pre></td></tr></table></figure>
<h3 id="路径控制"><a href="#路径控制" class="headerlink" title="路径控制"></a>路径控制</h3><p>1.0.7版中的新功能。</p>
<p>您可以控制配置文件，模块和kivy数据所在的默认目录。</p>
<p><strong>KIVY_DATA_DIR</strong> Kivy数据的位置，默认为<code>&lt;depressed path&gt;/data</code></p>
<p><strong>KIVY_MODULES_DIR</strong> Kivy模块的位置，默认为<code>&lt;depressed path&gt;/modules</code></p>
<p><strong>KIVY_HOME</strong> Kivy家的位置。 此目录用于本地配置，并且必须为在可写的位置。</p>
<p>默认为：</p>
<ul>
<li>Desktop: <code>&lt;user home&gt;/.kivy</code></li>
<li>Android: <code>&lt;android app path&gt;/.kivy</code></li>
<li>iOS: <code>&lt;user home&gt;/Documents/.kivy</code></li>
</ul>
<p>1.9.0版中的新功能。</p>
<p><strong>KIVY_SDL2_PATH</strong>如果设置，则在编译kivy时使用此路径的SDL2库和头<br>而不是系统范围内安装的系统。 要在运行kivy应用程序时使用相同的库，这<br>必须在PATH环境变量的开头添加路径。</p>
<p>1.9.0版中的新功能。</p>
<p><strong>警告：编译Kivy需要此路径。程序不需要执行。</strong></p>
<h3 id="组态"><a href="#组态" class="headerlink" title="组态"></a>组态</h3><p><strong>KIVY_USE_DEFAULTCONFIG</strong> 如果在环境中找到此名称，Kivy将不会读取用户配置文件。</p>
<p><strong>KIVY_NO_CONFIG</strong> 如果设置，则不会读取或写入任何配置文件。 这也适用于用户配置目录。</p>
<p><strong>KIVY_NO_FILELOG</strong> 如果设置，日志将不会打印到文件中。</p>
<p><strong>KIVY_NO_CONSOLELOG</strong> 如果设置，日志将不会打印到控制台</p>
<p><strong>KIVY_NO_ARGS</strong> 如果设置，则在命令行中传递的参数将不会被Kivy解析和使用。</p>
<p>即，您可以安全地使用自己的参数制作脚本或应用，而无需 - 分隔符：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">"KIVY_NO_ARGS"</span>] = <span class="string">"1"</span></span><br><span class="line"><span class="keyword">import</span> kivy</span><br></pre></td></tr></table></figure>
<p>1.9.0版中的新功能。</p>
<p><strong>KCFG_section_key</strong> 如果检测到这样的格式环境名称，它将被映射到<code>Config</code>宾语。 导入kivy后，它们只会加载一次。 该行为可以通过以下方式禁用<em>KIVY_NO_ENV_CONFIG</em>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">"KCFG_KIVY_LOG_LEVEL"</span>] = <span class="string">"warning"</span></span><br><span class="line"><span class="keyword">import</span> kivy</span><br><span class="line"><span class="comment"># during import it will map it to:</span></span><br><span class="line"><span class="comment"># Config.set("kivy", "log_level", "warning")</span></span><br></pre></td></tr></table></figure>
<p>1.11.0版中的新功能。</p>
<p><strong>KIVY_NO_ENV_CONFIG</strong> 如果设置，则没有环境密钥将映射到配置对象。 如果未设置，任何<code>KCFG_section_key = value</code>都将映射到<code>Config</code>。</p>
<p>1.11.0版中的新功能。</p>
<h3 id="将核心限制为具体实施"><a href="#将核心限制为具体实施" class="headerlink" title="将核心限制为具体实施"></a>将核心限制为具体实施</h3><p>kivy.core尝试选择适用于您的平台的最佳实施。用于测试或定制<br>安装时，您可能希望将选择器限制为特定的实现。</p>
<p><strong>KIVY_WINDOW</strong> 实现，用于创建窗口。</p>
<p>值：sdl2，pygame，x11，egl_rpi</p>
<p><strong>KIVY_TEXT</strong> 用于呈现文本的实现</p>
<p>值：sdl2, pil, pygame, sdlttf</p>
<p>KIVY_VIDEO实现，用于呈现视频</p>
<p>值：gstplayer, ffpyplayer, ffmpeg, null</p>
<p><strong>KIVY_AUDIO</strong> 用于播放音频的实现</p>
<p>值：sdl2, gstplayer, ffpyplayer, pygame, avplayer</p>
<p><strong>KIVY_IMAGE</strong> 用于读取图像的实现</p>
<p>值：sdl2, pil, pygame, imageio, tex, dds, gif</p>
<p><strong>KIVY_CAMERA</strong> 用于读取相机的实现</p>
<p>值：avfoundation, android, opencv</p>
<p><strong>KIVY_SPELLING</strong> 用于拼写的实现</p>
<p>值：enchant, osxappkit</p>
<p><strong>KIVY_CLIPBOARD</strong> 实现，用于剪贴板管理</p>
<p>值：sdl2, pygame, dummy, android</p>
<h3 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h3><p><strong>KIVY_DPI</strong> 如果设置，则该值将用于<strong>Metrics.dpi</strong>。</p>
<p>1.4.0版的新功能。</p>
<p><strong>KIVY_METRICS_DENSITY</strong> 如果设置，则该值将用于<strong>Metrics.density</strong>。</p>
<p>1.5.0版的新功能。</p>
<p><strong>KIVY_METRICS_FONTSCALE</strong>如果设置，则该值将用于<strong>Metrics.fontscale</strong>。</p>
<p>1.5.0版的新功能。</p>
<h3 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h3><p><strong>KIVY_GL_BACKEND</strong> 要使用的OpenGL后端。参见cgl。</p>
<p><strong>KIVY_GL_DEBUG</strong> 是否记录OpenGL调用。参见cgl。</p>
<p><strong>KIVY_GRAPHICS</strong> 是否使用OpenGL ES2。参见cgl。</p>
<p><strong>KIVY_GLES_LIMITS</strong> 是否强制执行GLES2限制（默认设置，或设置为1）。如果设置为否，Kivy不会真正与GLES2兼容。</p>
<p>以下列出了设置为true时可能导致的不兼容性。</p>
<ul>
<li>网格指数<ul>
<li>如果为true，则网格中的索引数限制为65535</li>
</ul>
</li>
<li>纹理闪电战<ul>
<li>向纹理贴图时，数据（颜色和缓冲区）格式必须与一种用于纹理创建。在桌面上，不同颜色的转换正确由驱动程序处理，而在Android上，大多数设备都无法做到。参考：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tpdnkva2l2eS9pc3N1ZXMvMTYwMA==">https://github.com/kivy/kivy/issues/1600<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</li>
</ul>
<p>版本1.8.1中的新功能。</p>
<p><strong>KIVY_BCM_DISPMANX_ID</strong> 更改要使用的默认Raspberry Pi显示。 可用清单可在<em>vc_dispmanx_types.h</em>中访问该值。默认值为0：</p>
<ul>
<li>0: <strong>DISPMANX_ID_MAIN_LCD</strong></li>
<li>1: <strong>DISPMANX_ID_AUX_LCD</strong></li>
<li>2: <strong>DISPMANX_ID_HDMI</strong></li>
<li>3: <strong>DISPMANX_ID_SDTV</strong></li>
<li>4: <strong>DISPMANX_ID_FORCE_LCD</strong></li>
<li>5: <strong>DISPMANX_ID_FORCE_TV</strong></li>
<li>6: <strong>DISPMANX_ID_FORCE_OTHER</strong></li>
</ul>
<p><strong>KIVY_BCM_DISPMANX_LAYER</strong> 更改默认的Raspberry Pi Dispmanx图层。默认值为0。</p>
<p>1.10.1版中的新功能。</p>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p><strong>KIVY_EVENTLOOP</strong>在异步运行应用程序时应使用哪个异步库方式。有关示例用法，请参见kivy.app。</p>
<p><strong>‘asyncio’</strong>：当应用以异步方式运行且标准库asyncio时包装应使用。 如果未设置，则为默认值。</p>
<p><strong>‘trio’</strong>：当应用程序以异步方式运行且trio包应为用过的。</p>
<p>2.0.0版中的新功能。</p>
<h2 id="Kivy-配置"><a href="#Kivy-配置" class="headerlink" title="Kivy 配置"></a>Kivy 配置</h2><p>kivy的配置文件名为config.ini，并遵循<span class="exturl" data-url="aHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JTklfZmlsZQ==">标准INI<i class="fa fa-external-link-alt"></i></span>格式。</p>
<h3 id="查找配置文件"><a href="#查找配置文件" class="headerlink" title="查找配置文件"></a>查找配置文件</h3><p>配置文件的位置由环境变量<em>KIVY_HOME</em>控制：</p>
<p><code>&lt;KIVY_HOME&gt;/config.ini</code></p>
<p>在台式机上，默认为：</p>
<p><code>&lt;HOME_DIRECTORY&gt;/.kivy/config.ini</code></p>
<p>因此，如果您的用户名为“ tito”，则文件将位于此处：</p>
<ul>
<li>Windows: C:\Users\tito.kivy\config.ini</li>
<li>OS X: /Users/tito/.kivy/config.ini</li>
<li>Linux: /home/tito/.kivy/config.ini</li>
</ul>
<p>在Android上，默认为：</p>
<p><code>&lt;ANDROID_APP_PATH&gt;/.kivy/config.ini</code></p>
<p>如果您的应用名为“ org.kivy.launcher”，则文件将位于此处：</p>
<p><code>/data/data/org.kivy.launcher/files/.kivy/config.ini</code></p>
<p>在iOS上，默认为：</p>
<p><code>&lt;HOME_DIRECTORY&gt;/Documents/.kivy/config.ini</code></p>
<h3 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h3><p>有时，只希望更改某些应用程序的配置或在单独测试期间更改配置Kivy的一部分，例如输入提供程序。要创建单独的配置文件，您只需使用以下命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> kivy.config <span class="keyword">import</span> Config</span><br><span class="line">Config.read(&lt;file&gt;)</span><br><span class="line"><span class="comment"># set config</span></span><br><span class="line">Config.write()</span><br></pre></td></tr></table></figure>
<p>如果单个.ini文件的本地配置不够用，例如 当你想分开花园，奇异果原木和其他物品的环境，您需要更改<strong>KIVY_HOME</strong>环境您的应用程序中的变量以获得所需的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">os.environ[&#39;KIVY_HOME&#39;] &#x3D; &lt;folder&gt;</span><br></pre></td></tr></table></figure>
<p>或在每次运行该应用程序之前在控制台中对其进行手动更改：</p>
<ol>
<li>Windows:</li>
</ol>
<p><code>set KIVY_HOME=&lt;folder&gt;</code></p>
<ol start="2">
<li>Linux &amp; OSX:</li>
</ol>
<p><code>export KIVY_HOME=&lt;folder&gt;</code></p>
<p>更改<strong>KIVY_HOME</strong>后，该文件夹的行为将与默认的.kivy /文件夹完全相同上文提到的。</p>
<h3 id="了解配置令牌"><a href="#了解配置令牌" class="headerlink" title="了解配置令牌"></a>了解配置令牌</h3><p>所有配置令牌在kivy.config模块中进行了说明。</p>
<h2 id="建筑概述"><a href="#建筑概述" class="headerlink" title="建筑概述"></a>建筑概述</h2><p>我们想花一点时间从软件工程角度解释我们如何设计Kivy视图。 这是了解所有事物如何协同工作的关键。如果您只看代码，您是否已经有了一个大概的主意，但是由于这种方法对于大多数用户而言确实令人生畏，因此本节更详细地说明了实现的基本思想。 您可以跳过本节并参考稍后再讨论，但我们建议至少略读一下以大致了解。</p>
<p>Kivy由几个构建块组成，我们将在稍后进行解释。这是以下内容的图形摘要,架构：</p>
<p><img src="https://s2.ax1x.com/2020/02/13/1LYIDx.png" alt="1LYIDx.png"></p>
<h3 id="核心提供者和输入提供者"><a href="#核心提供者和输入提供者" class="headerlink" title="核心提供者和输入提供者"></a>核心提供者和输入提供者</h3><p>理解Kivy内部的关键是模块化和抽象化。我们尝试抽象基本任务，例如打开窗口，显示图像和文本，播放音频，获取来自相机的图像，拼写更正等。我们称这些核心任务。这使得API都易于使用且易于扩展。最重要的是，它允许我们使用-我们所谓的-特定提供商适用于运行您的应用的各个方案。例如，在OSX，Linux和Windows上，针对不同的核心任务有不同的本机API。一段使用以下特定代码之一的代码一方面与操作系统通信，另一方面与Kivy通信的API（充当中间设备）通信层）就是我们所谓的核心提供商。使用专业核心提供商的优势对于每个平台，我们可以充分利用操作系统提供的功能并采取行动尽可能有效。它还为用户提供了选择。此外，通过使用附带的库在任何一个平台上，我们都有效地减少了Kivy分销的规模并进行包装更轻松。这也使得将Kivy移植到其他平台变得更加容易。 Android端口受益匪浅由此。</p>
<p>我们对输入处理遵循相同的概念。 输入提供程序是一段添加支持的代码适用于特定的输入设备，例如Apple的触控板，TUIO或鼠标模拟器。 如果需要添加支持新的输入设备，您只需提供一个新类即可从中读取输入数据您的设备并将其转换为Kivy基本事件。</p>
<h3 id="图形-1"><a href="#图形-1" class="headerlink" title="图形"></a>图形</h3><p>Kivy的图形API是我们对OpenGL的抽象。从最低的角度看，Kivy的硬件加速问题使用OpenGL绘制命令。但是编写OpenGL代码可能会有些混乱，特别是对新来者。因此，我们提供了图形API，可让您使用OpenGL中不存在的简单隐喻（例如Canvas，Rectangle等）。</p>
<p>我们所有的小部件本身都使用此图形API，该API在C层上实现以提高性能原因。</p>
<p>图形API的另一个优点是它能够自动优化绘图命令您的代码问题。如果您不是调整OpenGL的专家，这将特别有用。这使得在许多情况下，您的绘图代码效率更高。</p>
<p>当然，如果愿意，您仍然可以使用原始OpenGL命令。我们针对的版本是OpenGL 2.0所有设备上的ES（GLES2），因此，如果要保持跨平台兼容性，建议您仅使用GLES2功能。</p>
<h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p>核心软件包中的代码提供了常用功能，例如：</p>
<ul>
<li><strong>Clock</strong> 您可以使用时钟安排计时器事件。 一次性计时器和定期计时器支持计时器。</li>
<li><strong>Cache</strong> 如果您需要缓存经常使用的内容，可以使用我们的类而不是自己写。</li>
<li><strong>Gesture Detection</strong> 我们提供了一个简单的手势识别器，您可以使用它来检测各种各种笔触，例如圆形或矩形。您可以训练它来检测自己的招。</li>
<li><strong>Kivy Language</strong> Kivy语言用于轻松有效地描述用户界面。</li>
<li><strong>Properties</strong> 这些不是您可能从python知道的普通属性。他们是我们自己的属性类，这些属性类将窗口小部件代码与用户界面描述相关联。</li>
</ul>
<h3 id="UIX（小部件和布局）"><a href="#UIX（小部件和布局）" class="headerlink" title="UIX（小部件和布局）"></a>UIX（小部件和布局）</h3><p>UIX模块包含常用的小部件和布局，您可以重复使用这些小部件和布局以快速创建一个用户界面。</p>
<ul>
<li><strong>Widgets</strong> 小部件是您添加到程序中以提供的用户界面元素某种功能。它们可能不可见。例子是文件浏览器，按钮，滑块，列表等。窗口小部件接收MotionEvents。</li>
<li><strong>Layouts</strong> 您使用布局来排列小部件。当然可以计算您的小部件的定位自己，但使用我们现成的一种通常更方便布局。例如网格布局或箱形布局。您也可以嵌套布局。</li>
</ul>
<h3 id="模组"><a href="#模组" class="headerlink" title="模组"></a>模组</h3><p>如果您曾经使用过现代的网络浏览器并使用一些插件对其进行了自定义，那么您已经了解我们模块类背后的基本思想。模块可用于将功能注入Kivy程序，即使原始作者未将其包括在内。</p>
<p>一个示例是始终显示当前应用程序的FPS和一些图形的模块描述随着时间推移的FPS。</p>
<p>您也可以编写自己的模块。</p>
<h3 id="输入事件（触摸）"><a href="#输入事件（触摸）" class="headerlink" title="输入事件（触摸）"></a>输入事件（触摸）</h3><p>Kivy提取了不同的输入类型和来源，例如触摸，鼠标，TUIO或类似输入。 什么都可以。这些输入类型的共同点是您可以将2D屏幕上的位置与任何个人相关联输入事件。（还有其他输入设备，例如加速度计，您无法轻松找到2D例如的位置 设备倾斜。 这种输入是单独处理的。 接下来我们描述前一种类型。）</p>
<p>所有这些输入类型均由<code>Touch()</code>类的实例表示。（请注意，这不仅指的是手指触摸，其他所有输入类型也是如此。为了方便起见，我们将其称为Touch简单。考虑一下触摸用户界面或屏幕的事物。）触摸实例，或对象，可以处于三种状态之一。当触摸进入这些状态之一时，程序会收到通知该事件发生了。可以进入的三种状态是：</p>
<ul>
<li><strong>Down</strong> 触摸仅在第一次出现的那一刻才下降一次。</li>
<li><strong>Move</strong> 触摸可能会在这种状态下持续无限的时间。 一点触摸都没有在其一生中处于这种状态。只要“ A”的2D位置触摸更改。</li>
<li><strong>Up</strong> 触摸最多一次或永远不会增加。实际上，您几乎总是会收到上升事件，因为没有人会永远在屏幕上牵着手指，但这是不保证。如果您知道用户将使用的输入源，则将知道是否可以依靠此状态被输入。</li>
</ul>
<h3 id="小部件和事件调度"><a href="#小部件和事件调度" class="headerlink" title="小部件和事件调度"></a>小部件和事件调度</h3><p>小部件<em>widget</em>通常在GUI编程上下文中用于描述程序的某些部分，用户进行交互。在Kivy中，小部件是一个接收输入事件的对象。不一定必须在屏幕上有可见的表示。所有小部件都排列在小部件树中（从计算机科学类中已知的树数据结构）：一个小部件可以具有任意数量的子级小部件或无。树的顶部只有一个根窗口小部件，没有父窗口小部件，而所有其他小部件直接或间接是此小部件的子级（这就是为什么将其称为根）的原因。</p>
<p>当有新的输入数据可用时，Kivy每次触摸都会发出一个事件。小部件的根小部件树首先接收事件。根据触摸状态，<code>on_touch_down</code>，<code>on_touch_move</code>或<code>on_touch_up</code>事件被调度（以touch作为参数）到根窗口小部件，结果在根小部件的相应<code>on_touch_down</code>，<code>on_touch_move</code>或<code>on_touch_up</code>事件处理程序中被呼叫。</p>
<p>树中的每个窗口小部件（包括根窗口小部件）都可以选择摘要事件或将事件继续传递。如果事件处理程序返回True，则表示该事件已被摘要并正确处理。 没有该事件将进行进一步处理。否则，事件处理程序会将小部件传递给通过调用其超类的相应事件处理程序的实现来调用自己的子级。这去一直到baseWidget类，在其触摸事件处理程序中，除了传递感动它的孩子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This is analogous for move/up:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_touch_down</span><span class="params">(self, touch)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> self.children[:]:</span><br><span class="line">        <span class="keyword">if</span> child.dispatch(<span class="string">'on_touch_down'</span>, touch):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>这确实比最初看起来容易得多。 如何将其用于创建漂亮的应用程序的示例下一节将很快给出。</p>
<p>通常，您会希望限制小部件监视触摸的屏幕区域。您可以使用小部件的<code>collide_point()</code>方法来实现此目的。您只需将触摸的位置传递给它如果触摸在“观看区域”内，则返回True；否则返回False。默认情况下，这会检查小部件的pos（位置； x和y）和大小所描述的屏幕上的矩形区域（宽度和高度），但是您可以在自己的课程中覆盖此行为。</p>
<h2 id="活动和属性"><a href="#活动和属性" class="headerlink" title="活动和属性"></a>活动和属性</h2><p>事件是Kivy编程的重要组成部分。对于使用GUI的人来说，这可能不足为奇开发经验，但这对新来者来说是重要的概念。一旦你了解了事件有效，以及如何绑定它们，您会在Kivy中到处看到它们。他们很容易将您想要的任何行为建立到Kivy中。</p>
<p>下图显示了如何在Kivy框架中处理事件。<br><img src="https://s2.ax1x.com/2020/02/13/1L0xfK.png" alt="1L0xfK.png"></p>
<h3 id="事件分派器简介"><a href="#事件分派器简介" class="headerlink" title="事件分派器简介"></a>事件分派器简介</h3><p>该框架最重要的基类之一是EventDispatcher类。这个班允许您注册事件类型，并将其分派给感兴趣的各方（通常是其他事件分派器）。Widget，Animation和Clock类是事件分配器的示例。</p>
<p>EventDispatcher对象依赖于主循环来生成和处理事件。</p>
<h3 id="主循环"><a href="#主循环" class="headerlink" title="主循环"></a>主循环</h3><p>如上图所示，Kivy具有一个主循环。 此循环正在所有应用程序的运行期间运行生存期，仅在退出应用程序时退出。</p>
<p>在循环内部，每次迭代都会从用户输入，硬件传感器或几个事件生成事件其他来源，并将帧渲染到显示器。</p>
<p>您的应用程序将指定回调（稍后会详细介绍），这些回调由主循环调用。如果回调时间太长或根本没有退出，主循环中断并且您的应用无法正常运行不再。</p>
<p>在Kivy应用程序中，必须避免长时间/无限循环或休眠。例如下面的代码两者都做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    animate_something()</span><br><span class="line">    time.sleep(<span class="number">.10</span>)</span><br></pre></td></tr></table></figure>
<p>当您运行此程序时，该程序将永远不会退出循环，从而阻止Kivy执行其他所有操作需要做的事情。结果，您将看到的是一个黑色的窗口，您将无法交互用。相反，您需要“计划”您的<code>animate_something()</code>函数以反复调用。</p>
<h4 id="安排重复事件"><a href="#安排重复事件" class="headerlink" title="安排重复事件"></a>安排重复事件</h4><p>您可以使用<code>schedule_interval()</code>每秒每X次调用一次函数或方法。 这是每秒调用一次名为<code>my_callback</code>的函数30次的示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_callback</span><span class="params">(dt)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'My callback is called'</span>, dt</span><br><span class="line">event = Clock.schedule_interval(my_callback, <span class="number">1</span> / <span class="number">30.</span>)</span><br></pre></td></tr></table></figure>
<p>您可以采用多种方式取消安排先前安排的事件。一种是使用<code>cancel()</code>或<br><code>unschedule()</code>：</p>
<p><code>event.cancel()</code></p>
<p>或者：</p>
<p><code>Clock.unschedule(event)</code></p>
<p>另外，您可以在回调中返回False，事件将自动取消计划：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_callback</span><span class="params">(dt)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> count</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'Last call of my callback, bye bye !'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'My callback is called'</span>)</span><br><span class="line">Clock.schedule_interval(my_callback, <span class="number">1</span> / <span class="number">30.</span>)</span><br></pre></td></tr></table></figure>
<h4 id="计划一个事件"><a href="#计划一个事件" class="headerlink" title="计划一个事件"></a>计划一个事件</h4><p>使用<code>schedule_once()</code>，您可以调用函数“稍后”，例如在下一帧或X秒内：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_callback</span><span class="params">(dt)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'My callback is called !'</span></span><br><span class="line">Clock.schedule_once(my_callback, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>这将在一秒钟内调用<code>my_callback</code>。第二个参数是要等待的时间量调用该函数，以秒为单位。但是，您可以使用特殊的值获得其他一些结果第二个参数：</p>
<ul>
<li>如果X大于0，则回调将在X秒内被调用</li>
<li>如果X为0，则在下一帧之后将调用回调</li>
<li>如果X为-1，则将在下一帧之前调用回调</li>
</ul>
<p>-1通常用于已经安排好的活动中，并且要安排通话时在下一帧发生之前。</p>
<p>重复函数调用的第二种方法是先使用<code>schedule_once()</code>，以及在回调自身内部的第二次调用此函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_callback</span><span class="params">(dt)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'My callback is called !'</span></span><br><span class="line">    Clock.schedule_once(my_callback, <span class="number">1</span>)</span><br><span class="line">Clock.schedule_once(my_callback, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>尽管主循环将尝试按要求保持进度，但在某些方面存在不确定性确切地说，何时将调用计划的回调。有时，另一个回调或其他一些任务应用所需的时间比预期的要长，因此时间可能会稍短。</p>
<p>在后一种解决重复性回调问题的方法中，下一次迭代将至少称为一个最后一次迭代结束后的第二秒。但是，使用<code>schedule_interval()</code>时，每个回调都会被调用第二。</p>
<h4 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h4><p>有时您可能希望将某个函数安排为下一帧仅被调用一次，以防止重复通话。您可能会很想这样实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># First, schedule once.</span></span><br><span class="line">event = Clock.schedule_once(my_callback, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># Then, in another place you will have to unschedule first</span></span><br><span class="line"><span class="comment"># to avoid duplicate call. Then you can schedule again.</span></span><br><span class="line">Clock.unschedule(event)</span><br><span class="line">event = Clock.schedule_once(my_callback, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>通过这种方式对触发器进行编程非常昂贵，因为即使事件已经完成了。此外，每次都会创建一个新事件。改用触发器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">trigger = Clock.create_trigger(my_callback)</span><br><span class="line"><span class="comment"># later</span></span><br><span class="line">trigger()</span><br></pre></td></tr></table></figure>
<p>每次调用<code>trigger()</code>时，它将安排一次回调调用。如果已经安排好了不会重新安排。</p>
<h3 id="小部件事件"><a href="#小部件事件" class="headerlink" title="小部件事件"></a>小部件事件</h3><p>小部件具有2种默认事件类型：</p>
<ul>
<li>属性事件：如果窗口小部件更改其位置或大小，则将触发一个事件。</li>
<li>窗口小部件定义的事件：例如 按下或释放按钮时会触发一个事件。</li>
</ul>
<p>有关如何管理和传播窗口小部件触摸事件的讨论，请参考窗口小部件触摸事件冒泡部分。</p>
<h3 id="创建自定义事件"><a href="#创建自定义事件" class="headerlink" title="创建自定义事件"></a>创建自定义事件</h3><p>要使用自定义事件创建事件分配器，您需要在类中注册事件的名称,然后创建一个同名的方法。</p>
<p>请参见以下示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEventDispatcher</span><span class="params">(EventDispatcher)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        self.register_event_type(<span class="string">'on_test'</span>)</span><br><span class="line">        super(MyEventDispatcher, self).__init__(**kwargs)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_something</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="comment"># when do_something is called, the 'on_test' event will be</span></span><br><span class="line">        <span class="comment"># dispatched with the value</span></span><br><span class="line">        self.dispatch(<span class="string">'on_test'</span>, value)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_test</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"I am dispatched"</span>, args</span><br></pre></td></tr></table></figure>

<h3 id="附加回调"><a href="#附加回调" class="headerlink" title="附加回调"></a>附加回调</h3><p>要使用事件，您必须将回调绑定到事件。调度事件后，您的回调将使用与该特定事件相关的参数调用。</p>
<p>回调可以是任何可调用的python，但是您需要确保其接受该事件的参数发出。为此，通常最安全的方法是接受<code>* args</code>参数，该参数会捕获参数列表。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_callback</span><span class="params">(value, *args)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Hello, I got an event!"</span>, args</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ev = MyEventDispatcher()</span><br><span class="line">ev.bind(on_test=my_callback)</span><br><span class="line">ev.do_something(<span class="string">'test'</span>)</span><br></pre></td></tr></table></figure>
<p>请参阅<code>kivy.event.EventDispatcher.bind()</code>方法文档以获取更多示例关于如何附加回调。</p>
<h3 id="物业介绍"><a href="#物业介绍" class="headerlink" title="物业介绍"></a>物业介绍</h3><p>属性是定义事件并将其绑定的一种很棒的方法。本质上，它们产生事件,这样，当对象的属性更改时，所有引用该属性的属性都会自动更新。</p>
<p>有不同类型的属性来描述您要处理的数据类型。</p>
<ul>
<li><strong>StringProperty</strong></li>
<li><strong>NumericProperty</strong></li>
<li><strong>BoundedNumericProperty</strong></li>
<li><strong>ObjectProperty</strong></li>
<li><strong>DictProperty</strong></li>
<li><strong>ListProperty</strong></li>
<li><strong>OptionProperty</strong></li>
<li><strong>AliasProperty</strong></li>
<li><strong>BooleanProperty</strong></li>
<li><strong>ReferenceListProperty</strong></li>
</ul>
<h3 id="财产申报"><a href="#财产申报" class="headerlink" title="财产申报"></a>财产申报</h3><p>要声明属性，必须在类级别声明它们。 然后，该班级将做创建对象时实例化真实属性。这些属性不是属性：它们是根据您的属性创建事件的机制：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyWidget</span><span class="params">(Widget)</span>:</span></span><br><span class="line"></span><br><span class="line">    text = StringProperty(<span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<p>覆盖<code>__init__</code>时，请始终接受<code>**kwargs</code>并使用<code>super()</code>调用父级的<code>__init__</code>方法，传递您的类实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">    super(MyWidget, self).__init__(**kwargs)</span><br></pre></td></tr></table></figure>

<h3 id="调度属性事件"><a href="#调度属性事件" class="headerlink" title="调度属性事件"></a>调度属性事件</h3><p>默认情况下，Kivy属性提供on_<property_name>事件。当值属性的更改。</property_name></p>
<hr>
<p><strong>注意：如果属性的新值等于当前值，则on_ <property_name>事件不会被调用。</property_name></strong></p>
<hr>
<p>例如，考虑以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomBtn</span><span class="params">(Widget)</span>:</span></span><br><span class="line"></span><br><span class="line">    pressed = ListProperty([<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_touch_down</span><span class="params">(self, touch)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.collide_point(*touch.pos):</span><br><span class="line">            self.pressed = touch.pos</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> super(CustomBtn, self).on_touch_down(touch)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_pressed</span><span class="params">(self, instance, pos)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'pressed at &#123;pos&#125;'</span>.format(pos=pos))</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，第3行：</p>
<p><code>pressed = ListProperty([0, 0])</code></p>
<p>我们定义类型为ListProperty的pressed属性，并为其提供默认值[0，0]。由此向前指出，只要更改此属性的值，就会调用on_pressed事件。</p>
<p>在第5行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_touch_down</span><span class="params">(self, touch)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.collide_point(*touch.pos):</span><br><span class="line">        self.pressed = touch.pos</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> super(CustomBtn, self).on_touch_down(touch)</span><br></pre></td></tr></table></figure>
<p>我们重写Widget类的<code>on_touch_down()</code>方法。在这里，我们检查触摸我们的小部件。</p>
<p>如果触摸落入我们的小部件内部，我们将pressed的值更改为touch.pos并返回True，表示我们已经消耗了触摸并且不希望其进一步传播。</p>
<p>最后，如果触摸超出了我们的小部件，我们将使用<code>super（...）</code>调用原始事件，并返回结果。这使得触摸事件传播可以像通常发生的那样继续进行。</p>
<p>最后在第11行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_pressed</span><span class="params">(self, instance, pos)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'pressed at &#123;pos&#125;'</span>.format(pos=pos))</span><br></pre></td></tr></table></figure>
<p>我们定义了一个<em>on_pressed</em>函数，只要更改属性值，属性就会调用该函数。</p>
<hr>
<p><strong>注意：此on_ <prop_name>事件在定义属性的类中调用。 要监视/观察对定义类之外的属性的任何更改，您应按如下所示绑定到该属性。</prop_name></strong></p>
<hr>
<p><strong>绑定到属性</strong></p>
<p>当您仅拥有窗口小部件实例时，如何监视对属性的更改？ 您绑定到属性：</p>
<p><code>your_widget_instance.bind(property_name=function_name)</code></p>
<p>例如，考虑以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootWidget</span><span class="params">(BoxLayout)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        super(RootWidget, self).__init__(**kwargs)</span><br><span class="line">        self.add_widget(Button(text=<span class="string">'btn 1'</span>))</span><br><span class="line">        cb = CustomBtn()</span><br><span class="line">        cb.bind(pressed=self.btn_pressed)</span><br><span class="line">        self.add_widget(cb)</span><br><span class="line">        self.add_widget(Button(text=<span class="string">'btn 2'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">btn_pressed</span><span class="params">(self, instance, pos)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'pos: printed from root widget: &#123;pos&#125;'</span>.format(pos=.pos))</span><br></pre></td></tr></table></figure>
<p>如果按原样运行代码，则会在控制台中看到两个打印语句。一个来自在CustomBtn类内部调用的on_pressed事件，另一个来自我们绑定到属性更改的btn_pressed函数。</p>
<p>调用两个函数的原因很简单。绑定并不意味着覆盖。 同时拥有这两个功能是多余的，通常应仅使用侦听/响应属性更改的方法之一。</p>
<p>您还应该注意传递给on_ <property_name>事件的参数或绑定到该属性的函数。</property_name></p>
<p><code>def btn_pressed(self, instance, pos):</code></p>
<p>第一个参数是self，它是定义此函数的类的实例。 您可以如下使用嵌入式函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cb = CustomBtn()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_local_func</span><span class="params">(instance, pos)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'pos: printed from root widget: &#123;pos&#125;'</span>.format(pos=pos))</span><br><span class="line"></span><br><span class="line">cb.bind(pressed=_local_func)</span><br><span class="line">self.add_widget(cb)</span><br></pre></td></tr></table></figure>
<p>第一个参数将是定义属性的类的实例。</p>
<p>第二个参数是值，它是属性的新值。</p>
<p>这是从上面的片段衍生而来的完整示例，您可以使用该示例复制并粘贴到编辑器中进行实验。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> kivy.app <span class="keyword">import</span> App</span><br><span class="line"><span class="keyword">from</span> kivy.uix.widget <span class="keyword">import</span> Widget</span><br><span class="line"><span class="keyword">from</span> kivy.uix.button <span class="keyword">import</span> Button</span><br><span class="line"><span class="keyword">from</span> kivy.uix.boxlayout <span class="keyword">import</span> BoxLayout</span><br><span class="line"><span class="keyword">from</span> kivy.properties <span class="keyword">import</span> ListProperty</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootWidget</span><span class="params">(BoxLayout)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        super(RootWidget, self).__init__(**kwargs)</span><br><span class="line">        self.add_widget(Button(text=<span class="string">'btn 1'</span>))</span><br><span class="line">        cb = CustomBtn()</span><br><span class="line">        cb.bind(pressed=self.btn_pressed)</span><br><span class="line">        self.add_widget(cb)</span><br><span class="line">        self.add_widget(Button(text=<span class="string">'btn 2'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">btn_pressed</span><span class="params">(self, instance, pos)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'pos: printed from root widget: &#123;pos&#125;'</span>.format(pos=pos))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomBtn</span><span class="params">(Widget)</span>:</span></span><br><span class="line">    pressed = ListProperty([<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_touch_down</span><span class="params">(self, touch)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.collide_point(*touch.pos):</span><br><span class="line">            self.pressed = touch.pos</span><br><span class="line">            <span class="comment"># we consumed the touch. return False here to propagate</span></span><br><span class="line">            <span class="comment"># the touch further to the children.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> super(CustomBtn, self).on_touch_down(touch)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_pressed</span><span class="params">(self, instance, pos)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'pressed at &#123;pos&#125;'</span>.format(pos=pos))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestApp</span><span class="params">(App)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> RootWidget()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    TestApp().run()</span><br></pre></td></tr></table></figure>
<p>运行上面的代码将为您提供以下输出：<br><img src="https://s2.ax1x.com/2020/02/15/1xwwnS.jpg" alt="1xwwnS.jpg"></p>
<p>我们的CustomBtn没有视觉表现，因此显示为黑色。 您可以触摸/单击黑色区域以在控制台上查看输出。</p>
<h3 id="复合性质"><a href="#复合性质" class="headerlink" title="复合性质"></a>复合性质</h3><p>定义AliasProperty时，通常您自己定义一个getter和setter函数。 在这里，由您来定义何时使用bind参数调用getter和setter函数。</p>
<p>考虑下面的代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cursor_pos = AliasProperty(_get_cursor_pos, <span class="literal">None</span>, bind=(<span class="string">'cursor'</span>, <span class="string">'padding'</span>, <span class="string">'pos'</span>, <span class="string">'size'</span>, <span class="string">'focus'</span>, <span class="string">'scroll_x'</span>, <span class="string">'scroll_y'</span>, <span class="string">'line_height'</span>, <span class="string">'line_spacing'</span>), cache=<span class="literal">True</span>)</span><br><span class="line"><span class="string">'''Current position of the cursor, in (x, y).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">:attr:`cursor_pos` is an :class:`~kivy.properties.AliasProperty`,</span></span><br><span class="line"><span class="string">read-only.</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<p>在这里cursor_pos是AliasProperty，它使用将setter部分设置为None的<em>getter _get_cursor_pos</em>，这意味着这是一个只读属性。</p>
<p>最后，bind参数定义当bind =参数中使用的任何属性更改时，将调度<em>on_cursor_pos</em>事件。</p>
<h2 id="输入管理"><a href="#输入管理" class="headerlink" title="输入管理"></a>输入管理</h2><h3 id="输入架构"><a href="#输入架构" class="headerlink" title="输入架构"></a>输入架构</h3><p>Kivy能够处理大多数类型的输入：鼠标，触摸屏，加速计，陀螺仪等。它在以下平台上处理本机多点触摸协议：Tuio，WM_Touch，MacMultitouchSupport，MT Protocol A / B和Android。</p>
<p>全局架构可以视为：</p>
<p><code>Input providers -&gt; Motion event -&gt; Post processing -&gt; Dispatch to Window</code></p>
<p>所有输入事件的类都是MotionEvent。它生成2种事件：</p>
<ul>
<li>触摸事件：至少包含X和Y位置的运动事件。所有触摸事件都在Widget树中调度。</li>
<li>非接触事件：其余所有事件。例如，加速度计是连续事件，没有位置。 它永远不会开始或停止。这些事件不会在Widget树上调度。</li>
</ul>
<p>Motion事件由输入提供程序生成。 输入提供者负责从操作系统，网络甚至其他应用程序读取输入事件。 存在多个输入提供程序，例如：</p>
<ul>
<li>TuioMotionEventProvider：创建UDP服务器并侦听TUIO / OSC消息。</li>
<li>WM_MotionEventProvider：使用Windows API读取多点触控信息并将其发送给Kivy。</li>
<li>ProbeSysfsHardwareProbe：在Linux中，遍历连接到计算机的所有硬件，并为找到的每个多点触控设备附加一个多点触控输入提供程序。</li>
<li>以及更多！</li>
</ul>
<p>编写应用程序时，无需创建输入提供程序。Kivy尝试自动检测可用的硬件。但是，如果要支持自定义硬件，则需要配置kivy使其起作用。</p>
<p>在将新创建的运动事件传递给用户之前，Kivy将后处理应用于输入。 分析每个运动事件，以检测和纠正错误的输入，并做出有意义的解释，例如：</p>
<ul>
<li>根据距离和时间阈值两次/三次检测</li>
<li>在硬件不准确时使事件更准确</li>
<li>如果本机触摸硬件正在发送位置几乎相同的事件，则减少生成的事件数量。</li>
</ul>
<p>经过处理后，运动事件将分派到Window。 如前所述，并非所有事件都分派到整个窗口小部件树：窗口会过滤它们。 对于给定事件：</p>
<ul>
<li>如果只是运动事件，它将被分派到on_motion()</li>
<li>如果是触摸事件，则触摸的（x，y）位置（0-1范围）将缩放为窗口大小（宽度/高度），并分配给：<ul>
<li>on_touch_down()</li>
<li>on_touch_move()</li>
<li>on_touch_up()</li>
</ul>
</li>
</ul>
<h3 id="运动事件配置文件"><a href="#运动事件配置文件" class="headerlink" title="运动事件配置文件"></a>运动事件配置文件</h3><p>根据您的硬件和使用的输入提供程序，可能会为您提供更多信息。 例如，触摸输入具有（x，y）位置，但也可能具有压力信息，斑点大小，加速度矢量等。</p>
<p>配置文件是一个字符串，指示运动事件中可用的功能。 假设您处于<code>on_touch_move</code>方法中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_touch_move</span><span class="params">(self, touch)</span>:</span></span><br><span class="line">    print(touch.profile)</span><br><span class="line">    <span class="keyword">return</span> super(..., self).on_touch_move(touch)</span><br></pre></td></tr></table></figure>
<p>打印输出：</p>
<p><code>[&#39;pos&#39;, &#39;angle&#39;]</code></p>
<hr>
<p><strong>警告：许多人混淆了个人资料的名称和相应属性的名称。 仅仅因为可用配置文件中包含“角度”，并不意味着触摸事件对象将具有angle属性。</strong></p>
<hr>
<p>对于“ pos”配置文件，属性pos，x和y将可用。 使用“角度”配置文件，属性a将可用。 如前所述，对于触摸事件，“ pos”是必需配置文件，而不是“ angle”。 您可以通过检查“角度”配置文件是否存在来扩展交互：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_touch_move</span><span class="params">(self, touch)</span>:</span></span><br><span class="line">    print(<span class="string">'The touch is at position'</span>, touch.pos)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'angle'</span> <span class="keyword">in</span> touch.profile:</span><br><span class="line">        print(<span class="string">'The touch angle is'</span>, touch.a)</span><br></pre></td></tr></table></figure>
<p>您可以在motionevent文档中找到可用配置文件的列表。</p>
<h3 id="触摸事件"><a href="#触摸事件" class="headerlink" title="触摸事件"></a>触摸事件</h3><p>触摸事件是专用的MotionEvent，其属性is_touch的值为True。 对于所有触摸事件，您将自动获得X和Y位置，并缩放到Window的宽度和高度。 换句话说，所有触摸事件都具有“ pos”配置文件。</p>
<h4 id="触控事件基础"><a href="#触控事件基础" class="headerlink" title="触控事件基础"></a>触控事件基础</h4><p>默认情况下，触摸事件将分派给所有当前显示的窗口小部件。 这意味着小部件将接收触摸事件，无论它是否在其物理区域内发生。</p>
<p>如果您有使用其他GUI工具包的经验，这可能会很直观。 这些通常将屏幕划分为几何区域，并且如果坐标位于窗口小部件区域之内，则仅向窗口小部件发送触摸或鼠标事件。</p>
<p>使用触摸输入时，此要求变得非常严格。 滑动，捏和长按很可能源自想要了解它们并对其做出反应的小部件外部。</p>
<p>为了提供最大的灵活性，Kivy将事件分派给所有小部件，并让它们决定如何对它们作出反应。 如果您只想响应小部件内的触摸事件，则只需检查：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_touch_down</span><span class="params">(self, touch)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.collide_point(*touch.pos):</span><br><span class="line">        <span class="comment"># The touch has occurred inside the widgets area. Do stuff!</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h4 id="座标"><a href="#座标" class="headerlink" title="座标"></a>座标</h4><p>在使用带有矩阵转换的小部件时，必须立即触摸矩阵转换。 诸如Scatter之类的某些小部件具有其自己的矩阵转换，这意味着触摸必须乘以散布矩阵才能正确地将触摸位置分配给Scatter的子级。</p>
<ul>
<li>获取父空间到本地空间的坐标：<code>to_local()</code></li>
<li>获取从本地空间到父空间的坐标：<code>to_parent()</code></li>
<li>获取局部空间到窗口空间的坐标：<code>to_window()</code></li>
<li>获取从窗口空间到本地空间的坐标：<code>to_widget()</code></li>
</ul>
<p>您必须使用其中之一将坐标正确缩放到上下文。 让我们看一下分散的实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_touch_down</span><span class="params">(self, touch)</span>:</span></span><br><span class="line">    <span class="comment"># 推动当前坐标，以便以后恢复</span></span><br><span class="line">    touch.push()</span><br><span class="line">    <span class="comment"># 将触摸坐标转换为局部空间</span></span><br><span class="line">    touch.apply_transform_2d(self.to_local)</span><br><span class="line">    <span class="comment"># 像往常一样向孩子派遣触摸</span></span><br><span class="line">    <span class="comment"># 触摸中的坐标现在在本地空间中</span></span><br><span class="line">    ret = super(..., self).on_touch_down(touch)</span><br><span class="line">    <span class="comment"># 无论结果如何，别忘了进行转换</span></span><br><span class="line">    <span class="comment"># 调用之后，因此坐标将返回到父空间</span></span><br><span class="line">    touch.pop()</span><br><span class="line">    <span class="comment"># 返回结果（取决于您想要的）。</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h4 id="触摸形状"><a href="#触摸形状" class="headerlink" title="触摸形状"></a>触摸形状</h4><p>如果触摸具有形状，它将反映在“形状”属性中。 现在，只能公开ShapeRect：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> kivy.input.shape <span class="keyword">import</span> ShapeRect</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_touch_move</span><span class="params">(self, touch)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(touch.shape, ShapeRect):</span><br><span class="line">        print(<span class="string">'My touch have a rectangle shape of size'</span>,</span><br><span class="line">              (touch.shape.width, touch.shape.height))</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<h4 id="双击"><a href="#双击" class="headerlink" title="双击"></a>双击</h4><p>双击是一次在一定距离内两次轻敲的动作。 由doubletap后处理模块计算得出。 您可以测试当前触摸是否是双击之一：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_touch_down</span><span class="params">(self, touch)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> touch.is_double_tap:</span><br><span class="line">        print(<span class="string">'Touch is a double tap !'</span>)</span><br><span class="line">        print(<span class="string">' - interval is'</span>, touch.double_tap_time)</span><br><span class="line">        print(<span class="string">' - distance between previous is'</span>, touch.double_tap_distance)</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<h4 id="三连击"><a href="#三连击" class="headerlink" title="三连击"></a>三连击</h4><p>三次轻击是在一个时间和距离内轻击三次的动作。 由三连击后处理模块计算得出。 您可以测试当前触摸是否是三次轻击之一：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_touch_down</span><span class="params">(self, touch)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> touch.is_triple_tap:</span><br><span class="line">        print(<span class="string">'Touch is a triple tap !'</span>)</span><br><span class="line">        print(<span class="string">' - interval is'</span>, touch.triple_tap_time)</span><br><span class="line">        print(<span class="string">' - distance between previous is'</span>, touch.triple_tap_distance)</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>

<h4 id="抓住触摸事件"><a href="#抓住触摸事件" class="headerlink" title="抓住触摸事件"></a>抓住触摸事件</h4><p>父窗口小部件可以通过<strong>inon_touch_down</strong>向其子窗口小部件发送触摸事件，而不能从<strong>on_touch_move</strong>或<strong>on_touch_up</strong>中向其分配事件。 在某些情况下可能会发生这种情况，例如当触摸运动位于父级的边界框之外时，因此父级决定不通知其子级该运动。</p>
<p>但是您可能想在<strong>on_touch_up</strong>中做一些事情。 假设您在<strong>on_touch_down</strong>事件中开始了某件事，例如播放声音，并且想在<strong>on_touch_up</strong>事件中完成某件事。您需要抓斗。</p>
<p>当您触摸时，将始终收到上移事件。但是抓取有一些限制：</p>
<ul>
<li>您将至少两次收到该事件：一次来自您的父母（正常事件），一次来自窗口（抓取）。</li>
<li>您可能会收到一个带有触摸式触摸的事件，但不是从您那里收到的：这可能是因为父级在触摸式触摸屏状态下已将触摸发送给了其子级。</li>
</ul>
<p>这是如何使用抓取的示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_touch_down</span><span class="params">(self, touch)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.collide_point(*touch.pos):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># if the touch collides with our widget, let's grab it</span></span><br><span class="line">        touch.grab(self)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># and accept the touch.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_touch_up</span><span class="params">(self, touch)</span>:</span></span><br><span class="line">    <span class="comment"># here, you don't check if the touch collides or things like that.</span></span><br><span class="line">    <span class="comment"># you just need to check if it's a grabbed touch event</span></span><br><span class="line">    <span class="keyword">if</span> touch.grab_current <span class="keyword">is</span> self:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># ok, the current touch is dispatched for us.</span></span><br><span class="line">        <span class="comment"># do something interesting here</span></span><br><span class="line">        print(<span class="string">'Hello world!'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># don't forget to ungrab ourself, or you might have side effects</span></span><br><span class="line">        touch.ungrab(self)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># and accept</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h4 id="触摸事件管理"><a href="#触摸事件管理" class="headerlink" title="触摸事件管理"></a>触摸事件管理</h4><p>为了查看如何在小部件之间控制和传播触摸事件，请参阅“小部件触摸事件冒泡”部分。</p>
<h3 id="游戏杆事件"><a href="#游戏杆事件" class="headerlink" title="游戏杆事件"></a>游戏杆事件</h3><p>操纵杆输入代表通过以下事件通过SDL2提供程序直接从物理或虚拟控制器接收的原始值：</p>
<ul>
<li>SDL_JOYAXISMOTION</li>
<li>SDL_JOYHATMOTION</li>
<li>SDL_JOYBALLMOTION</li>
<li>SDL_JOYBUTTONDOWN</li>
<li>SDL_JOYBUTTONUP</li>
</ul>
<p>每个运动事件都有一个最小值，最大值和默认值，可以达到：<br><img src="https://s2.ax1x.com/2020/02/15/1xXY6I.png" alt="1xXY6I.png"></p>
<p>另一方面，按钮事件基本上仅表示每个按钮的状态，即向上和向下，因此不存在这样的值。</p>
<ul>
<li>on_joy_button_up</li>
<li>on_joy_button_down</li>
</ul>
<h4 id="游戏杆事件基础"><a href="#游戏杆事件基础" class="headerlink" title="游戏杆事件基础"></a>游戏杆事件基础</h4><p>与触摸事件不同，操纵杆事件直接分派到Window，这意味着仅传递了一个值，例如 指定的轴，而不是多个轴。 如果您想将输入分离到不同的小部件，这将使事情变得更加困难，但这并非没有可能。 您可以使用Multiple dropfile示例作为灵感。</p>
<p>要获得操纵杆事件，首先需要将一些函数绑定到Window操纵杆事件，如下所示：</p>
<p><code>Window.bind(on_joy_axis=self.on_joy_axis)</code></p>
<p>然后，您需要为您使用的每个事件获取在Window中指定的参数，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_joy_axis</span><span class="params">(self, win, stickid, axisid, value)</span>:</span></span><br><span class="line">    print(win, stickid, axisid, value)</span><br></pre></td></tr></table></figure>
<p>变量stickid是发送值的控制器的ID，axisid是值所属的轴的ID。</p>
<h4 id="操纵杆输入"><a href="#操纵杆输入" class="headerlink" title="操纵杆输入"></a>操纵杆输入</h4><p>Kivy应该能够从指定为手柄，操纵杆的任何设备或基本上由SDL2提供程序识别的任何其他类型的游戏控制器中获取输入。 为了使事情变得容易，这里是一些通用控制器的布局以及每个部分的ID。</p>
<p>Xbox 360<br><img src="https://s2.ax1x.com/2020/02/15/1xjGUU.png" alt="1xjGUU.png"></p>
<h4 id="游戏杆调试"><a href="#游戏杆调试" class="headerlink" title="游戏杆调试"></a>游戏杆调试</h4><p>通常，您希望使用多个控制器调试应用程序，或针对_other_类型的控制器（例如，不同品牌）进行测试。 或者，您可能想使用一些可用的控制器仿真器，例如vJoy。</p>
<hr>
<p><strong>下一篇<span class="exturl" data-url="aHR0cDovL3d3dy5zaHVvc2h1b3l1bi5jbi9hcmNoaXZlcy80ODM4NS5odG1s">《Kivy参考文档（二）》<i class="fa fa-external-link-alt"></i></span></strong></p>
<hr>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Kivy</category>
      </categories>
      <tags>
        <tag>kivy</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome浏览器推荐插件</title>
    <url>/2020/02/07/9903/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Chrome浏览器，算是个人比较喜欢的一款浏览器吧，支持插件算是喜欢这类浏览器的主要原因了；当然，支持插件的浏览器还有其他的，比如火狐之类的，不过个人因为先用的 Chrome，很是喜欢，体验也想当的好，所以就没打算换其他的了。今天就来介绍一下 Chrome 浏览器个人比较喜欢的一些插件吧。</p>
<a id="more"></a>

<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h2 id="集装箱"><a href="#集装箱" class="headerlink" title="集装箱"></a>集装箱</h2><p>和它的名字一样，这是一个综合型的插件，主要的功能有这样四个：谷歌助手、网盘助手、优惠购以及下载卫士。推荐最先安装的一个插件，这是<span class="exturl" data-url="aHR0cHM6Ly9zaHVvc2h1b3l1bi5sYW56b3VzLmNvbS9pYmp0bzJm">链接<i class="fa fa-external-link-alt"></i></span>，有了它，就可以愉快的访问谷歌商店了，安装其他的插件自然不再话下~</p>
<ul>
<li><p><strong>谷歌助手</strong>，由于某些不可抗因素，我们通常无法直接访问谷歌网站。安装这个插件后，谷歌系的网站都能直接访问，包括我们下载插件需要的应用商店，也能直接访问。</p>
</li>
<li><p><strong>网盘助手</strong>，安装插件后支持自动填充提取码、自定义提取码以及一键生成分享链接等等，提升你的网盘实用效率。</p>
</li>
<li><p><strong>优惠购</strong>的功能是支持查询领取优惠券、显示各个购物网站的历史价格。</p>
</li>
<li><p><strong>下载卫士</strong>则是屏蔽各个下载网站的广告以及无关链接，都是非常实用的功能</p>
<p><img src="https://s2.ax1x.com/2020/02/08/1RqMrQ.png" alt="1RqMrQ.png"></p>
</li>
</ul>
<h2 id="Click-amp-Clean"><a href="#Click-amp-Clean" class="headerlink" title="Click&amp;Clean"></a>Click&amp;Clean</h2><p>经常清缓存，一键清缓存，这个插件不错</p>
<p><img src="https://s2.ax1x.com/2020/02/07/1g5vND.png" alt="1g5vND.png"></p>
<h2 id="Infinity新标签页-Pro"><a href="#Infinity新标签页-Pro" class="headerlink" title="Infinity新标签页(Pro)"></a>Infinity新标签页(Pro)</h2><p>可能是Chrome浏览器上最好用的新标签页</p>
<p><img src="https://s2.ax1x.com/2020/02/07/1gIjrq.png" alt="1gIjrq.png"></p>
<h2 id="Chrono下载管理器"><a href="#Chrono下载管理器" class="headerlink" title="Chrono下载管理器"></a>Chrono下载管理器</h2><p>完爆Chrome自带的下载器</p>
<p><img src="https://s2.ax1x.com/2020/02/07/1gooO1.png" alt="1gooO1.png"></p>
<h2 id="网页截图-注释-amp-录屏"><a href="#网页截图-注释-amp-录屏" class="headerlink" title="网页截图:注释&amp;录屏"></a>网页截图:注释&amp;录屏</h2><p> 录屏，捕获整个页面或任何部分，矩形，圆形，箭头，线条和文字，模糊敏感信息，一键上传分享注释。支持PNG和链接。</p>
<p> <img src="https://s2.ax1x.com/2020/02/08/1RLYTA.png" alt="1RLYTA.png"></p>
<h2 id="AdBlock-—-最佳广告拦截工具"><a href="#AdBlock-—-最佳广告拦截工具" class="headerlink" title="AdBlock — 最佳广告拦截工具"></a>AdBlock — 最佳广告拦截工具</h2><p> 网站上拦截广告和弹窗。</p>
<p> <img src="https://s2.ax1x.com/2020/02/08/1RLv6O.png" alt="1RLv6O.png"></p>
<h2 id="Free-VPN"><a href="#Free-VPN" class="headerlink" title="Free VPN"></a>Free VPN</h2><p> 科学上网工具，你懂的。</p>
<p> <img src="https://s2.ax1x.com/2020/02/08/1RONB4.png" alt="1RONB4.png"></p>
<h2 id="Tampermonkey"><a href="#Tampermonkey" class="headerlink" title="Tampermonkey"></a>Tampermonkey</h2><p>个人感觉是最为强大的一款插件了！一个脚本管理工具，可以去它推荐的网站去下载一些需要的脚本，从而实现各种黑科技~~</p>
<p><img src="https://s1.ax1x.com/2020/03/25/8vXMz4.png" alt="8vXMz4.png"></p>
<p>作者常用的脚本下载地址就一起推荐了：<span class="exturl" data-url="aHR0cHM6Ly9ncmVhc3lmb3JrLm9yZy96aC1DTg==">Greasy Fork<i class="fa fa-external-link-alt"></i></span></p>
<p><img src="https://s1.ax1x.com/2020/03/25/8vjD9U.png" alt="8vjD9U.png"></p>
<p>在右上角的脚本列表中有许许多多的好用的脚本，有需要的都可以安装；有其他需求的童鞋还可以自己搜索。</p>
<h2 id="沙拉查词"><a href="#沙拉查词" class="headerlink" title="沙拉查词"></a>沙拉查词</h2><p>一款非常方便的翻译插件，其中作者最为喜欢的就是它的划词翻译了，在某些不需要全网页翻译但是你又有一些不认识的单词或是句子的时候，只需要把这些单词或者句子选中，沙拉查词就会自动翻译出来。</p>
<p>而且翻译引擎也非常之多，总能选中你喜欢的且翻译准确的。</p>
<p><img src="https://s1.ax1x.com/2020/03/25/8vzPkq.png" alt="8vzPkq.png"></p>
<h2 id="OneTab"><a href="#OneTab" class="headerlink" title="OneTab"></a>OneTab</h2><p>不知道同学们有没有一种很烦恼的情况：浏览器打开的标签页太多了，以至于自己都找不到先要的网址是哪一个了，但是又不能随便乱关，，万一关了一个比较重要的，那就。。。要是你也有这种烦恼，那么，这款插件非常适合你！它可以一键将你打开的所有标签页全部收录起来，然后就可以轻松继续打开其他的网址了。另外，收录的标签页全部会以全称显示在 OneTab页面内，点击想要的就可以重新打开，那可是想当之方便！！！</p>
<p><img src="https://s1.ax1x.com/2020/03/25/8xSDaR.png" alt="8xSDaR.png"></p>
<h2 id="Xpath"><a href="#Xpath" class="headerlink" title="Xpath"></a>Xpath</h2><p>一款适用于开发人员的插件，配合 xpath 语法，用于提取目标网页的信息，个人感觉很好用~~所以在此推荐一下。</p>
<p><img src="https://s1.ax1x.com/2020/03/25/8x9GcT.png" alt="8x9GcT.png"></p>
<h2 id="二管家"><a href="#二管家" class="headerlink" title="二管家"></a>二管家</h2><p>一个用来管理插件的插件，可以方便的打开或者关闭其他的插件。并且适用于情景模式，切换不同的情景，自动打开关闭相应的插件。</p>
<p><img src="https://s1.ax1x.com/2020/03/25/8xCKKO.png" alt="8xCKKO.png"></p>
<h2 id="Octotree"><a href="#Octotree" class="headerlink" title="Octotree"></a>Octotree</h2><p>一款适用于 Github 的插件，可以在页面的左侧显示当前仓库的文件列表，可以很方便的在各个文件之间跳转，</p>
<p><img src="https://s1.ax1x.com/2020/03/25/8xPVeg.png" alt="8xPVeg.png"></p>
<hr>
<h1 id="手动安装插件方法"><a href="#手动安装插件方法" class="headerlink" title="手动安装插件方法"></a>手动安装插件方法</h1><p>(1) 从设置-&gt;扩展程序 打开扩展程序页面，或者地址栏输入 Chrome://extensions/ 按下回车打开扩展程序页面</p>
<p><img src="https://s2.ax1x.com/2020/02/08/1RXfLF.png" alt="1RXfLF.png"></p>
<p>(2) 打开扩展程序页面的“开发者模式</p>
<p><img src="https://s2.ax1x.com/2020/02/08/1RXTiR.png" alt="1RXTiR.png"></p>
<p>(3) 将crx文件拖拽到扩展程序页面，完成安装</p>
<h1 id="自动安装插件方法"><a href="#自动安装插件方法" class="headerlink" title="自动安装插件方法"></a>自动安装插件方法</h1><p>安装好<strong>集装箱</strong>插件后，就可以愉快的访问Chrome自带的<strong>网上应用店</strong>了，搜索想要的插件，直接安装就好了。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Chrome插件</category>
      </categories>
      <tags>
        <tag>Chrome插件</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机VMware buildozer的安装配置</title>
    <url>/2020/02/07/46753/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这段时间，由于新型冠状病毒的肆虐，寒假被延时了不知道多久，在家闲来无事学习了一下怎么用自己写的python代码打包成一个apk文件。</p>
<p>在网上寻找了良久，发现比较简单的方法就是直接下载一个虚拟机VirtualBox+已经配置好的系统kivydev.ova，然后就可以直接愉快的打包了。</p>
<a id="more"></a>

<p>虚拟机及系统的下载<span class="exturl" data-url="aHR0cDovL3Bhbi5iYWlkdS5jb20vcy8xZ2Y1UzhsUA==">链接<i class="fa fa-external-link-alt"></i></span>，密码：buj4</p>
<p>但是，在浪费了我16g流量后（一个系统只有大概4g，我第一次尝试下载用了12g，第二次用了4g，此处手动笑脸），发现他们的提供现有的系统我都装不上，尝试多次无果后，只有放弃，准备自己在自己的虚拟机VMware的ubuntu中配置一个环境。因而就有了下面的学习记录。</p>
<p>在此之前，先放上两个好东西：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9idWlsZG96ZXIucmVhZHRoZWRvY3MuaW8vZW4vbGF0ZXN0L2luc3RhbGxhdGlvbi5odG1s">Buildozer官方文档<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tpdnkvYnVpbGRvemVy">Buildozer项目页面<i class="fa fa-external-link-alt"></i></span></p>
<hr>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>ubuntu中pip3下载会很慢，建议修改下载源。</li>
<li>文中部分网址需要翻墙，须自己准备工具。<ul>
<li>本人是使用的Chrome浏览器，因此在Chrome的官方网上应用店就可以很方便的下载VPN插件。但是还是要翻墙，所以推荐一个国内插件下载的网站：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZXh0ZmFucy5jb20v">扩展迷<i class="fa fa-external-link-alt"></i></span>。手动安装插件的方法参见我的另一篇文章<span class="exturl" data-url="aHR0cDovL3d3dy5zaHVvc2h1b3l1bi5jbi9hcmNoaXZlcy85OTAzLmh0bWw=">Chrome浏览器推荐插件<i class="fa fa-external-link-alt"></i></span><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><code>pip3 install --user --upgrade buildozer</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><h4 id="找个例子"><a href="#找个例子" class="headerlink" title="找个例子"></a>找个例子</h4><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tpdnkva2l2eS9ibG9iL21hc3Rlci9leGFtcGxlcy9kZW1vL3BpY3R1cmVzL21haW4ucHk=">我是栗子<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><p><code>buildozer init</code></p>
<h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><p>初始化会在当前目录下生成一个<code>buildozer.spec</code>文件，需要文件进行简单的修改：</p>
<p><code>sublime buildozer.spec</code></p>
<ul>
<li>title：软件名称</li>
<li>package.name：安装包的名称</li>
<li>version：软件版本</li>
</ul>
<p>buildozer.spec详细介绍：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title</span><br><span class="line">为了避免某些字符可能引起的不工作，最好避免过长的标题，太长的标题到时候也可能不适应在App的图标下。</span><br><span class="line"> </span><br><span class="line">package.name</span><br><span class="line">package.name只能是一个单词，只能是由ASCII字符或数字组成，不应该包含特殊字符。比如说，如果你的应用叫Test One，那么package name就应该写成 testone。</span><br><span class="line"> </span><br><span class="line">package.domain</span><br><span class="line">这个应该填写的是制作这个App的公司或个人的名称，domain+name将会成为该应用对于Android 或iOS的标识。</span><br><span class="line"> </span><br><span class="line">source.dir</span><br><span class="line">填写包含main.py这些文件的目录路径，默认是在buildozer.spec所在的目录。</span><br><span class="line"> </span><br><span class="line">source.include_exts</span><br><span class="line">设置将扩展名符合该规则的文件包含进来。如果想将所有属于你自己的扩展名文件包含进来，直接将该值设置为空值，这样就能将所有东西包含进来了。</span><br><span class="line"> </span><br><span class="line">source.exclude_exts</span><br><span class="line">跟上面相对应的，这里设置的是不将符合该规则扩展名的文件包含进来。</span><br><span class="line"> </span><br><span class="line">source.exclude_dirs</span><br><span class="line">这里设置的是不将符合该规则的目录包含进来。比如说，如果不想将tests和bin目录包含进来的话，就进行如下设置。</span><br><span class="line"> </span><br><span class="line">source.exclude_dirs &#x3D; tests, bin</span><br><span class="line">version.regex</span><br><span class="line">使用正则表达式去捕捉version.filename文件内的version信息。默认的捕捉方法是在main.py里面查找类似下面一行的内容。</span><br><span class="line">__version__ &#x3D; &quot;1.0&quot;</span><br><span class="line">version.filename</span><br><span class="line">默认是指main.py文件</span><br><span class="line"> </span><br><span class="line">version</span><br><span class="line">用来自己手动设置version，如果你不想用捕捉的方法获取到version的话，你可以将version.regex 和 version.filename给注释掉，然后给version赋一个值，例如。</span><br><span class="line"> </span><br><span class="line"># version.regex &#x3D;</span><br><span class="line"># version.filename &#x3D;</span><br><span class="line">version &#x3D; 1.0</span><br><span class="line">requirements</span><br><span class="line">填写该App所需要的Python的模块或扩展模块</span><br><span class="line"> </span><br><span class="line">presplash.filename</span><br><span class="line">Presplash是应用刚打开加载时显示的图像，对于不同的平台presplash可能会有不同的要求，目前Buildozer在该方面对于Android的支持要好于iOS。图片的类型必须是JPG或PNG的，最好是2次幂的尺寸，比如说512X512类型的图片对于所有的机器运行都很好。Presplash图片是不会自己适应、伸缩屏幕的，如果提供在尺寸的图片，可能就不适合在小屏幕的机器上显示。</span><br><span class="line"> </span><br><span class="line">icon.filename</span><br><span class="line">应用的图标，作为图标的图片必须是512X512而且是PNG格式的，这样才能够适应很多平台的要求。</span><br><span class="line"> </span><br><span class="line">orientation</span><br><span class="line">指明该App支持的显示方向，默认是landscape（横向显示），也可以更改为portrait（竖向显示）或者是全部。</span><br><span class="line"> </span><br><span class="line">fullscreen</span><br><span class="line">该值为布尔类型的，默认是true，这样App就会运行在全屏的状态了，意味着状态栏将会被隐藏。如果想要让用户能够看到状态栏、时间、通知等内容的话，就应该将该值设置为0。</span><br></pre></td></tr></table></figure>

<p>有关新的规范文件，请参见<span class="exturl" data-url="aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2tpdnkvYnVpbGRvemVyL21hc3Rlci9idWlsZG96ZXIvZGVmYXVsdC5zcGVj">buildozer.spec<i class="fa fa-external-link-alt"></i></span></p>
<p>以下为详细介绍：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[app]</span><br><span class="line"></span><br><span class="line"># (str) Title of your application # 你的应用的标题</span><br><span class="line">title &#x3D; My Application</span><br><span class="line"></span><br><span class="line"># (str) Package name # 安装包名称</span><br><span class="line">package.name &#x3D; myapp</span><br><span class="line"></span><br><span class="line"># (str) Package domain (needed for android&#x2F;ios packaging) # 包域</span><br><span class="line">package.domain &#x3D; org.test</span><br><span class="line"></span><br><span class="line"># (str) Source code where the main.py live # main.py所在的源代码</span><br><span class="line">source.dir &#x3D; .</span><br><span class="line"></span><br><span class="line"># (list) Source files to include (let empty to include all the files) # 要包含的源文件（将其保留为空白以包含所有文件）</span><br><span class="line">source.include_exts &#x3D; py,png,jpg,kv,atlas</span><br><span class="line"></span><br><span class="line"># (list) List of inclusions using pattern matching # 使用模式匹配的内含物清单</span><br><span class="line">#source.include_patterns &#x3D; assets&#x2F;*,images&#x2F;*.png</span><br><span class="line"></span><br><span class="line"># (list) Source files to exclude (let empty to not exclude anything) # 要排除的源文件（为空不排除任何内容）</span><br><span class="line">#source.exclude_exts &#x3D; spec</span><br><span class="line"></span><br><span class="line"># (list) List of directory to exclude (let empty to not exclude anything) # 要排除的目录列表（如果为空，则不排除任何内容）</span><br><span class="line">#source.exclude_dirs &#x3D; tests, bin</span><br><span class="line"></span><br><span class="line"># (list) List of exclusions using pattern matching # 使用模式匹配排除列表</span><br><span class="line">#source.exclude_patterns &#x3D; license,images&#x2F;*&#x2F;*.jpg</span><br><span class="line"></span><br><span class="line"># (str) Application versioning (method 1) # 应用程序版本控制（方法1）</span><br><span class="line">version &#x3D; 0.1</span><br><span class="line"></span><br><span class="line"># (str) Application versioning (method 2) # 应用程序版本控制（方法2）</span><br><span class="line"># version.regex &#x3D; __version__ &#x3D; [&#39;&quot;](.*)[&#39;&quot;]</span><br><span class="line"># version.filename &#x3D; %(source.dir)s&#x2F;main.py</span><br><span class="line"></span><br><span class="line"># (list) Application requirements # 用用需求</span><br><span class="line"># comma separated e.g. requirements &#x3D; sqlite3,kivy</span><br><span class="line">requirements &#x3D; python3,kivy</span><br><span class="line"></span><br><span class="line"># (str) Custom source folders for requirements # 需求的自定义源文件夹</span><br><span class="line"># Sets custom source for any requirements with recipes # 为配方设置任何需求的自定义来源</span><br><span class="line"># requirements.source.kivy &#x3D; ..&#x2F;..&#x2F;kivy</span><br><span class="line"></span><br><span class="line"># (list) Garden requirements</span><br><span class="line">#garden_requirements &#x3D;</span><br><span class="line"></span><br><span class="line"># (str) Presplash of the application 应用程序的预启动图像</span><br><span class="line">#presplash.filename &#x3D; %(source.dir)s&#x2F;data&#x2F;presplash.png</span><br><span class="line"></span><br><span class="line"># (str) Icon of the application # 应用程序的图标</span><br><span class="line">#icon.filename &#x3D; %(source.dir)s&#x2F;data&#x2F;icon.png</span><br><span class="line"></span><br><span class="line"># (str) Supported orientation (one of landscape, sensorLandscape, portrait or all) # 支持的方向（横向，传感器横向，纵向或全部方向之一）</span><br><span class="line">orientation &#x3D; portrait</span><br><span class="line"></span><br><span class="line"># (list) List of service to declare # 申报服务清单</span><br><span class="line">#services &#x3D; NAME:ENTRYPOINT_TO_PY,NAME2:ENTRYPOINT2_TO_PY</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># OSX Specific</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># author &#x3D; © Copyright Info</span><br><span class="line"></span><br><span class="line"># change the major version of python used by the app # 更改应用程序使用的python的主要版本</span><br><span class="line">osx.python_version &#x3D; 3</span><br><span class="line"></span><br><span class="line"># Kivy version to use # 使用的Kivy版本</span><br><span class="line">osx.kivy_version &#x3D; 1.9.1</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Android specific</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># (bool) Indicate if the application should be fullscreen or not # 指示应用程序是否应全屏显示</span><br><span class="line">fullscreen &#x3D; 0</span><br><span class="line"></span><br><span class="line"># (string) Presplash background color (for new android toolchain)</span><br><span class="line"># Supported formats are: #RRGGBB #AARRGGBB or one of the following names:</span><br><span class="line"># red, blue, green, black, white, gray, cyan, magenta, yellow, lightgray,</span><br><span class="line"># darkgray, grey, lightgrey, darkgrey, aqua, fuchsia, lime, maroon, navy,</span><br><span class="line"># olive, purple, silver, teal.</span><br><span class="line">#android.presplash_color &#x3D; #FFFFFF</span><br><span class="line"></span><br><span class="line"># (list) Permissions</span><br><span class="line">#android.permissions &#x3D; INTERNET</span><br><span class="line"></span><br><span class="line"># (int) Target Android API, should be as high as possible.</span><br><span class="line">#android.api &#x3D; 27</span><br><span class="line"></span><br><span class="line"># (int) Minimum API your APK will support.</span><br><span class="line">#android.minapi &#x3D; 21</span><br><span class="line"></span><br><span class="line"># (int) Android SDK version to use</span><br><span class="line">#android.sdk &#x3D; 20</span><br><span class="line"></span><br><span class="line"># (str) Android NDK version to use</span><br><span class="line">#android.ndk &#x3D; 17c</span><br><span class="line"></span><br><span class="line"># (int) Android NDK API to use. This is the minimum API your app will support, it should usually match android.minapi.</span><br><span class="line">#android.ndk_api &#x3D; 21</span><br><span class="line"></span><br><span class="line"># (bool) Use --private data storage (True) or --dir public storage (False)</span><br><span class="line">#android.private_storage &#x3D; True</span><br><span class="line"></span><br><span class="line"># (str) Android NDK directory (if empty, it will be automatically downloaded.)</span><br><span class="line">#android.ndk_path &#x3D;</span><br><span class="line"></span><br><span class="line"># (str) Android SDK directory (if empty, it will be automatically downloaded.)</span><br><span class="line">#android.sdk_path &#x3D;</span><br><span class="line"></span><br><span class="line"># (str) ANT directory (if empty, it will be automatically downloaded.)</span><br><span class="line">#android.ant_path &#x3D;</span><br><span class="line"></span><br><span class="line"># (bool) If True, then skip trying to update the Android sdk</span><br><span class="line"># This can be useful to avoid excess Internet downloads or save time</span><br><span class="line"># when an update is due and you just want to test&#x2F;build your package</span><br><span class="line"># android.skip_update &#x3D; False</span><br><span class="line"></span><br><span class="line"># (bool) If True, then automatically accept SDK license</span><br><span class="line"># agreements. This is intended for automation only. If set to False,</span><br><span class="line"># the default, you will be shown the license when first running</span><br><span class="line"># buildozer.</span><br><span class="line"># android.accept_sdk_license &#x3D; False</span><br><span class="line"></span><br><span class="line"># (str) Android entry point, default is ok for Kivy-based app</span><br><span class="line">#android.entrypoint &#x3D; org.renpy.android.PythonActivity</span><br><span class="line"></span><br><span class="line"># (str) Android app theme, default is ok for Kivy-based app</span><br><span class="line"># android.apptheme &#x3D; &quot;@android:style&#x2F;Theme.NoTitleBar&quot;</span><br><span class="line"></span><br><span class="line"># (list) Pattern to whitelist for the whole project</span><br><span class="line">#android.whitelist &#x3D;</span><br><span class="line"></span><br><span class="line"># (str) Path to a custom whitelist file</span><br><span class="line">#android.whitelist_src &#x3D;</span><br><span class="line"></span><br><span class="line"># (str) Path to a custom blacklist file</span><br><span class="line">#android.blacklist_src &#x3D;</span><br><span class="line"></span><br><span class="line"># (list) List of Java .jar files to add to the libs so that pyjnius can access</span><br><span class="line"># their classes. Don&#39;t add jars that you do not need, since extra jars can slow</span><br><span class="line"># down the build process. Allows wildcards matching, for example:</span><br><span class="line"># OUYA-ODK&#x2F;libs&#x2F;*.jar</span><br><span class="line">#android.add_jars &#x3D; foo.jar,bar.jar,path&#x2F;to&#x2F;more&#x2F;*.jar</span><br><span class="line"></span><br><span class="line"># (list) List of Java files to add to the android project (can be java or a</span><br><span class="line"># directory containing the files)</span><br><span class="line">#android.add_src &#x3D;</span><br><span class="line"></span><br><span class="line"># (list) Android AAR archives to add (currently works only with sdl2_gradle</span><br><span class="line"># bootstrap)</span><br><span class="line">#android.add_aars &#x3D;</span><br><span class="line"></span><br><span class="line"># (list) Gradle dependencies to add (currently works only with sdl2_gradle</span><br><span class="line"># bootstrap)</span><br><span class="line">#android.gradle_dependencies &#x3D;</span><br><span class="line"></span><br><span class="line"># (list) add java compile options</span><br><span class="line"># this can for example be necessary when importing certain java libraries using the &#39;android.gradle_dependencies&#39; option</span><br><span class="line"># see https:&#x2F;&#x2F;developer.android.com&#x2F;studio&#x2F;write&#x2F;java8-support for further information</span><br><span class="line"># android.add_compile_options &#x3D; &quot;sourceCompatibility &#x3D; 1.8&quot;, &quot;targetCompatibility &#x3D; 1.8&quot;</span><br><span class="line"></span><br><span class="line"># (list) Gradle repositories to add &#123;can be necessary for some android.gradle_dependencies&#125;</span><br><span class="line"># please enclose in double quotes </span><br><span class="line"># e.g. android.gradle_repositories &#x3D; &quot;maven &#123; url &#39;https:&#x2F;&#x2F;kotlin.bintray.com&#x2F;ktor&#39; &#125;&quot;</span><br><span class="line">#android.add_gradle_repositories &#x3D;</span><br><span class="line"></span><br><span class="line"># (list) packaging options to add </span><br><span class="line"># see https:&#x2F;&#x2F;google.github.io&#x2F;android-gradle-dsl&#x2F;current&#x2F;com.android.build.gradle.internal.dsl.PackagingOptions.html</span><br><span class="line"># can be necessary to solve conflicts in gradle_dependencies</span><br><span class="line"># please enclose in double quotes </span><br><span class="line"># e.g. android.add_packaging_options &#x3D; &quot;exclude &#39;META-INF&#x2F;common.kotlin_module&#39;&quot;, &quot;exclude &#39;META-INF&#x2F;*.kotlin_module&#39;&quot;</span><br><span class="line">#android.add_gradle_repositories &#x3D;</span><br><span class="line"></span><br><span class="line"># (list) Java classes to add as activities to the manifest.</span><br><span class="line">#android.add_activites &#x3D; com.example.ExampleActivity</span><br><span class="line"></span><br><span class="line"># (str) OUYA Console category. Should be one of GAME or APP</span><br><span class="line"># If you leave this blank, OUYA support will not be enabled</span><br><span class="line">#android.ouya.category &#x3D; GAME</span><br><span class="line"></span><br><span class="line"># (str) Filename of OUYA Console icon. It must be a 732x412 png image.</span><br><span class="line">#android.ouya.icon.filename &#x3D; %(source.dir)s&#x2F;data&#x2F;ouya_icon.png</span><br><span class="line"></span><br><span class="line"># (str) XML file to include as an intent filters in &lt;activity&gt; tag</span><br><span class="line">#android.manifest.intent_filters &#x3D;</span><br><span class="line"></span><br><span class="line"># (str) launchMode to set for the main activity</span><br><span class="line">#android.manifest.launch_mode &#x3D; standard</span><br><span class="line"></span><br><span class="line"># (list) Android additional libraries to copy into libs&#x2F;armeabi</span><br><span class="line">#android.add_libs_armeabi &#x3D; libs&#x2F;android&#x2F;*.so</span><br><span class="line">#android.add_libs_armeabi_v7a &#x3D; libs&#x2F;android-v7&#x2F;*.so</span><br><span class="line">#android.add_libs_arm64_v8a &#x3D; libs&#x2F;android-v8&#x2F;*.so</span><br><span class="line">#android.add_libs_x86 &#x3D; libs&#x2F;android-x86&#x2F;*.so</span><br><span class="line">#android.add_libs_mips &#x3D; libs&#x2F;android-mips&#x2F;*.so</span><br><span class="line"></span><br><span class="line"># (bool) Indicate whether the screen should stay on</span><br><span class="line"># Don&#39;t forget to add the WAKE_LOCK permission if you set this to True</span><br><span class="line">#android.wakelock &#x3D; False</span><br><span class="line"></span><br><span class="line"># (list) Android application meta-data to set (key&#x3D;value format)</span><br><span class="line">#android.meta_data &#x3D;</span><br><span class="line"></span><br><span class="line"># (list) Android library project to add (will be added in the</span><br><span class="line"># project.properties automatically.)</span><br><span class="line">#android.library_references &#x3D;</span><br><span class="line"></span><br><span class="line"># (list) Android shared libraries which will be added to AndroidManifest.xml using &lt;uses-library&gt; tag</span><br><span class="line">#android.uses_library &#x3D;</span><br><span class="line"></span><br><span class="line"># (str) Android logcat filters to use</span><br><span class="line">#android.logcat_filters &#x3D; *:S python:D</span><br><span class="line"></span><br><span class="line"># (bool) Copy library instead of making a libpymodules.so</span><br><span class="line">#android.copy_libs &#x3D; 1</span><br><span class="line"></span><br><span class="line"># (str) The Android arch to build for, choices: armeabi-v7a, arm64-v8a, x86, x86_64</span><br><span class="line">android.arch &#x3D; armeabi-v7a</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># Python for android (p4a) specific</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># (str) python-for-android fork to use, defaults to upstream (kivy)</span><br><span class="line">#p4a.fork &#x3D; kivy</span><br><span class="line"></span><br><span class="line"># (str) python-for-android branch to use, defaults to master</span><br><span class="line">#p4a.branch &#x3D; master</span><br><span class="line"></span><br><span class="line"># (str) python-for-android git clone directory (if empty, it will be automatically cloned from github)</span><br><span class="line">#p4a.source_dir &#x3D;</span><br><span class="line"></span><br><span class="line"># (str) The directory in which python-for-android should look for your own build recipes (if any)</span><br><span class="line">#p4a.local_recipes &#x3D;</span><br><span class="line"></span><br><span class="line"># (str) Filename to the hook for p4a</span><br><span class="line">#p4a.hook &#x3D;</span><br><span class="line"></span><br><span class="line"># (str) Bootstrap to use for android builds</span><br><span class="line"># p4a.bootstrap &#x3D; sdl2</span><br><span class="line"></span><br><span class="line"># (int) port number to specify an explicit --port&#x3D; p4a argument (eg for bootstrap flask)</span><br><span class="line">#p4a.port &#x3D;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># iOS specific</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># (str) Path to a custom kivy-ios folder</span><br><span class="line">#ios.kivy_ios_dir &#x3D; ..&#x2F;kivy-ios</span><br><span class="line"># Alternately, specify the URL and branch of a git checkout:</span><br><span class="line">ios.kivy_ios_url &#x3D; https:&#x2F;&#x2F;github.com&#x2F;kivy&#x2F;kivy-ios</span><br><span class="line">ios.kivy_ios_branch &#x3D; master</span><br><span class="line"></span><br><span class="line"># Another platform dependency: ios-deploy</span><br><span class="line"># Uncomment to use a custom checkout</span><br><span class="line">#ios.ios_deploy_dir &#x3D; ..&#x2F;ios_deploy</span><br><span class="line"># Or specify URL and branch</span><br><span class="line">ios.ios_deploy_url &#x3D; https:&#x2F;&#x2F;github.com&#x2F;phonegap&#x2F;ios-deploy</span><br><span class="line">ios.ios_deploy_branch &#x3D; 1.7.0</span><br><span class="line"></span><br><span class="line"># (str) Name of the certificate to use for signing the debug version</span><br><span class="line"># Get a list of available identities: buildozer ios list_identities</span><br><span class="line">#ios.codesign.debug &#x3D; &quot;iPhone Developer: &lt;lastname&gt; &lt;firstname&gt; (&lt;hexstring&gt;)&quot;</span><br><span class="line"></span><br><span class="line"># (str) Name of the certificate to use for signing the release version</span><br><span class="line">#ios.codesign.release &#x3D; %(ios.codesign.debug)s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[buildozer]</span><br><span class="line"></span><br><span class="line"># (int) Log level (0 &#x3D; error only, 1 &#x3D; info, 2 &#x3D; debug (with command output))</span><br><span class="line">log_level &#x3D; 2</span><br><span class="line"></span><br><span class="line"># (int) Display warning if buildozer is run as root (0 &#x3D; False, 1 &#x3D; True)</span><br><span class="line">warn_on_root &#x3D; 1</span><br><span class="line"></span><br><span class="line"># (str) Path to build artifact storage, absolute or relative to spec file</span><br><span class="line"># build_dir &#x3D; .&#x2F;.buildozer</span><br><span class="line"></span><br><span class="line"># (str) Path to build output (i.e. .apk, .ipa) storage</span><br><span class="line"># bin_dir &#x3D; .&#x2F;bin</span><br><span class="line"></span><br><span class="line">#    -----------------------------------------------------------------------------</span><br><span class="line">#    List as sections</span><br><span class="line">#</span><br><span class="line">#    You can define all the &quot;list&quot; as [section:key].</span><br><span class="line">#    Each line will be considered as a option to the list.</span><br><span class="line">#    Let&#39;s take [app] &#x2F; source.exclude_patterns.</span><br><span class="line">#    Instead of doing:</span><br><span class="line">#</span><br><span class="line">#[app]</span><br><span class="line">#source.exclude_patterns &#x3D; license,data&#x2F;audio&#x2F;*.wav,data&#x2F;images&#x2F;original&#x2F;*</span><br><span class="line">#</span><br><span class="line">#    This can be translated into:</span><br><span class="line">#</span><br><span class="line">#[app:source.exclude_patterns]</span><br><span class="line">#license</span><br><span class="line">#data&#x2F;audio&#x2F;*.wav</span><br><span class="line">#data&#x2F;images&#x2F;original&#x2F;*</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#    -----------------------------------------------------------------------------</span><br><span class="line">#    Profiles</span><br><span class="line">#</span><br><span class="line">#    You can extend section &#x2F; key with a profile</span><br><span class="line">#    For example, you want to deploy a demo version of your application without</span><br><span class="line">#    HD content. You could first change the title to add &quot;(demo)&quot; in the name</span><br><span class="line">#    and extend the excluded directories to remove the HD content.</span><br><span class="line">#</span><br><span class="line">#[app@demo]</span><br><span class="line">#title &#x3D; My Application (demo)</span><br><span class="line">#</span><br><span class="line">#[app:source.exclude_patterns@demo]</span><br><span class="line">#images&#x2F;hd&#x2F;*</span><br><span class="line">#</span><br><span class="line">#    Then, invoke the command line with the &quot;demo&quot; profile:</span><br><span class="line">#</span><br><span class="line">#buildozer --profile demo android debug</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>按照官方文档：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install -y git zip unzip openjdk-8-jdk python3-pip autoconf libtool pkg-config zlib1g-dev libncurses5-dev libncursesw5-dev libtinfo5 cmake libffi-dev</span><br><span class="line">pip3 install --user --upgrade cython virtualenv</span><br></pre></td></tr></table></figure>

<h3 id="打包封装"><a href="#打包封装" class="headerlink" title="打包封装"></a>打包封装</h3><p><strong>注意，打包所需的.py文件名称必须为<code>main</code></strong></p>
<p><code>buildozer -v android debug</code></p>
<p>它会下载 Android SDK, NDK 和其他工具，需要下载很久很久，我第一次弄的时候一直卡在<code>python-for-android</code>这里一直无法动弹，后面处于尝试的心里，停止打包，重新输入命令<code>pip3 install python-for-android</code>，手动安装<code>python-for-android</code>。然后再重新输入命令<code>buildozer -v android debug</code>。</p>
<p>成功后会在当前目录下的<code>bin\</code>目录下生成apk文件。</p>
<h3 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h3><p>本来在第一次安装结束后尝试打包时出现了一个错误：大概意思就是Buildozer无法执行最后一条命令。在网上寻找了很久也没有找到答案。</p>
<p>后来换了一个路径后重新<code>pip3 install python-for-android</code>（其实我自己也不知道要不要，感觉不需要~），然后再尝试就成功了…别问我为什么，我也不知道。在第二次确认自己是否配置成功的时候发现，第二次打包也需要很长的时间，也就是以后每一次都需要很多的时间，不过这些不重要，能用就行。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Buildozer</category>
      </categories>
      <tags>
        <tag>Buildozer</tag>
      </tags>
  </entry>
  <entry>
    <title>Pycharm 快捷键</title>
    <url>/2020/02/01/13294/</url>
    <content><![CDATA[<h3 id="Alt-Shift"><a href="#Alt-Shift" class="headerlink" title="Alt+Shift"></a>Alt+Shift</h3><p><code>Alt+Shift+c</code> 查看最近修改</p>
<a id="more"></a>

<hr>
<h3 id="Ctrl"><a href="#Ctrl" class="headerlink" title="Ctrl"></a>Ctrl</h3><p><code>Ctrl+鼠标左键</code> 查看函数源码</p>
<hr>
<h3 id="Ctrl-Shift"><a href="#Ctrl-Shift" class="headerlink" title="Ctrl+Shift"></a>Ctrl+Shift</h3><p><code>Ctrl+Shift+F11</code> 建立/取消标签</p>
<hr>
<h3 id="Shift"><a href="#Shift" class="headerlink" title="Shift"></a>Shift</h3><p><code>Shift+F2</code> 定位到错误行</p>
<p><code>Shift+F11</code> 打开标签库</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>pycharm</category>
      </categories>
      <tags>
        <tag>pycharm</tag>
      </tags>
  </entry>
</search>
